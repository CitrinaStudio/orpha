/* Generated code for Python source for module 'pycparser.c_parser'
 * created by Nuitka version 0.5.27
 *
 * This code is in part copyright 2017 Kay Hayen.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "nuitka/prelude.h"

#include "__helpers.h"

/* The _module_pycparser$c_parser is a Python object pointer of module type. */

/* Note: For full compatibility with CPython, every module variable access
 * needs to go through it except for cases where the module cannot possibly
 * have changed in the mean time.
 */

PyObject *module_pycparser$c_parser;
PyDictObject *moduledict_pycparser$c_parser;

/* The module constants used, if any. */
static PyObject *const_str_digest_94f4c600d0330853c740c988770a5205;
static PyObject *const_str_digest_e8f9383a162dfbf1f03d39b53d3b5fc9;
static PyObject *const_str_plain_p_jump_statement_4;
static PyObject *const_str_plain_initializer_list;
static PyObject *const_str_digest_aeedbaa90a2ea63d79afdc2349fb7597;
static PyObject *const_str_digest_dae376c9624166cef9d09e7b5e652d77;
static PyObject *const_str_plain__build_declarations;
static PyObject *const_tuple_str_plain_typeid_noparen_str_plain_TYPEID_tuple;
static PyObject *const_str_plain_p_direct_abstract_declarator_4;
static PyObject *const_str_digest_4f9513954810f933174045a85cc3a2ab;
static PyObject *const_str_digest_b662c5a69a6a4f6634e2c2fb3d230a44;
extern PyObject *const_dict_empty;
extern PyObject *const_int_pos_9;
static PyObject *const_str_digest_79346a7e0deb4b73cbe7b4194fb4e2e9;
extern PyObject *const_str_plain_last_token;
extern PyObject *const_tuple_str_empty_int_0_tuple;
static PyObject *const_str_digest_e28583a0c8281162e1d6bb9bcf52a53f;
static PyObject *const_str_plain_declaration_specifiers_no_type;
static PyObject *const_str_digest_245e706123acd66a0d916383148f8b39;
static PyObject *const_str_digest_17335b6423c53852abc4fa386f487ebf;
static PyObject *const_str_digest_e01ad3fcfb8f2ceeb611d950f8bc575c;
static PyObject *const_str_digest_68c0be9602cedbb187213fbf197fea5b;
static PyObject *const_str_digest_030e172aedb3e27ebaa801170da02568;
extern PyObject *const_str_angle_listcontraction;
static PyObject *const_str_digest_d64b22c7e8bcf5726624a0a905a39454;
static PyObject *const_str_digest_72424e08fc91bf13cdbee5746dacdd3f;
static PyObject *const_str_digest_6540d053a4745d3499d98b3c1b137fdc;
static PyObject *const_str_digest_e24f977f6803d5f0c297c89e5fb42201;
static PyObject *const_str_digest_d3b46ce600868fd3d7716c8dd7a08173;
static PyObject *const_str_plain_p_declaration_specifiers_no_type_2;
static PyObject *const_str_digest_f67d5f062350872f4b7a3431eb8ff9ef;
static PyObject *const_str_digest_d26c56e6f12d65901f9ea8a848bbf06f;
static PyObject *const_str_plain_debuglevel;
extern PyObject *const_str_plain_EllipsisParam;
static PyObject *const_str_plain_p_parameter_type_list;
static PyObject *const_str_digest_e664f998ac5740d2a3a6c87d0e4d9671;
static PyObject *const_str_plain_s_u_or_e;
static PyObject *const_str_digest_317c273604af4de5e262e646925688c4;
static PyObject *const_str_digest_80150a5bbe00013c9a11609bcac2921e;
static PyObject *const_str_plain_typeid_noparen;
extern PyObject *const_str_plain_FuncCall;
static PyObject *const_tuple_str_plain_self_str_plain_p_str_plain_arr_tuple;
extern PyObject *const_int_pos_5;
static PyObject *const_tuple_0ea225ba60de122d0cbb5d84b83eeb1c_tuple;
static PyObject *const_str_digest_32f37d7b1e094bf932b7a1d06bfa5763;
extern PyObject *const_str_plain_Return;
static PyObject *const_str_digest_5dd9b87f6fa196442177a7da624a6140;
extern PyObject *const_str_plain_TYPEID;
static PyObject *const_dict_2c030ba937b9e185526e262591ee7db7;
static PyObject *const_str_digest_f8343e16e92e519e6585339ebb169a13;
extern PyObject *const_str_plain_Compound;
extern PyObject *const_str_plain_quals;
static PyObject *const_str_plain_in_scope;
static PyObject *const_str_digest_df1d3e1503202a90612746b6071f8fc8;
static PyObject *const_str_digest_1f8992215f1ce67405c35060612647fa;
static PyObject *const_str_digest_f8f063e2d73853aff8adc792b438908e;
extern PyObject *const_str_plain_start;
static PyObject *const_str_plain_p_external_declaration_3;
static PyObject *const_str_plain_p_external_declaration_4;
extern PyObject *const_tuple_none_none_none_tuple;
static PyObject *const_str_digest_30531a534a7c297aabfd46265292dec4;
static PyObject *const_str_digest_1a96c17db4422135332fc034b84b4f5e;
static PyObject *const_str_digest_705568b41dc44e9db67a41d3b2108e29;
static PyObject *const_str_plain_p_id_init_declarator;
static PyObject *const_str_digest_325218adecc4f0228a24278fb5234c18;
static PyObject *const_str_digest_613ba6a44a1d56c696caece48ebdb21e;
extern PyObject *const_str_plain_ply;
static PyObject *const_str_plain_decls_0_tail;
static PyObject *const_str_digest_61cb30757fb84ded43723d45db63c47d;
static PyObject *const_str_digest_2ee573711e350e5fa9f7994e07f7d359;
extern PyObject *const_str_plain_Decl;
static PyObject *const_str_plain_p_assignment_expression;
static PyObject *const_tuple_str_plain_self_str_plain_p_str_plain_typename_tuple;
static PyObject *const_str_digest_1d80facf566b625aa32b1f97e9f80fdc;
static PyObject *const_str_plain_p_designator;
static PyObject *const_str_plain_p_jump_statement_2;
static PyObject *const_str_digest_fb8cb72a47e4e6a97db78d6f2a14c1a9;
static PyObject *const_str_digest_b2165be07d44c0536d62b0ea0314fef6;
static PyObject *const_str_plain_identifier_list;
static PyObject *const_str_digest_3f66b33dcd02380a3b34f7c175ab47ca;
static PyObject *const_str_digest_17cc52e14b6c1f7ad77cb5c85591f124;
static PyObject *const_str_digest_49258e4a03bd2250dfb8cbfdcea029e5;
static PyObject *const_str_plain_p_offsetof_member_designator;
static PyObject *const_str_digest_eeeb606ddede2757ab34e6f6c30e8cfc;
static PyObject *const_str_digest_dd774f65546147d7cec683569068da92;
extern PyObject *const_str_plain_dim;
extern PyObject *const_str_plain_StructRef;
static PyObject *const_str_digest_d5664c5531b4d8c20886d97ceb88d02f;
static PyObject *const_str_digest_d13b4c87d8a8852eb743b212f8d676d6;
static PyObject *const_tuple_str_plain_id_str_plain_ID_tuple;
static PyObject *const_str_plain_declspec;
extern PyObject *const_int_pos_8;
static PyObject *const_str_digest_f31c05fd6230f58c972a6b1f6469cc4a;
static PyObject *const_tuple_814fd99db7b828bfc5d54aae3ba8f30f_tuple;
static PyObject *const_str_plain_p_pppragma_directive;
static PyObject *const_str_digest_f7773303a76f0396c72f44ccc6cdac61;
static PyObject *const_str_digest_891e4ef06043254cd6f550a053fcf199;
static PyObject *const_str_plain_p_pp_directive;
extern PyObject *const_str_plain_Typename;
static PyObject *const_tuple_str_plain_self_str_plain_p_str_plain_func_str_plain_param_tuple;
static PyObject *const_str_digest_926cbb8fdd1f46d7626b4cc0e214cfd0;
static PyObject *const_str_digest_5ce94e49f4392eb90c8c6d62708b5382;
extern PyObject *const_str_plain_name;
static PyObject *const_str_digest_aa4b6ff9cb7b7e2de6145f81e4b024a4;
extern PyObject *const_str_plain__create_opt_rule;
extern PyObject *const_str_plain_InitList;
static PyObject *const_str_digest_a095f2bdede86bb9b3571d87f15a4f3c;
static PyObject *const_list_92f625f2146505b2a221686ca03ee1cd_list;
static PyObject *const_str_digest_dd3def542e52a4ea9e23e75851f4878e;
static PyObject *const_str_digest_c244982f392d01a9847bfb619bd7437c;
static PyObject *const_str_plain__last_yielded_token;
static PyObject *const_str_plain_abstract_declarator;
extern PyObject *const_str_plain_TernaryOp;
static PyObject *const_str_digest_98df06d490521f0a00d6ac5b08c499e6;
static PyObject *const_str_plain_p_identifier_list;
extern PyObject *const_str_plain_lineno;
static PyObject *const_str_plain_p_struct_declaration_1;
extern PyObject *const_str_plain_dim_quals;
static PyObject *const_str_plain_p_direct_xxx_declarator_6;
static PyObject *const_str_digest_c2c7438f6f3ab6e2ae34cf42aec88484;
static PyObject *const_str_plain__fix_decl_name_type;
extern PyObject *const_str_plain_pop;
extern PyObject *const_int_0;
static PyObject *const_str_plain_p_constant_2;
static PyObject *const_str_plain_p_parameter_declaration_2;
extern PyObject *const_str_plain_Cast;
static PyObject *const_str_digest_3d1c1b5a40bad5ea2b53479303af8ac3;
static PyObject *const_str_digest_c42ba573360bdf98cc14a40131013fc8;
static PyObject *const_str_digest_6dbcd0ad6d3e522de8841a8354327179;
static PyObject *const_str_digest_10f37e3bff7e991e751e7269ffabadb0;
static PyObject *const_str_plain_p_selection_statement_1;
static PyObject *const_str_digest_25da212803d8c0d225df3dfd19d548d9;
static PyObject *const_str_digest_eb511689ea0dfd7ea92bdc676c27cead;
static PyObject *const_str_plain_p_direct_xxx_declarator_5;
extern PyObject *const_str_plain_cparser;
extern PyObject *const_int_pos_4;
static PyObject *const_str_digest_641c74115009f84216dbefa5d7bd4004;
static PyObject *const_str_digest_c7dec89123121915f4b9612d61ec875a;
static PyObject *const_str_plain_p_compound_statement_1;
extern PyObject *const_str_plain_ArrayDecl;
extern PyObject *const_str_plain_set_lineno;
extern PyObject *const_str_plain_type;
extern PyObject *const_str_plain_Case;
static PyObject *const_str_digest_1b8d0d478bf813fa092f6bca5ef1c206;
static PyObject *const_str_digest_6bc7376195f70b4ee319b4b195df915c;
static PyObject *const_str_plain_p_struct_or_union_specifier_3;
static PyObject *const_str_plain_rules_with_opt;
static PyObject *const_str_digest_3d708f088baf2d9fe04b4d4c3d1048e2;
static PyObject *const_str_plain_declaration_list;
extern PyObject *const_str_plain_is_typedef;
static PyObject *const_str_plain_p_translation_unit_1;
extern PyObject *const_str_plain_optimize;
extern PyObject *const_str_plain___cached__;
static PyObject *const_tuple_str_plain_typeid_str_plain_TYPEID_tuple;
static PyObject *const_str_digest_63caba6a8655f13f8d6329090735eda2;
static PyObject *const_str_digest_4d2282977f5acc83443a234c654eb96e;
static PyObject *const_str_digest_4283807529d6bc7d66fde2041c90b214;
static PyObject *const_tuple_08c0da61fe57987f4fb46301e9d60b83_tuple;
static PyObject *const_str_plain_p_id_init_declarator_list;
static PyObject *const_str_plain_rule;
static PyObject *const_str_digest_47c288e3e3c1ec5382a287f33b329e55;
static PyObject *const_str_digest_e5e2ab4a197a763e089302e170784084;
static PyObject *const_str_plain_p_type_qualifier;
static PyObject *const_str_digest_9003243efa0c0ecc239aa9a62dcb65fd;
extern PyObject *const_str_plain_on_rbrace_func;
static PyObject *const_str_plain_block_item_list;
extern PyObject *const_int_pos_1;
static PyObject *const_str_plain_p_specifier_qualifier_list_1;
static PyObject *const_str_digest_91fe4d48c7f332f506ad592767e0b1fa;
static PyObject *const_str_plain_p_struct_declaration_2;
static PyObject *const_dict_a65047c1ba5fd08918aea9f317bf9947;
extern PyObject *const_str_plain_field;
extern PyObject *const_str_plain_outputdir;
static PyObject *const_str_plain_p_primary_expression_5;
extern PyObject *const_str_plain_find_tok_column;
static PyObject *const_str_plain_tn;
static PyObject *const_str_plain_p_primary_expression_2;
extern PyObject *const_str_plain___prepare__;
static PyObject *const_str_digest_b754de9b97f0b72d6dd37dec82ba5746;
static PyObject *const_str_plain_p_declaration;
static PyObject *const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_item_tuple;
static PyObject *const_str_plain_p_specifier_qualifier_list_2;
static PyObject *const_str_digest_d642d0fe838aefefa0b9280cc6a39a38;
static PyObject *const_str_digest_d6ee975e0df9eca8d5440193b813bd7d;
static PyObject *const_str_digest_6f2181aeaf73e778ef8fef0fecb260be;
static PyObject *const_str_plain_p_struct_declaration_list;
extern PyObject *const_str_plain_module;
static PyObject *const_str_plain_p_declaration_list;
static PyObject *const_str_digest_1e69359fa796c1d395f6ed6e958b1038;
static PyObject *const_str_digest_738bb76ee3cb1d75ac2eedcc90bfedb8;
static PyObject *const_tuple_list_str_plain_int_list_tuple;
static PyObject *const_str_plain_p_struct_or_union_specifier_1;
static PyObject *const_str_digest_12b5d80dbab35a1fee3c7294bdecc060;
extern PyObject *const_str_plain_build;
static PyObject *const_str_plain__add_identifier;
static PyObject *const_str_digest_73b402b81d578988831576aa55cece06;
static PyObject *const_str_digest_2cf67ea0a03b2cf611b58d5daaa1326b;
static PyObject *const_str_plain_p_declaration_specifiers_no_type_1;
extern PyObject *const_str_plain_ParamList;
static PyObject *const_str_digest_c7350461c8319ccb9b869ca9d757d071;
static PyObject *const_str_digest_3aa1bda91d8a187cb1cfaa05f37e2a9a;
static PyObject *const_str_digest_b3256d0808a5cfa78a9b07f0014ae192;
static PyObject *const_str_plain_p_direct_xxx_declarator_2;
static PyObject *const_str_plain_p_parameter_list;
static PyObject *const_str_digest_229a95fb3332065f431f76ad875a569b;
static PyObject *const_str_digest_cef2fc285c8d4fd024540eafb50e5036;
static PyObject *const_str_digest_246f58de0d8282544b0f16b8e9adffe7;
static PyObject *const_str_digest_edc88e6e620d04e505071707ba4525ca;
static PyObject *const_str_digest_8ecbd0539063d98b175e5d1b148373e4;
static PyObject *const_str_plain_p_constant_expression;
extern PyObject *const_str_plain_yacc;
extern PyObject *const_str_plain_IdentifierType;
static PyObject *const_str_digest_59d40c66bd1068fb9a5fac1ba3853f9d;
static PyObject *const_tuple_dbc31fde9862f09a6a68bd61c7b8a34c_tuple;
static PyObject *const_str_plain_modifier_head;
static PyObject *const_str_plain_p_conditional_expression;
extern PyObject *const_str_plain_TypeDecl;
static PyObject *const_str_plain_p_brace_open;
extern PyObject *const_str_plain_string;
static PyObject *const_str_digest_e1c12c8d1dab799b69e07b9066071ae2;
static PyObject *const_str_plain_nested_type;
extern PyObject *const_slice_int_pos_1_none_none;
extern PyObject *const_str_plain___file__;
static PyObject *const_str_digest_26372fde2775fe57a8247ee618f79642;
static PyObject *const_str_plain_p_declaration_specifiers_6;
static PyObject *const_str_digest_680cc8fadbfc312c9e9abfca1ee7a562;
extern PyObject *const_str_plain_struct;
static PyObject *const_str_digest_0469223446185989541f16e54e881c26;
static PyObject *const_str_plain_p_declarator;
static PyObject *const_str_digest_c0efe027b7adc1ecc803adc6bf777f4f;
static PyObject *const_str_digest_1fca5d0e9bc76c0e07b262792fd8e99e;
static PyObject *const_str_plain_p_pointer;
static PyObject *const_str_digest_a5744676b3080c705bd7d08f2eeaded7;
static PyObject *const_str_digest_7525f41ae25b32b5ae040b76992d907b;
extern PyObject *const_str_plain_storage;
static PyObject *const_str_digest_76ad672554caf5e4ae0ce3d708784295;
extern PyObject *const_str_plain_CLexer;
static PyObject *const_str_digest_5528a54872ed3f6e644fc93ddc6e4329;
static PyObject *const_str_digest_4c53af9b18e731d13a6eaff3cd61c1bd;
static PyObject *const_str_digest_a20a4a402871289db2df557bee02c305;
static PyObject *const_str_digest_7c7abce5be464c1a2373a819305d6607;
extern PyObject *const_str_plain_func;
static PyObject *const_str_digest_5ee1bd137846e03700116c37b66c1e9a;
static PyObject *const_str_plain__get_yacc_lookahead_token;
extern PyObject *const_str_plain_names;
static PyObject *const_str_plain_p_selection_statement_3;
extern PyObject *const_tuple_int_pos_1_tuple;
static PyObject *const_str_digest_e13114f89598d7e65c91b632f0cadbb8;
static PyObject *const_str_digest_4bcc04ea9ec07560edae21db6b5348a0;
static PyObject *const_str_digest_47d71f45ed595c6bc27351f58c7aaad0;
static PyObject *const_tuple_str_plain_self_str_plain_p_str_plain_klass_tuple;
static PyObject *const_str_digest_218c48307caf6bfda88fe53635606a43;
static PyObject *const_str_digest_c921c8f322b3fd46a59553d2e5dfc401;
static PyObject *const_str_digest_c5fd27a7e790f10912398117eb633879;
static PyObject *const_str_digest_8a34c5f5b79e2060c67f54d2ea359c5c;
extern PyObject *const_str_plain_decls;
static PyObject *const_str_digest_67949f32b9c50c7570da61d6f3116a3c;
static PyObject *const_str_plain__lex_type_lookup_func;
static PyObject *const_str_plain_modifier;
static PyObject *const_str_plain_p_empty;
extern PyObject *const_str_plain_template;
static PyObject *const_str_plain_p_identifier;
static PyObject *const_str_digest_e362d81bd9b3e85900445f8c349b8841;
extern PyObject *const_str_plain___qualname__;
static PyObject *const_str_digest_df2387d02cc8652fc0588206818d2a5b;
static PyObject *const_str_plain_p_iteration_statement_1;
static PyObject *const_str_plain_p_function_definition_1;
extern PyObject *const_tuple_str_plain_self_str_plain_p_str_plain_func_tuple;
static PyObject *const_str_digest_99ef339a31ce34c0e20749e73057955b;
static PyObject *const_str_digest_8e675f7522c50836436091bad083eade;
extern PyObject *const_str_plain_FuncDef;
static PyObject *const_str_plain_LBRACE;
extern PyObject *const_str_plain_p;
static PyObject *const_str_digest_6e95ffeb0e7816beaeca0e8f138f7c30;
extern PyObject *const_str_plain_value;
static PyObject *const_str_plain_p_declaration_specifiers_3;
extern PyObject *const_str_plain_insert;
static PyObject *const_tuple_str_plain_self_str_plain_p_str_plain_init_tuple;
static PyObject *const_str_digest_67292cb13e9197e2fb2c1781dd68cf71;
static PyObject *const_str_digest_388dfcadefec749acf799f03439e30db;
static PyObject *const_str_digest_4b825c9f3babefb0715ce67102552636;
static PyObject *const_str_plain_p_declaration_specifiers_5;
static PyObject *const_str_digest_420d2d0b3c68fd79b820d0f6672b0a25;
extern PyObject *const_str_plain_Assignment;
static PyObject *const_str_digest_6ab508e6c2405e1a94cf3d2c7c0831cb;
static PyObject *const_str_plain__lex_error_func;
extern PyObject *const_str_plain_arr;
static PyObject *const_str_plain__is_type_in_scope;
static PyObject *const_str_digest_f5a05b9f3549c638d7908479c708f6c5;
static PyObject *const_str_plain_is_type;
static PyObject *const_tuple_b9ac4cd6be84011bb32a829063c1f63d_tuple;
static PyObject *const_str_digest_35fa98ecde313fbb87f970e5b6d1309e;
static PyObject *const_str_plain_p_declaration_specifiers_no_type_3;
extern PyObject *const_str_plain_DeclList;
static PyObject *const_str_digest_b42a0c796084440910713d8694dbdc5e;
static PyObject *const_str_plain_p_jump_statement_1;
static PyObject *const_tuple_751da5b1a920ae509d273d698c85b4d3_tuple;
static PyObject *const_str_digest_9bb26e7c3ad302320772fd07b96a4189;
static PyObject *const_str_plain_typedef_namespace;
extern PyObject *const_str_plain_If;
static PyObject *const_str_digest_1a34dbec4760d533fb71694a481d5e82;
static PyObject *const_str_digest_3a2b2d446e67b8b60dcfe60187bbb94a;
static PyObject *const_str_digest_67ab4d59a0c077231f5627abe5a96096;
static PyObject *const_str_digest_d5fcd1840d9fbc06c9c5a3527fc1847d;
static PyObject *const_str_digest_821acde88c2af9a2f13af52e0c27fed6;
static PyObject *const_str_digest_05d595f63bad393233213e890f949113;
extern PyObject *const_str_plain_lexer;
static PyObject *const_tuple_dd6b1b91cc0261088d31198011b3777b_tuple;
static PyObject *const_str_digest_571f26da7d7ba7969e33ae47d529100a;
static PyObject *const_str_plain_p_initializer_list;
extern PyObject *const_str_plain_Break;
static PyObject *const_tuple_str_plain_CLexer_tuple;
static PyObject *const_str_digest_b69fc3ce48390b0e9cfa18d81a30a6e0;
static PyObject *const_str_digest_f6e25df3d800bc64ee76c249251a121b;
static PyObject *const_str_digest_2e1cbe41f85e408c79a828dbf5edff43;
static PyObject *const_str_digest_0c8f1309a535f9f28741353a49e7264a;
static PyObject *const_str_plain_typeid;
static PyObject *const_str_plain_dummytype;
static PyObject *const_str_digest_483f66f5df35d692c60dbf8d94b9ce53;
extern PyObject *const_str_plain_text;
extern PyObject *const_str_plain_EmptyStatement;
static PyObject *const_tuple_92a4268d571593236672ed5e2ec111d7_tuple;
static PyObject *const_str_digest_aa59018a8d0d3fcfa3ad474999db574d;
static PyObject *const_str_digest_647a6e3276e06f7939544595fc801eba;
static PyObject *const_str_digest_3e10b62863993a2cc69fa833b1c10828;
extern PyObject *const_str_plain_reset_lineno;
extern PyObject *const_str_plain_UnaryOp;
static PyObject *const_str_digest_7cdb66da260f8b202170173dc4a6470f;
static PyObject *const_str_plain_p_designator_list;
static PyObject *const_str_digest_0e25af74743e7bbe803c3850cf908d5e;
static PyObject *const_str_digest_3502e26f1e7e9795bcde23e020a1c6c2;
static PyObject *const_str_plain_decl_tail;
static PyObject *const_str_digest_fb1821a12d9337038c5f0ba339bff7bc;
static PyObject *const_str_plain_p_primary_expression_1;
static PyObject *const_str_digest_fdd5d372186562e91a02b35106e75db3;
static PyObject *const_str_digest_03c3aa4a35ee337fabd3abd65350cf72;
static PyObject *const_str_digest_d86600b943a4c7555073e3e4856d1089;
static PyObject *const_str_digest_7aa878e9a432a70b1be9c111bdefc021;
static PyObject *const_tuple_str_plain_bitsize_tuple;
extern PyObject *const_str_plain_c_ast;
static PyObject *const_str_plain_p_unary_expression_3;
static PyObject *const_str_plain_p_abstract_declarator_2;
static PyObject *const_str_digest_07bf1055960239c6afdf14732b3e2626;
extern PyObject *const_str_plain_DoWhile;
static PyObject *const_str_plain_translation_unit_or_empty;
static PyObject *const_str_digest_be14d60093071f59d0507692040d9a94;
static PyObject *const_str_plain_p_postfix_expression_2;
static PyObject *const_str_digest_f25f218a0c1f5cad198347bc47b76ed9;
static PyObject *const_str_digest_467f5498c75043f32be58f16f19f8328;
static PyObject *const_str_digest_8d8f57fbf9ace4a819eb9da34e88ef83;
static PyObject *const_str_digest_5494df6239ebd6d1e5bb525f10a0f6cd;
extern PyObject *const_str_plain_kind;
static PyObject *const_str_digest_d16adbea55fe0967a56b6e6ba6b8aa8a;
static PyObject *const_str_digest_55677b557b6476d90f099cb7f3f3bf9c;
extern PyObject *const_slice_none_int_neg_1_none;
static PyObject *const_tuple_str_plain_self_str_plain_p_str_plain_quals_str_plain_arr_tuple;
static PyObject *const_str_digest_432c60fb536d6a5750f1ead762b4062e;
static PyObject *const_str_digest_7d9088072ecc638c9f57de60088a1028;
static PyObject *const_str_plain_p_declaration_specifiers_1;
static PyObject *const_str_digest_d19791b80d76ff0c0c5ce1c5dc8220b7;
static PyObject *const_str_digest_673754ad82ad40b5e8cfbef5f26fa28b;
static PyObject *const_tuple_f1ccb3db058b3624653c84c90fc9f384_tuple;
extern PyObject *const_slice_int_pos_2_none_none;
static PyObject *const_str_plain_newspec;
extern PyObject *const_str_plain___init__;
static PyObject *const_str_digest_4d5064fee01745e0edfcfd695c906323;
static PyObject *const_str_plain_p_labeled_statement_2;
extern PyObject *const_str_plain_parse;
extern PyObject *const_str_plain_Pragma;
static PyObject *const_str_plain_p_direct_abstract_declarator_1;
static PyObject *const_str_plain_p_type_qualifier_list;
static PyObject *const_str_digest_0cf7bbaa709fa7445d261c18853462db;
extern PyObject *const_str_plain_error_func;
static PyObject *const_str_digest_23aa0dacc3c1436a615874779d7ba221;
static PyObject *const_str_digest_7f1585ee0758766cedaf1624cb16edb0;
static PyObject *const_str_digest_e6054102b697f4379243ef2e481d9de1;
extern PyObject *const_str_empty;
static PyObject *const_str_digest_12f9e6fe12f7541fa2b46186a390fa7e;
static PyObject *const_tuple_str_plain_self_str_plain_name_str_plain_is_type_tuple;
static PyObject *const_str_digest_eae5a57ac505c9fd51dcee063c70c12f;
static PyObject *const_str_plain_p_brace_close;
static PyObject *const_str_digest_c07bd5cfbc553d3631d0a1668f710914;
extern PyObject *const_str_plain_Node;
static PyObject *const_str_plain_p_enum_specifier_1;
static PyObject *const_str_digest_576430d2ecd57cd9248634515b4042e1;
static PyObject *const_str_plain_p_struct_or_union;
static PyObject *const_str_plain_p_postfix_expression_4;
static PyObject *const_str_digest_df25ccf54e7b8d881231a8646232b4c5;
extern PyObject *const_str_plain_Switch;
extern PyObject *const_str_plain_Continue;
static PyObject *const_str_digest_abe9cf4d34820d00ecbbe01507e8a236;
static PyObject *const_str_plain_p_direct_xxx_declarator_4;
static PyObject *const_str_plain_p_specifier_qualifier_list_4;
static PyObject *const_dict_9d1be102e274ebd5d21e13e40f132db0;
static PyObject *const_str_plain_p_storage_class_specifier;
static PyObject *const_str_digest_52b362b68c1a3994b3c354ae840e20f1;
static PyObject *const_str_digest_e60fde1ce3556920242aca8b3c191efe;
extern PyObject *const_str_plain_ParseError;
static PyObject *const_str_plain__push_scope;
static PyObject *const_str_digest_294b43969495463422d51c2e0af683fa;
static PyObject *const_list_dict_empty_list;
extern PyObject *const_int_neg_1;
static PyObject *const_str_digest_f4c586e057933351dce958e95b28310c;
extern PyObject *const_str_plain_Goto;
extern PyObject *const_str_plain_id;
static PyObject *const_str_digest_aee4be64fec3aac8f4cc13847cf5d34c;
static PyObject *const_str_digest_436d5669d5bef2966850e86231313d36;
extern PyObject *const_str_plain_input;
static PyObject *const_str_plain__lex_on_rbrace_func;
static PyObject *const_str_digest_86e7bc379ddaa437cb4d0740b0f09628;
extern PyObject *const_str_plain_fix_switch_cases;
extern PyObject *const_str_plain_Label;
extern PyObject *const_str_plain_tabmodule;
static PyObject *const_str_plain_p_direct_abstract_declarator_6;
extern PyObject *const_tuple_str_plain_c_ast_tuple;
static PyObject *const_str_digest_f902c40d06583479323f2a0e09f149d0;
static PyObject *const_str_digest_52db91b7c1f71ae57834d48da56bbc3e;
static PyObject *const_str_digest_05db319dd614b03c1a9c5cbdcfc77915;
extern PyObject *const_str_plain_typedef;
static PyObject *const_str_digest_4d9f5a102c6e338e4518642310a06235;
static PyObject *const_str_digest_c9f59b1fa5017cb9005bb768b7c0c697;
extern PyObject *const_str_plain_Enumerator;
static PyObject *const_str_digest_124cdd6e5c1c3bca0c3f9db3c722414e;
static PyObject *const_str_plain_p_translation_unit_or_empty;
extern PyObject *const_str_plain_body;
static PyObject *const_str_digest_f652614c068fd18ab6b54821e3f5e567;
static PyObject *const_str_digest_5818384d85f9531b5d1a4dc60515c5ef;
static PyObject *const_str_plain_p_designation;
extern PyObject *const_str_plain_declname;
static PyObject *const_str_plain_p_declaration_specifiers_4;
extern PyObject *const_str_plain_Coord;
extern PyObject *const_str_plain_Typedef;
extern PyObject *const_str_plain_re;
extern PyObject *const_str_plain___doc__;
extern PyObject *const_str_plain_extend;
static PyObject *const_str_digest_97d8cb402d283686d305a0534205cf16;
static PyObject *const_str_digest_55a08934bb62f870d418c2065396356a;
static PyObject *const_tuple_f42d7b470c00f28d1af65a7593268b5b_tuple;
static PyObject *const_str_digest_41f6ebfa89aad8d3dfc1d7132e5ff63a;
static PyObject *const_str_digest_568b35cedd50be265c02bbdb7a7eb88d;
static PyObject *const_str_plain_p_postfix_expression_6;
static PyObject *const_str_plain_p_initializer_2;
extern PyObject *const_str_plain___package__;
static PyObject *const_str_digest_04b031e3a95a05949b8673c1377c8678;
static PyObject *const_str_digest_e50bcc58dedc95a40e88a177d13094dc;
static PyObject *const_str_plain_p_abstract_declarator_3;
extern PyObject *const_tuple_str_plain_self_str_plain_name_str_plain_coord_tuple;
extern PyObject *const_str_plain__coord;
static PyObject *const_str_plain_lex_optimize;
static PyObject *const_str_digest_ca8a32ff5c72a1ecfed53d1c8b17063d;
static PyObject *const_str_plain_p_function_specifier;
static PyObject *const_str_digest_90a2bfabec7dd4c758b77580ec12f8b8;
static PyObject *const_str_digest_6e6c77e24cfc9a052b7d222f6e6f60cf;
extern PyObject *const_str_plain_node;
extern PyObject *const_str_digest_b9c4baf879ebd882d40843df3a4dead7;
extern PyObject *const_str_plain_bitsize;
extern PyObject *const_str_plain_item;
static PyObject *const_str_digest_d0dce591a53a04884750228ee0143163;
static PyObject *const_str_digest_a3ba25157bfdb97c14e3f422913e6e9a;
static PyObject *const_str_digest_74fea7cff33b7bf42ce4fcb20f366d7e;
static PyObject *const_str_digest_bf7acc4751dc5b6ecae6da620bd3895d;
static PyObject *const_str_digest_0ba0c181eb95710a8b10bf6f48d47eb7;
static PyObject *const_str_plain_p_decl_body;
static PyObject *const_str_digest_0ebf677191c7d5c09c299499be874cec;
static PyObject *const_str_digest_c88ddef41084d2b01880f788a8e1915e;
extern PyObject *const_str_plain_float;
extern PyObject *const_tuple_str_plain_self_tuple;
extern PyObject *const_str_plain_typename;
extern PyObject *const_str_plain_ast_transforms;
static PyObject *const_str_digest_9ca4962d95812b4146545cad53121567;
static PyObject *const_str_plain_p_enum_specifier_3;
static PyObject *const_str_plain_p_direct_abstract_declarator_2;
static PyObject *const_str_digest_791b8912d692e91ab59be831ef8bc1a7;
static PyObject *const_str_digest_0037b7bb71b496183bd8ef3fbe80fbf7;
static PyObject *const_str_plain_listed_quals;
static PyObject *const_str_digest_b4df5602eb44336fd139f1d9d4f707a8;
extern PyObject *const_tuple_empty;
static PyObject *const_str_plain_p_unary_expression_1;
static PyObject *const_str_plain_p_enumerator_list;
static PyObject *const_str_digest_ed337dbead15c0fdcf05f046938efb38;
static PyObject *const_str_plain_yacc_optimize;
static PyObject *const_str_plain_designation;
extern PyObject *const_str_plain_append;
static PyObject *const_str_digest_547b0820a3a668896a8f847d79c3b158;
extern PyObject *const_tuple_str_plain_self_str_plain_p_tuple;
static PyObject *const_str_digest_8ad640be40d1e51038889c0ad468a995;
static PyObject *const_str_digest_59e6ee836c87207f91389c76e8f37211;
static PyObject *const_str_plain_p_unified_wstring_literal;
static PyObject *const_tuple_a4b7bb804c3c87f7b7aff1f402fad3af_tuple;
static PyObject *const_str_plain_p_enum_specifier_2;
static PyObject *const_str_digest_9b2521a2a4f11b3568e8ad30e3a505ca;
static PyObject *const_str_digest_6c52cb702432c3d80308420329a005f0;
extern PyObject *const_tuple_str_plain_init_tuple;
static PyObject *const_str_digest_e658ac8c4b7c2299a86f760a10b99615;
static PyObject *const_str_digest_5e2d8ee1259d7fabe59ee8fbc3b91004;
static PyObject *const_str_digest_aefe7a31071e8b90b70d14309835c4e8;
static PyObject *const_str_digest_eb88e54a205432a72790f32cf3ad216c;
extern PyObject *const_str_plain_Default;
extern PyObject *const_str_plain_token;
static PyObject *const_tuple_75d110c860c3329371e02201c24c7204_tuple;
static PyObject *const_str_plain_declaration;
static PyObject *const_str_plain_taboutputdir;
static PyObject *const_str_digest_ee647972fdff9211886cabce258b38a4;
static PyObject *const_tuple_f2e4debd813b1d9581312e122bd2eee4_tuple;
static PyObject *const_str_digest_33b3b26831c9fdeed6fb503fb3235253;
extern PyObject *const_str_plain_qual;
static PyObject *const_str_digest_51cb11be562c4e62872e5a99fb92c982;
extern PyObject *const_str_plain_param_decls;
static PyObject *const_str_plain_parameter_type_list;
static PyObject *const_str_digest_711802f92e6a2899ad0c3a102d2f0802;
static PyObject *const_str_digest_d22a9d10bffbeaa38403c3c0bb0d1558;
extern PyObject *const_str_plain__token_coord;
static PyObject *const_tuple_05106f1143fd548d61395e9607a1282d_tuple;
static PyObject *const_str_plain_p_iteration_statement_4;
static PyObject *const_str_digest_4747c94525afd53dfec17ba56a3a01da;
extern PyObject *const_str_plain_msg;
static PyObject *const_str_plain_yacctab;
static PyObject *const_str_plain_p_labeled_statement_1;
static PyObject *const_tuple_str_plain_self_str_plain_p_str_plain_dummytype_tuple;
static PyObject *const_str_plain_p_primary_expression_3;
static PyObject *const_str_plain_p_expression_statement;
static PyObject *const_str_plain_p_direct_xxx_declarator_1;
static PyObject *const_str_digest_57444e9b5b325fc1be7aff5d9f3b4c3e;
static PyObject *const_str_digest_550126ff38d208154c0902478dbba1ce;
static PyObject *const_str_plain_id_init_declarator_list;
static PyObject *const_str_plain_p_unary_operator;
static PyObject *const_str_digest_2dcd182a11e70168432f85bd4916de3f;
static PyObject *const_str_digest_b8f2e1eb7155c9c1f218f399b31285ac;
static PyObject *const_str_plain_p_unary_expression_2;
static PyObject *const_str_digest_01f6ae58b95068740a6086923c913284;
static PyObject *const_str_plain_declarations;
extern PyObject *const_list_none_list;
static PyObject *const_str_digest_98a5d60d6dc1672f0b5dd8b8c452133c;
static PyObject *const_str_plain_p_postfix_expression_3;
static PyObject *const_str_digest_d629f9f772cbeff45a83968be4ddd03c;
static PyObject *const_str_digest_cf56e81ade3b51653cf6277798267531;
extern PyObject *const_str_plain_Union;
static PyObject *const_str_plain_p_constant_3;
extern PyObject *const_str_plain_decl;
extern PyObject *const_str_plain___module__;
extern PyObject *const_str_plain_BinaryOp;
static PyObject *const_str_plain_expression;
static PyObject *const_str_digest_77451082531ef90d5a12539bac91b84d;
static PyObject *const_str_digest_de90f98da1f88f6c37ec30f2101d5029;
static PyObject *const_str_digest_8c97fa18e75807bc919d97720956d8b5;
extern PyObject *const_str_plain_debug;
static PyObject *const_tuple_str_plain_self_str_plain_p_str_plain_coord_tuple;
static PyObject *const_str_digest_3bf5fc201f146f4078233e173b4cb76d;
extern PyObject *const_str_plain_parameterized;
extern PyObject *const_str_plain_pycparser;
extern PyObject *const_str_plain_For;
extern PyObject *const_str_plain_block_items;
extern PyObject *const_tuple_str_plain_self_str_plain_token_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_p_str_plain_field_tuple;
static PyObject *const_tuple_481aebbbcf4c8fc7e212b2f24b7348d3_tuple;
static PyObject *const_tuple_2353d864ddc8d50bf7ddd83b7128ace5_tuple;
static PyObject *const_str_plain_p_type_name;
static PyObject *const_str_digest_4bd430b578c2bcc6d80843b185fb40e9;
static PyObject *const_str_plain_fixed_decl;
extern PyObject *const_str_plain_type_lookup_func;
static PyObject *const_str_plain_p_direct_abstract_declarator_5;
static PyObject *const_str_digest_3cd56dd644178e94ac8c95975280e123;
extern PyObject *const_str_plain_FileAST;
static PyObject *const_str_plain_p_initializer_1;
extern PyObject *const_str_plain_function;
extern PyObject *const_str_plain_ExprList;
static PyObject *const_str_digest_04111da496bbf8fa420ef5af2e2ec8c2;
extern PyObject *const_str_plain_on_lbrace_func;
static PyObject *const_str_plain_p_direct_xxx_declarator_3;
static PyObject *const_str_digest_5a2740760b061d16507e2fe95c154990;
extern PyObject *const_list_empty;
extern PyObject *const_str_plain_get;
static PyObject *const_str_digest_5ffee6bd7e73a82aa69f100a7aa6d022;
static PyObject *const_str_digest_9cdeb6682169eabb916c7a726bd5a898;
static PyObject *const_str_digest_0873233ec7645beb5174dc9e5b721ed2;
static PyObject *const_str_plain__pop_scope;
extern PyObject *const_str_plain_CompoundLiteral;
extern PyObject *const_str_plain_klass;
static PyObject *const_str_digest_8d22bfcb2b0b548ef9d27d2e0cd24f7d;
static PyObject *const_str_digest_51f8cd619ea97f30dc6589cdec4889ff;
extern PyObject *const_str_plain_NamedInitializer;
extern PyObject *const_str_plain_metaclass;
static PyObject *const_str_plain_p_translation_unit_2;
static PyObject *const_str_digest_1af3c0955bc51582727db494d6e3b036;
static PyObject *const_str_plain_decl_type;
static PyObject *const_str_plain_p_selection_statement_2;
static PyObject *const_str_digest_16dd3aa8de123b64723e9d3f1db8a05b;
static PyObject *const_tuple_a4361eef94546b476a1f9f18cdc0dc2d_tuple;
static PyObject *const_str_digest_5d8b7746d279b77778a2347a35fac441;
static PyObject *const_str_plain_p_external_declaration_1;
extern PyObject *const_tuple_false_tuple;
static PyObject *const_str_plain_p_iteration_statement_3;
static PyObject *const_str_digest_a61395ec1f8cbf83baab4a2c6ec5e642;
static PyObject *const_tuple_335994457eed7eca0e0ad48eb3a022bd_tuple;
static PyObject *const_str_digest_85edeba66ecd8010a3ffbe3e744f2716;
static PyObject *const_str_digest_3f8b6aa31a0455c8989a7d5ca708b30b;
static PyObject *const_str_plain_p_primary_expression_4;
static PyObject *const_str_plain__type_modify_decl;
extern PyObject *const_str_plain_args;
static PyObject *const_str_plain_p_unified_string_literal;
extern PyObject *const_str_plain_funcspec;
static PyObject *const_str_plain_p_specifier_qualifier_list_3;
extern PyObject *const_str_plain_c_lexer;
static PyObject *const_str_digest_192b105d8a394fb0ecdd5413c89d71d5;
static PyObject *const_str_plain_p_binary_expression;
static PyObject *const_str_plain_p_struct_declarator_list;
static PyObject *const_tuple_str_plain_self_str_plain_msg_str_plain_line_str_plain_column_tuple;
extern PyObject *const_str_plain_param;
static PyObject *const_tuple_str_plain_fix_switch_cases_tuple;
static PyObject *const_str_plain_p_function_definition_2;
static PyObject *const_str_digest_034d2d261123545addc18f62de03953f;
static PyObject *const_str_digest_643d36ef80210022e8e8988135837871;
extern PyObject *const_int_pos_6;
static PyObject *const_str_plain_scope;
extern PyObject *const_str_plain_ID;
static PyObject *const_str_plain_p_init_declarator;
static PyObject *const_str_plain_struct_declarator_list;
static PyObject *const_str_plain_p_struct_or_union_specifier_2;
static PyObject *const_str_digest_2060f4e391866f3f24cf672a745dbddb;
static PyObject *const_str_plain_p_typedef_name;
extern PyObject *const_str_plain_FuncDecl;
extern PyObject *const_list_str_plain_int_list;
static PyObject *const_str_plain_p_external_declaration_2;
static PyObject *const_str_plain_p_constant_1;
static PyObject *const_str_plain__build_function_definition;
static PyObject *const_str_digest_e01c24288bb4a048bc585c985f9198c6;
static PyObject *const_str_plain_p_postfix_expression_5;
extern PyObject *const_str_chr_63;
static PyObject *const_str_digest_d3241665db4061517845a1ec21ea60f2;
static PyObject *const_str_digest_9d630abb686b7666019838011d097aa8;
static PyObject *const_str_digest_307040cd1aee1d586a3e132983f8218a;
static PyObject *const_str_plain_init_declarator_list;
static PyObject *const_str_plain_type_qualifier_list;
static PyObject *const_str_digest_e86f7034b1998ca0fd1f83fbc241f439;
static PyObject *const_str_plain_p_labeled_statement_3;
static PyObject *const_str_digest_ef5470f8407896db734faec9dc576857;
static PyObject *const_str_digest_2aaa91cf4331f7a6a55f392233d13676;
static PyObject *const_str_digest_125855f9025066f00bab7e56db3721bd;
static PyObject *const_str_plain__add_typedef_name;
static PyObject *const_str_digest_2b800f7f12830ca3c74b3d002525a8e9;
extern PyObject *const_str_plain_c_parser;
static PyObject *const_tuple_str_plain_yacc_tuple;
static PyObject *const_str_plain_p_type_specifier_no_typeid;
extern PyObject *const_str_plain_t;
static PyObject *const_str_plain_p_enumerator;
static PyObject *const_str_plain_assignment_expression;
extern PyObject *const_str_plain_EnumeratorList;
extern PyObject *const_str_plain_int;
static PyObject *const_str_digest_d73a0191fa324324a6b46a5358fae01c;
extern PyObject *const_str_plain_lextab;
static PyObject *const_str_digest_e804d385509db9b1e7283e5542b56ffc;
static PyObject *const_str_digest_58be8217c52b2b0082fd54c328e34edd;
static PyObject *const_str_plain_p_block_item_list;
static PyObject *const_str_digest_8843e107d9ff99510b99f46b7f76e849;
static PyObject *const_str_plain_tail_type;
extern PyObject *const_str_plain_init;
static PyObject *const_str_plain_p_struct_declarator_2;
extern PyObject *const_str_plain_line;
static PyObject *const_str_digest_2f6102c4e0aa673d1243e931a1fc5195;
static PyObject *const_str_digest_87931e228ae4f4b725f2af333756cf40;
static PyObject *const_str_digest_f5534e5846f0091e2dec27d444fffb08;
static PyObject *const_str_plain_p_direct_abstract_declarator_7;
extern PyObject *const_str_plain_CParser;
static PyObject *const_str_digest_db4fbd32244e3e142dfff8ca5ad2d835;
extern PyObject *const_str_plain_tokens;
static PyObject *const_str_digest_1beda91f8819e027ad8a23c29f618425;
static PyObject *const_str_plain_p_assignment_operator;
static PyObject *const_str_digest_927a3c4fff6d9ce2ff3e8b0311b2a749;
static PyObject *const_str_digest_6fd75982f2b711afbab1aec5063c9027;
extern PyObject *const_str_plain_p_error;
extern PyObject *const_str_plain_precedence;
static PyObject *const_str_digest_178c771a71db12f844d7380f17f7ef4e;
static PyObject *const_str_plain__add_declaration_specifier;
static PyObject *const_str_digest_f6874ff50ae284a33e88afa362ab3553;
static PyObject *const_str_digest_6f813f05266ed46ec5181eab859080ad;
static PyObject *const_str_digest_732bc606378f1eac79e58256e6deeaca;
static PyObject *const_str_digest_a1cd6aed9971dbcb84ca89043785348d;
static PyObject *const_str_digest_edd8de4708a55f1ec9dbcdda4529a4c2;
static PyObject *const_str_plain_p_iteration_statement_2;
static PyObject *const_str_digest_d1cc4f42cc56377b00d07035e4578575;
static PyObject *const_str_digest_1c433317a7150a35692bd30cb2425716;
static PyObject *const_str_digest_820fa7852213334e67e36dc54e523377;
static PyObject *const_str_plain_p_cast_expression_1;
extern PyObject *const_str_plain_Struct;
static PyObject *const_str_digest_5f379363cdeef01b09cf7f64504042da;
static PyObject *const_list_dict_2c030ba937b9e185526e262591ee7db7_list;
static PyObject *const_str_plain_p_declaration_specifiers_2;
static PyObject *const_str_digest_c187e02bef7c074dcfaa98ea325683fc;
extern PyObject *const_str_plain_char;
static PyObject *const_str_digest_0594790bab68d7c87f42d25d5c5e4a6b;
extern PyObject *const_str_plain_PLYParser;
static PyObject *const_str_digest_abf6f1796659b1065c7123daae53e198;
static PyObject *const_str_plain_ty;
static PyObject *const_str_digest_ea1e7517ff14f16261f797c375173978;
static PyObject *const_str_digest_d981b77bcfe72f3dc742174b23807c08;
static PyObject *const_str_digest_6795256e62ee72e47844fa0e0f009b9a;
static PyObject *const_str_digest_d66e9c5c2bcd94289ac5f093c4055dbc;
extern PyObject *const_str_plain_PtrDecl;
static PyObject *const_str_digest_d88c34830a8f899e0db8bc3194789629;
extern PyObject *const_str_plain_clex;
extern PyObject *const_str_plain__parse_error;
static PyObject *const_str_plain_modifier_tail;
static PyObject *const_str_plain_p_struct_declarator_1;
static PyObject *const_str_digest_6e4b44069d4b8ebacde4e38969a5851a;
static PyObject *const_str_plain__select_struct_union_class;
static PyObject *const_str_plain_p_xxx_declarator_1;
static PyObject *const_str_digest_df007a6e044b925abf12d22b7ef3ea75;
static PyObject *const_str_digest_3527e2c43140c9c3fd5fb7fcbbe9a457;
extern PyObject *const_str_plain_column;
static PyObject *const_str_digest_a8184ddf33f783ca2f5ff9b3b636381f;
static PyObject *const_str_plain_p_argument_expression_list;
static PyObject *const_str_digest_ea48cf7104d76d4530fca21257b2ac6b;
extern PyObject *const_str_plain_Enum;
static PyObject *const_str_digest_e7a64a89e5927564e3642a46ab58f1c4;
static PyObject *const_str_digest_6a4952e047321440db18a38bf73040e5;
static PyObject *const_str_digest_df4123329a07844b816ca766a10e3b4d;
static PyObject *const_str_digest_ec3069c11ff9407ed42cf10e18b85079;
static PyObject *const_str_plain_p_init_declarator_list;
static PyObject *const_str_plain_p_xxx_declarator_2;
static PyObject *const_str_digest_e61ddf064a1db398749ac1d36281c3cb;
static PyObject *const_str_digest_54641dd2781e3ae796914e2648dd7e3c;
static PyObject *const_str_plain_p_statement;
extern PyObject *const_str_plain_filename;
static PyObject *const_tuple_22e763767c9a66d68e45377ac7499ee8_tuple;
extern PyObject *const_str_plain_params;
extern PyObject *const_str_plain_ArrayRef;
static PyObject *const_tuple_0f1b9a27033e2962bbcd8849947d6d02_tuple;
static PyObject *const_str_plain_yacc_debug;
static PyObject *const_str_plain_p_abstract_declarator_1;
static PyObject *const_str_digest_67f6f0661dcf43443ba5aba2601841f6;
static PyObject *const_str_digest_7fb11837565d2e38ffa2544b3c72440e;
static PyObject *const_str_digest_67c7a592d5ccaa55aa64fc82209437a9;
static PyObject *const_str_plain_p_block_item;
extern PyObject *const_str_plain_Constant;
static PyObject *const_str_plain_sublist;
static PyObject *const_str_digest_1ba6cb72fde357e6df707af7c40bc09e;
static PyObject *const_str_digest_534b5bcecbd2c4f39a6a03b6e5d0a4d9;
extern PyObject *const_str_plain_plyparser;
extern PyObject *const_int_pos_3;
static PyObject *const_str_digest_90baefe9843fd00d2fcc6c4fd66a583a;
extern PyObject *const_str_plain_self;
extern PyObject *const_str_plain_rstrip;
static PyObject *const_str_digest_e83b94dd40a22f9b101921f16536afd9;
static PyObject *const_tuple_str_plain_self_str_plain_p_str_plain_spec_tuple;
extern PyObject *const_str_plain_coord;
extern PyObject *const_str_plain_enumerator;
static PyObject *const_str_plain__lex_on_lbrace_func;
static PyObject *const_str_digest_4adaae36d1bcfc08aaddc6ab3ca280a1;
extern PyObject *const_int_pos_7;
static PyObject *const_str_plain_p_jump_statement_3;
static PyObject *const_str_digest_872052bc891e4d940163d196751ac419;
static PyObject *const_tuple_str_plain_self_str_plain_p_str_plain_enumerator_tuple;
static PyObject *const_str_digest_59cff374166603b529f71057ce36eaed;
static PyObject *const_str_plain_p_parameter_declaration_1;
static PyObject *const_str_plain_p_cast_expression_2;
extern PyObject *const_int_pos_2;
static PyObject *const_str_plain_p_postfix_expression_1;
static PyObject *const_str_plain_p_direct_abstract_declarator_3;
static PyObject *const_str_digest_7ba0fc454e8e35159e5df23ec4292d59;
static PyObject *const_str_digest_ad6ead784d30f848fe6914fe2453eb23;
extern PyObject *const_str_plain_exprs;
static PyObject *const_str_plain_p_type_specifier;
static PyObject *const_str_digest_9ea1b38e0d2aa74c23f145dd3e278bab;
extern PyObject *const_str_plain_spec;
static PyObject *const_str_digest_18559e92d38108a30eaa5a5cecac76ce;
extern PyObject *const_str_plain_enumerators;
extern PyObject *const_str_plain_While;
static PyObject *const_str_plain_p_expression;
static PyObject *const_str_plain__scope_stack;
static PyObject *const_str_digest_84f8f95f98f69c9f598b1943ad4af5e9;
static PyObject *module_filename_obj;

static bool constants_created = false;

static void createModuleConstants( void )
{
    const_str_digest_94f4c600d0330853c740c988770a5205 = UNSTREAM_STRING( &constant_bin[ 1622844 ], 122, 0 );
    const_str_digest_e8f9383a162dfbf1f03d39b53d3b5fc9 = UNSTREAM_STRING( &constant_bin[ 1622966 ], 30, 0 );
    const_str_plain_p_jump_statement_4 = UNSTREAM_STRING( &constant_bin[ 1622996 ], 18, 1 );
    const_str_plain_initializer_list = UNSTREAM_STRING( &constant_bin[ 1623014 ], 16, 1 );
    const_str_digest_aeedbaa90a2ea63d79afdc2349fb7597 = UNSTREAM_STRING( &constant_bin[ 1623030 ], 112, 0 );
    const_str_digest_dae376c9624166cef9d09e7b5e652d77 = UNSTREAM_STRING( &constant_bin[ 1623142 ], 29, 0 );
    const_str_plain__build_declarations = UNSTREAM_STRING( &constant_bin[ 1623171 ], 19, 1 );
    const_tuple_str_plain_typeid_noparen_str_plain_TYPEID_tuple = PyTuple_New( 2 );
    const_str_plain_typeid_noparen = UNSTREAM_STRING( &constant_bin[ 1623190 ], 14, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_typeid_noparen_str_plain_TYPEID_tuple, 0, const_str_plain_typeid_noparen ); Py_INCREF( const_str_plain_typeid_noparen );
    PyTuple_SET_ITEM( const_tuple_str_plain_typeid_noparen_str_plain_TYPEID_tuple, 1, const_str_plain_TYPEID ); Py_INCREF( const_str_plain_TYPEID );
    const_str_plain_p_direct_abstract_declarator_4 = UNSTREAM_STRING( &constant_bin[ 1623204 ], 30, 1 );
    const_str_digest_4f9513954810f933174045a85cc3a2ab = UNSTREAM_STRING( &constant_bin[ 1623234 ], 27, 0 );
    const_str_digest_b662c5a69a6a4f6634e2c2fb3d230a44 = UNSTREAM_STRING( &constant_bin[ 1623261 ], 153, 0 );
    const_str_digest_79346a7e0deb4b73cbe7b4194fb4e2e9 = UNSTREAM_STRING( &constant_bin[ 1623414 ], 32, 0 );
    const_str_digest_e28583a0c8281162e1d6bb9bcf52a53f = UNSTREAM_STRING( &constant_bin[ 1623446 ], 102, 0 );
    const_str_plain_declaration_specifiers_no_type = UNSTREAM_STRING( &constant_bin[ 1623447 ], 30, 1 );
    const_str_digest_245e706123acd66a0d916383148f8b39 = UNSTREAM_STRING( &constant_bin[ 1623548 ], 647, 0 );
    const_str_digest_17335b6423c53852abc4fa386f487ebf = UNSTREAM_STRING( &constant_bin[ 1624195 ], 47, 0 );
    const_str_digest_e01ad3fcfb8f2ceeb611d950f8bc575c = UNSTREAM_STRING( &constant_bin[ 1624242 ], 34, 0 );
    const_str_digest_68c0be9602cedbb187213fbf197fea5b = UNSTREAM_STRING( &constant_bin[ 1624276 ], 15, 0 );
    const_str_digest_030e172aedb3e27ebaa801170da02568 = UNSTREAM_STRING( &constant_bin[ 1624291 ], 42, 0 );
    const_str_digest_d64b22c7e8bcf5726624a0a905a39454 = UNSTREAM_STRING( &constant_bin[ 1624333 ], 20, 0 );
    const_str_digest_72424e08fc91bf13cdbee5746dacdd3f = UNSTREAM_STRING( &constant_bin[ 1624353 ], 39, 0 );
    const_str_digest_6540d053a4745d3499d98b3c1b137fdc = UNSTREAM_STRING( &constant_bin[ 1624392 ], 38, 0 );
    const_str_digest_e24f977f6803d5f0c297c89e5fb42201 = UNSTREAM_STRING( &constant_bin[ 1624430 ], 52, 0 );
    const_str_digest_d3b46ce600868fd3d7716c8dd7a08173 = UNSTREAM_STRING( &constant_bin[ 1624482 ], 72, 0 );
    const_str_plain_p_declaration_specifiers_no_type_2 = UNSTREAM_STRING( &constant_bin[ 1624554 ], 34, 1 );
    const_str_digest_f67d5f062350872f4b7a3431eb8ff9ef = UNSTREAM_STRING( &constant_bin[ 1624588 ], 45, 0 );
    const_str_digest_d26c56e6f12d65901f9ea8a848bbf06f = UNSTREAM_STRING( &constant_bin[ 1624633 ], 23, 0 );
    const_str_plain_debuglevel = UNSTREAM_STRING( &constant_bin[ 1624656 ], 10, 1 );
    const_str_plain_p_parameter_type_list = UNSTREAM_STRING( &constant_bin[ 1624666 ], 21, 1 );
    const_str_digest_e664f998ac5740d2a3a6c87d0e4d9671 = UNSTREAM_STRING( &constant_bin[ 1624687 ], 61, 0 );
    const_str_plain_s_u_or_e = UNSTREAM_STRING( &constant_bin[ 1624748 ], 8, 1 );
    const_str_digest_317c273604af4de5e262e646925688c4 = UNSTREAM_STRING( &constant_bin[ 1624756 ], 46, 0 );
    const_str_digest_80150a5bbe00013c9a11609bcac2921e = UNSTREAM_STRING( &constant_bin[ 1624802 ], 26, 0 );
    const_tuple_str_plain_self_str_plain_p_str_plain_arr_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_p_str_plain_arr_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_p_str_plain_arr_tuple, 1, const_str_plain_p ); Py_INCREF( const_str_plain_p );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_p_str_plain_arr_tuple, 2, const_str_plain_arr ); Py_INCREF( const_str_plain_arr );
    const_tuple_0ea225ba60de122d0cbb5d84b83eeb1c_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_0ea225ba60de122d0cbb5d84b83eeb1c_tuple, 0, const_str_plain_PLYParser ); Py_INCREF( const_str_plain_PLYParser );
    PyTuple_SET_ITEM( const_tuple_0ea225ba60de122d0cbb5d84b83eeb1c_tuple, 1, const_str_plain_Coord ); Py_INCREF( const_str_plain_Coord );
    PyTuple_SET_ITEM( const_tuple_0ea225ba60de122d0cbb5d84b83eeb1c_tuple, 2, const_str_plain_ParseError ); Py_INCREF( const_str_plain_ParseError );
    PyTuple_SET_ITEM( const_tuple_0ea225ba60de122d0cbb5d84b83eeb1c_tuple, 3, const_str_plain_parameterized ); Py_INCREF( const_str_plain_parameterized );
    PyTuple_SET_ITEM( const_tuple_0ea225ba60de122d0cbb5d84b83eeb1c_tuple, 4, const_str_plain_template ); Py_INCREF( const_str_plain_template );
    const_str_digest_32f37d7b1e094bf932b7a1d06bfa5763 = UNSTREAM_STRING( &constant_bin[ 1624828 ], 255, 0 );
    const_str_digest_5dd9b87f6fa196442177a7da624a6140 = UNSTREAM_STRING( &constant_bin[ 1625083 ], 109, 0 );
    const_dict_2c030ba937b9e185526e262591ee7db7 = _PyDict_NewPresized( 2 );
    PyDict_SetItem( const_dict_2c030ba937b9e185526e262591ee7db7, const_str_plain_decl, Py_None );
    PyDict_SetItem( const_dict_2c030ba937b9e185526e262591ee7db7, const_str_plain_init, Py_None );
    assert( PyDict_Size( const_dict_2c030ba937b9e185526e262591ee7db7 ) == 2 );
    const_str_digest_f8343e16e92e519e6585339ebb169a13 = UNSTREAM_STRING( &constant_bin[ 1625192 ], 16, 0 );
    const_str_plain_in_scope = UNSTREAM_STRING( &constant_bin[ 1625208 ], 8, 1 );
    const_str_digest_df1d3e1503202a90612746b6071f8fc8 = UNSTREAM_STRING( &constant_bin[ 1625216 ], 33, 0 );
    const_str_digest_1f8992215f1ce67405c35060612647fa = UNSTREAM_STRING( &constant_bin[ 1625249 ], 23, 0 );
    const_str_digest_f8f063e2d73853aff8adc792b438908e = UNSTREAM_STRING( &constant_bin[ 1625272 ], 156, 0 );
    const_str_plain_p_external_declaration_3 = UNSTREAM_STRING( &constant_bin[ 1625428 ], 24, 1 );
    const_str_plain_p_external_declaration_4 = UNSTREAM_STRING( &constant_bin[ 1625452 ], 24, 1 );
    const_str_digest_30531a534a7c297aabfd46265292dec4 = UNSTREAM_STRING( &constant_bin[ 1625476 ], 39, 0 );
    const_str_digest_1a96c17db4422135332fc034b84b4f5e = UNSTREAM_STRING( &constant_bin[ 1625515 ], 46, 0 );
    const_str_digest_705568b41dc44e9db67a41d3b2108e29 = UNSTREAM_STRING( &constant_bin[ 1625561 ], 17, 0 );
    const_str_plain_p_id_init_declarator = UNSTREAM_STRING( &constant_bin[ 1625578 ], 20, 1 );
    const_str_digest_325218adecc4f0228a24278fb5234c18 = UNSTREAM_STRING( &constant_bin[ 1625598 ], 10, 0 );
    const_str_digest_613ba6a44a1d56c696caece48ebdb21e = UNSTREAM_STRING( &constant_bin[ 1625608 ], 35, 0 );
    const_str_plain_decls_0_tail = UNSTREAM_STRING( &constant_bin[ 1625643 ], 12, 1 );
    const_str_digest_61cb30757fb84ded43723d45db63c47d = UNSTREAM_STRING( &constant_bin[ 1625655 ], 29, 0 );
    const_str_digest_2ee573711e350e5fa9f7994e07f7d359 = UNSTREAM_STRING( &constant_bin[ 1625684 ], 36, 0 );
    const_str_plain_p_assignment_expression = UNSTREAM_STRING( &constant_bin[ 1625720 ], 23, 1 );
    const_tuple_str_plain_self_str_plain_p_str_plain_typename_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_p_str_plain_typename_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_p_str_plain_typename_tuple, 1, const_str_plain_p ); Py_INCREF( const_str_plain_p );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_p_str_plain_typename_tuple, 2, const_str_plain_typename ); Py_INCREF( const_str_plain_typename );
    const_str_digest_1d80facf566b625aa32b1f97e9f80fdc = UNSTREAM_STRING( &constant_bin[ 1625743 ], 82, 0 );
    const_str_plain_p_designator = UNSTREAM_STRING( &constant_bin[ 1625825 ], 12, 1 );
    const_str_plain_p_jump_statement_2 = UNSTREAM_STRING( &constant_bin[ 1624810 ], 18, 1 );
    const_str_digest_fb8cb72a47e4e6a97db78d6f2a14c1a9 = UNSTREAM_STRING( &constant_bin[ 1625837 ], 105, 0 );
    const_str_digest_b2165be07d44c0536d62b0ea0314fef6 = UNSTREAM_STRING( &constant_bin[ 1625942 ], 44, 0 );
    const_str_plain_identifier_list = UNSTREAM_STRING( &constant_bin[ 1625986 ], 15, 1 );
    const_str_digest_3f66b33dcd02380a3b34f7c175ab47ca = UNSTREAM_STRING( &constant_bin[ 1626001 ], 125, 0 );
    const_str_digest_17cc52e14b6c1f7ad77cb5c85591f124 = UNSTREAM_STRING( &constant_bin[ 1626126 ], 110, 0 );
    const_str_digest_49258e4a03bd2250dfb8cbfdcea029e5 = UNSTREAM_STRING( &constant_bin[ 1626236 ], 30, 0 );
    const_str_plain_p_offsetof_member_designator = UNSTREAM_STRING( &constant_bin[ 1625692 ], 28, 1 );
    const_str_digest_eeeb606ddede2757ab34e6f6c30e8cfc = UNSTREAM_STRING( &constant_bin[ 1626266 ], 81, 0 );
    const_str_digest_dd774f65546147d7cec683569068da92 = UNSTREAM_STRING( &constant_bin[ 1626347 ], 59, 0 );
    const_str_digest_d5664c5531b4d8c20886d97ceb88d02f = UNSTREAM_STRING( &constant_bin[ 1626406 ], 25, 0 );
    const_str_digest_d13b4c87d8a8852eb743b212f8d676d6 = UNSTREAM_STRING( &constant_bin[ 1626431 ], 62, 0 );
    const_tuple_str_plain_id_str_plain_ID_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_id_str_plain_ID_tuple, 0, const_str_plain_id ); Py_INCREF( const_str_plain_id );
    PyTuple_SET_ITEM( const_tuple_str_plain_id_str_plain_ID_tuple, 1, const_str_plain_ID ); Py_INCREF( const_str_plain_ID );
    const_str_plain_declspec = UNSTREAM_STRING( &constant_bin[ 1626493 ], 8, 1 );
    const_str_digest_f31c05fd6230f58c972a6b1f6469cc4a = UNSTREAM_STRING( &constant_bin[ 1626501 ], 30, 0 );
    const_tuple_814fd99db7b828bfc5d54aae3ba8f30f_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 1626531 ], 3616 );
    const_str_plain_p_pppragma_directive = UNSTREAM_STRING( &constant_bin[ 1627128 ], 20, 1 );
    const_str_digest_f7773303a76f0396c72f44ccc6cdac61 = UNSTREAM_STRING( &constant_bin[ 1630147 ], 30, 0 );
    const_str_digest_891e4ef06043254cd6f550a053fcf199 = UNSTREAM_STRING( &constant_bin[ 1630177 ], 26, 0 );
    const_str_plain_p_pp_directive = UNSTREAM_STRING( &constant_bin[ 1627112 ], 14, 1 );
    const_tuple_str_plain_self_str_plain_p_str_plain_func_str_plain_param_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_p_str_plain_func_str_plain_param_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_p_str_plain_func_str_plain_param_tuple, 1, const_str_plain_p ); Py_INCREF( const_str_plain_p );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_p_str_plain_func_str_plain_param_tuple, 2, const_str_plain_func ); Py_INCREF( const_str_plain_func );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_p_str_plain_func_str_plain_param_tuple, 3, const_str_plain_param ); Py_INCREF( const_str_plain_param );
    const_str_digest_926cbb8fdd1f46d7626b4cc0e214cfd0 = UNSTREAM_STRING( &constant_bin[ 1630203 ], 207, 0 );
    const_str_digest_5ce94e49f4392eb90c8c6d62708b5382 = UNSTREAM_STRING( &constant_bin[ 1630410 ], 110, 0 );
    const_str_digest_aa4b6ff9cb7b7e2de6145f81e4b024a4 = UNSTREAM_STRING( &constant_bin[ 1630520 ], 36, 0 );
    const_str_digest_a095f2bdede86bb9b3571d87f15a4f3c = UNSTREAM_STRING( &constant_bin[ 1630556 ], 18, 0 );
    const_list_92f625f2146505b2a221686ca03ee1cd_list = PyList_New( 14 );
    const_str_plain_abstract_declarator = UNSTREAM_STRING( &constant_bin[ 1623213 ], 19, 1 );
    PyList_SET_ITEM( const_list_92f625f2146505b2a221686ca03ee1cd_list, 0, const_str_plain_abstract_declarator ); Py_INCREF( const_str_plain_abstract_declarator );
    const_str_plain_assignment_expression = UNSTREAM_STRING( &constant_bin[ 1625303 ], 21, 1 );
    PyList_SET_ITEM( const_list_92f625f2146505b2a221686ca03ee1cd_list, 1, const_str_plain_assignment_expression ); Py_INCREF( const_str_plain_assignment_expression );
    const_str_plain_declaration_list = UNSTREAM_STRING( &constant_bin[ 1625233 ], 16, 1 );
    PyList_SET_ITEM( const_list_92f625f2146505b2a221686ca03ee1cd_list, 2, const_str_plain_declaration_list ); Py_INCREF( const_str_plain_declaration_list );
    PyList_SET_ITEM( const_list_92f625f2146505b2a221686ca03ee1cd_list, 3, const_str_plain_declaration_specifiers_no_type ); Py_INCREF( const_str_plain_declaration_specifiers_no_type );
    const_str_plain_designation = UNSTREAM_STRING( &constant_bin[ 1625516 ], 11, 1 );
    PyList_SET_ITEM( const_list_92f625f2146505b2a221686ca03ee1cd_list, 4, const_str_plain_designation ); Py_INCREF( const_str_plain_designation );
    const_str_plain_expression = UNSTREAM_STRING( &constant_bin[ 29729 ], 10, 1 );
    PyList_SET_ITEM( const_list_92f625f2146505b2a221686ca03ee1cd_list, 5, const_str_plain_expression ); Py_INCREF( const_str_plain_expression );
    PyList_SET_ITEM( const_list_92f625f2146505b2a221686ca03ee1cd_list, 6, const_str_plain_identifier_list ); Py_INCREF( const_str_plain_identifier_list );
    const_str_plain_init_declarator_list = UNSTREAM_STRING( &constant_bin[ 1622976 ], 20, 1 );
    PyList_SET_ITEM( const_list_92f625f2146505b2a221686ca03ee1cd_list, 7, const_str_plain_init_declarator_list ); Py_INCREF( const_str_plain_init_declarator_list );
    const_str_plain_id_init_declarator_list = UNSTREAM_STRING( &constant_bin[ 1627695 ], 23, 1 );
    PyList_SET_ITEM( const_list_92f625f2146505b2a221686ca03ee1cd_list, 8, const_str_plain_id_init_declarator_list ); Py_INCREF( const_str_plain_id_init_declarator_list );
    PyList_SET_ITEM( const_list_92f625f2146505b2a221686ca03ee1cd_list, 9, const_str_plain_initializer_list ); Py_INCREF( const_str_plain_initializer_list );
    const_str_plain_parameter_type_list = UNSTREAM_STRING( &constant_bin[ 1624668 ], 19, 1 );
    PyList_SET_ITEM( const_list_92f625f2146505b2a221686ca03ee1cd_list, 10, const_str_plain_parameter_type_list ); Py_INCREF( const_str_plain_parameter_type_list );
    const_str_plain_block_item_list = UNSTREAM_STRING( &constant_bin[ 1626416 ], 15, 1 );
    PyList_SET_ITEM( const_list_92f625f2146505b2a221686ca03ee1cd_list, 11, const_str_plain_block_item_list ); Py_INCREF( const_str_plain_block_item_list );
    const_str_plain_type_qualifier_list = UNSTREAM_STRING( &constant_bin[ 1625100 ], 19, 1 );
    PyList_SET_ITEM( const_list_92f625f2146505b2a221686ca03ee1cd_list, 12, const_str_plain_type_qualifier_list ); Py_INCREF( const_str_plain_type_qualifier_list );
    const_str_plain_struct_declarator_list = UNSTREAM_STRING( &constant_bin[ 1628051 ], 22, 1 );
    PyList_SET_ITEM( const_list_92f625f2146505b2a221686ca03ee1cd_list, 13, const_str_plain_struct_declarator_list ); Py_INCREF( const_str_plain_struct_declarator_list );
    const_str_digest_dd3def542e52a4ea9e23e75851f4878e = UNSTREAM_STRING( &constant_bin[ 1630574 ], 103, 0 );
    const_str_digest_c244982f392d01a9847bfb619bd7437c = UNSTREAM_STRING( &constant_bin[ 1630677 ], 32, 0 );
    const_str_plain__last_yielded_token = UNSTREAM_STRING( &constant_bin[ 1630709 ], 19, 1 );
    const_str_digest_98df06d490521f0a00d6ac5b08c499e6 = UNSTREAM_STRING( &constant_bin[ 1630728 ], 33, 0 );
    const_str_plain_p_identifier_list = UNSTREAM_STRING( &constant_bin[ 1628559 ], 17, 1 );
    const_str_plain_p_struct_declaration_1 = UNSTREAM_STRING( &constant_bin[ 1628001 ], 22, 1 );
    const_str_plain_p_direct_xxx_declarator_6 = UNSTREAM_STRING( &constant_bin[ 1628403 ], 25, 1 );
    const_str_digest_c2c7438f6f3ab6e2ae34cf42aec88484 = UNSTREAM_STRING( &constant_bin[ 1630761 ], 32, 0 );
    const_str_plain__fix_decl_name_type = UNSTREAM_STRING( &constant_bin[ 1626797 ], 19, 1 );
    const_str_plain_p_constant_2 = UNSTREAM_STRING( &constant_bin[ 1630021 ], 12, 1 );
    const_str_plain_p_parameter_declaration_2 = UNSTREAM_STRING( &constant_bin[ 1628532 ], 25, 1 );
    const_str_digest_3d1c1b5a40bad5ea2b53479303af8ac3 = UNSTREAM_STRING( &constant_bin[ 1630793 ], 110, 0 );
    const_str_digest_c42ba573360bdf98cc14a40131013fc8 = UNSTREAM_STRING( &constant_bin[ 1630903 ], 33, 0 );
    const_str_digest_6dbcd0ad6d3e522de8841a8354327179 = UNSTREAM_STRING( &constant_bin[ 1630936 ], 31, 0 );
    const_str_digest_10f37e3bff7e991e751e7269ffabadb0 = UNSTREAM_STRING( &constant_bin[ 1630967 ], 30, 0 );
    const_str_plain_p_selection_statement_1 = UNSTREAM_STRING( &constant_bin[ 1629118 ], 23, 1 );
    const_str_digest_25da212803d8c0d225df3dfd19d548d9 = UNSTREAM_STRING( &constant_bin[ 1630997 ], 33, 0 );
    const_str_digest_eb511689ea0dfd7ea92bdc676c27cead = UNSTREAM_STRING( &constant_bin[ 1631030 ], 22, 0 );
    const_str_plain_p_direct_xxx_declarator_5 = UNSTREAM_STRING( &constant_bin[ 1628376 ], 25, 1 );
    const_str_digest_641c74115009f84216dbefa5d7bd4004 = UNSTREAM_STRING( &constant_bin[ 1631052 ], 156, 0 );
    const_str_digest_c7dec89123121915f4b9612d61ec875a = UNSTREAM_STRING( &constant_bin[ 1631208 ], 20, 0 );
    const_str_plain_p_compound_statement_1 = UNSTREAM_STRING( &constant_bin[ 1629025 ], 22, 1 );
    const_str_digest_1b8d0d478bf813fa092f6bca5ef1c206 = UNSTREAM_STRING( &constant_bin[ 1631228 ], 69, 0 );
    const_str_digest_6bc7376195f70b4ee319b4b195df915c = UNSTREAM_STRING( &constant_bin[ 1631297 ], 34, 0 );
    const_str_plain_p_struct_or_union_specifier_3 = UNSTREAM_STRING( &constant_bin[ 1627924 ], 29, 1 );
    const_str_plain_rules_with_opt = UNSTREAM_STRING( &constant_bin[ 1631331 ], 14, 1 );
    const_str_digest_3d708f088baf2d9fe04b4d4c3d1048e2 = UNSTREAM_STRING( &constant_bin[ 1631345 ], 98, 0 );
    const_str_plain_p_translation_unit_1 = UNSTREAM_STRING( &constant_bin[ 1626964 ], 20, 1 );
    const_tuple_str_plain_typeid_str_plain_TYPEID_tuple = PyTuple_New( 2 );
    const_str_plain_typeid = UNSTREAM_STRING( &constant_bin[ 1623190 ], 6, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_typeid_str_plain_TYPEID_tuple, 0, const_str_plain_typeid ); Py_INCREF( const_str_plain_typeid );
    PyTuple_SET_ITEM( const_tuple_str_plain_typeid_str_plain_TYPEID_tuple, 1, const_str_plain_TYPEID ); Py_INCREF( const_str_plain_TYPEID );
    const_str_digest_63caba6a8655f13f8d6329090735eda2 = UNSTREAM_STRING( &constant_bin[ 1631443 ], 26, 0 );
    const_str_digest_4d2282977f5acc83443a234c654eb96e = UNSTREAM_STRING( &constant_bin[ 1631469 ], 101, 0 );
    const_str_digest_4283807529d6bc7d66fde2041c90b214 = UNSTREAM_STRING( &constant_bin[ 1631570 ], 19, 0 );
    const_tuple_08c0da61fe57987f4fb46301e9d60b83_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_08c0da61fe57987f4fb46301e9d60b83_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_08c0da61fe57987f4fb46301e9d60b83_tuple, 1, const_str_plain_p ); Py_INCREF( const_str_plain_p );
    PyTuple_SET_ITEM( const_tuple_08c0da61fe57987f4fb46301e9d60b83_tuple, 2, const_str_plain_spec ); Py_INCREF( const_str_plain_spec );
    const_str_plain_ty = UNSTREAM_STRING( &constant_bin[ 895 ], 2, 1 );
    PyTuple_SET_ITEM( const_tuple_08c0da61fe57987f4fb46301e9d60b83_tuple, 3, const_str_plain_ty ); Py_INCREF( const_str_plain_ty );
    PyTuple_SET_ITEM( const_tuple_08c0da61fe57987f4fb46301e9d60b83_tuple, 4, const_str_plain_s_u_or_e ); Py_INCREF( const_str_plain_s_u_or_e );
    PyTuple_SET_ITEM( const_tuple_08c0da61fe57987f4fb46301e9d60b83_tuple, 5, const_str_plain_decls ); Py_INCREF( const_str_plain_decls );
    const_str_plain_p_id_init_declarator_list = UNSTREAM_STRING( &constant_bin[ 1627693 ], 25, 1 );
    const_str_plain_rule = UNSTREAM_STRING( &constant_bin[ 15136 ], 4, 1 );
    const_str_digest_47c288e3e3c1ec5382a287f33b329e55 = UNSTREAM_STRING( &constant_bin[ 1631589 ], 37, 0 );
    const_str_digest_e5e2ab4a197a763e089302e170784084 = UNSTREAM_STRING( &constant_bin[ 1631626 ], 31, 0 );
    const_str_plain_p_type_qualifier = UNSTREAM_STRING( &constant_bin[ 1627632 ], 16, 1 );
    const_str_digest_9003243efa0c0ecc239aa9a62dcb65fd = UNSTREAM_STRING( &constant_bin[ 1631657 ], 31, 0 );
    const_str_plain_p_specifier_qualifier_list_1 = UNSTREAM_STRING( &constant_bin[ 1627742 ], 28, 1 );
    const_str_digest_91fe4d48c7f332f506ad592767e0b1fa = UNSTREAM_STRING( &constant_bin[ 1631688 ], 23, 0 );
    const_str_plain_p_struct_declaration_2 = UNSTREAM_STRING( &constant_bin[ 1628025 ], 22, 1 );
    const_dict_a65047c1ba5fd08918aea9f317bf9947 = _PyDict_NewPresized( 4 );
    PyDict_SetItem( const_dict_a65047c1ba5fd08918aea9f317bf9947, const_str_plain_qual, const_list_empty );
    PyDict_SetItem( const_dict_a65047c1ba5fd08918aea9f317bf9947, const_str_plain_storage, const_list_empty );
    PyDict_SetItem( const_dict_a65047c1ba5fd08918aea9f317bf9947, const_str_plain_type, const_list_empty );
    PyDict_SetItem( const_dict_a65047c1ba5fd08918aea9f317bf9947, const_str_plain_function, const_list_empty );
    assert( PyDict_Size( const_dict_a65047c1ba5fd08918aea9f317bf9947 ) == 4 );
    const_str_plain_p_primary_expression_5 = UNSTREAM_STRING( &constant_bin[ 1629911 ], 22, 1 );
    const_str_plain_tn = UNSTREAM_STRING( &constant_bin[ 30602 ], 2, 1 );
    const_str_plain_p_primary_expression_2 = UNSTREAM_STRING( &constant_bin[ 1629839 ], 22, 1 );
    const_str_digest_b754de9b97f0b72d6dd37dec82ba5746 = UNSTREAM_STRING( &constant_bin[ 1631711 ], 26, 0 );
    const_str_plain_p_declaration = UNSTREAM_STRING( &constant_bin[ 1624299 ], 13, 1 );
    const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_item_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_item_tuple, 0, const_str_digest_b9c4baf879ebd882d40843df3a4dead7 ); Py_INCREF( const_str_digest_b9c4baf879ebd882d40843df3a4dead7 );
    PyTuple_SET_ITEM( const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_item_tuple, 1, const_str_plain_item ); Py_INCREF( const_str_plain_item );
    const_str_plain_p_specifier_qualifier_list_2 = UNSTREAM_STRING( &constant_bin[ 1627772 ], 28, 1 );
    const_str_digest_d642d0fe838aefefa0b9280cc6a39a38 = UNSTREAM_STRING( &constant_bin[ 1631737 ], 34, 0 );
    const_str_digest_d6ee975e0df9eca8d5440193b813bd7d = UNSTREAM_STRING( &constant_bin[ 1631771 ], 73, 0 );
    const_str_digest_6f2181aeaf73e778ef8fef0fecb260be = UNSTREAM_STRING( &constant_bin[ 1631844 ], 34, 0 );
    const_str_plain_p_struct_declaration_list = UNSTREAM_STRING( &constant_bin[ 1625224 ], 25, 1 );
    const_str_plain_p_declaration_list = UNSTREAM_STRING( &constant_bin[ 1627241 ], 18, 1 );
    const_str_digest_1e69359fa796c1d395f6ed6e958b1038 = UNSTREAM_STRING( &constant_bin[ 1631878 ], 33, 0 );
    const_str_digest_738bb76ee3cb1d75ac2eedcc90bfedb8 = UNSTREAM_STRING( &constant_bin[ 1631911 ], 18, 0 );
    const_tuple_list_str_plain_int_list_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_list_str_plain_int_list_tuple, 0, const_list_str_plain_int_list ); Py_INCREF( const_list_str_plain_int_list );
    const_str_plain_p_struct_or_union_specifier_1 = UNSTREAM_STRING( &constant_bin[ 1627862 ], 29, 1 );
    const_str_digest_12b5d80dbab35a1fee3c7294bdecc060 = UNSTREAM_STRING( &constant_bin[ 1631929 ], 38, 0 );
    const_str_plain__add_identifier = UNSTREAM_STRING( &constant_bin[ 1626633 ], 15, 1 );
    const_str_digest_73b402b81d578988831576aa55cece06 = UNSTREAM_STRING( &constant_bin[ 1631967 ], 97, 0 );
    const_str_digest_2cf67ea0a03b2cf611b58d5daaa1326b = UNSTREAM_STRING( &constant_bin[ 1632064 ], 38, 0 );
    const_str_plain_p_declaration_specifiers_no_type_1 = UNSTREAM_STRING( &constant_bin[ 1627261 ], 34, 1 );
    const_str_digest_c7350461c8319ccb9b869ca9d757d071 = UNSTREAM_STRING( &constant_bin[ 1632102 ], 155, 0 );
    const_str_digest_3aa1bda91d8a187cb1cfaa05f37e2a9a = UNSTREAM_STRING( &constant_bin[ 1632257 ], 152, 0 );
    const_str_digest_b3256d0808a5cfa78a9b07f0014ae192 = UNSTREAM_STRING( &constant_bin[ 1632409 ], 155, 0 );
    const_str_plain_p_direct_xxx_declarator_2 = UNSTREAM_STRING( &constant_bin[ 1628295 ], 25, 1 );
    const_str_plain_p_parameter_list = UNSTREAM_STRING( &constant_bin[ 1628487 ], 16, 1 );
    const_str_digest_229a95fb3332065f431f76ad875a569b = UNSTREAM_STRING( &constant_bin[ 1632564 ], 29, 0 );
    const_str_digest_cef2fc285c8d4fd024540eafb50e5036 = UNSTREAM_STRING( &constant_bin[ 1632593 ], 34, 0 );
    const_str_digest_246f58de0d8282544b0f16b8e9adffe7 = UNSTREAM_STRING( &constant_bin[ 1632627 ], 95, 0 );
    const_str_digest_edc88e6e620d04e505071707ba4525ca = UNSTREAM_STRING( &constant_bin[ 1632722 ], 38, 0 );
    const_str_digest_8ecbd0539063d98b175e5d1b148373e4 = UNSTREAM_STRING( &constant_bin[ 1632760 ], 100, 0 );
    const_str_plain_p_constant_expression = UNSTREAM_STRING( &constant_bin[ 1623150 ], 21, 1 );
    const_str_digest_59d40c66bd1068fb9a5fac1ba3853f9d = UNSTREAM_STRING( &constant_bin[ 1632860 ], 33, 0 );
    const_tuple_dbc31fde9862f09a6a68bd61c7b8a34c_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_dbc31fde9862f09a6a68bd61c7b8a34c_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_dbc31fde9862f09a6a68bd61c7b8a34c_tuple, 1, const_str_plain_spec ); Py_INCREF( const_str_plain_spec );
    PyTuple_SET_ITEM( const_tuple_dbc31fde9862f09a6a68bd61c7b8a34c_tuple, 2, const_str_plain_decl ); Py_INCREF( const_str_plain_decl );
    PyTuple_SET_ITEM( const_tuple_dbc31fde9862f09a6a68bd61c7b8a34c_tuple, 3, const_str_plain_param_decls ); Py_INCREF( const_str_plain_param_decls );
    PyTuple_SET_ITEM( const_tuple_dbc31fde9862f09a6a68bd61c7b8a34c_tuple, 4, const_str_plain_body ); Py_INCREF( const_str_plain_body );
    const_str_plain_declaration = UNSTREAM_STRING( &constant_bin[ 29401 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_dbc31fde9862f09a6a68bd61c7b8a34c_tuple, 5, const_str_plain_declaration ); Py_INCREF( const_str_plain_declaration );
    const_str_plain_modifier_head = UNSTREAM_STRING( &constant_bin[ 1632893 ], 13, 1 );
    const_str_plain_p_conditional_expression = UNSTREAM_STRING( &constant_bin[ 1629498 ], 24, 1 );
    const_str_plain_p_brace_open = UNSTREAM_STRING( &constant_bin[ 1630102 ], 12, 1 );
    const_str_digest_e1c12c8d1dab799b69e07b9066071ae2 = UNSTREAM_STRING( &constant_bin[ 1632906 ], 236, 0 );
    const_str_plain_nested_type = UNSTREAM_STRING( &constant_bin[ 1633142 ], 11, 1 );
    const_str_digest_26372fde2775fe57a8247ee618f79642 = UNSTREAM_STRING( &constant_bin[ 1633153 ], 31, 0 );
    const_str_plain_p_declaration_specifiers_6 = UNSTREAM_STRING( &constant_bin[ 1627509 ], 26, 1 );
    const_str_digest_680cc8fadbfc312c9e9abfca1ee7a562 = UNSTREAM_STRING( &constant_bin[ 1633184 ], 123, 0 );
    const_str_digest_0469223446185989541f16e54e881c26 = UNSTREAM_STRING( &constant_bin[ 1633307 ], 26, 0 );
    const_str_plain_p_declarator = UNSTREAM_STRING( &constant_bin[ 1628214 ], 12, 1 );
    const_str_digest_c0efe027b7adc1ecc803adc6bf777f4f = UNSTREAM_STRING( &constant_bin[ 1633333 ], 33, 0 );
    const_str_digest_1fca5d0e9bc76c0e07b262792fd8e99e = UNSTREAM_STRING( &constant_bin[ 1633366 ], 28, 0 );
    const_str_plain_p_pointer = UNSTREAM_STRING( &constant_bin[ 587267 ], 9, 1 );
    const_str_digest_a5744676b3080c705bd7d08f2eeaded7 = UNSTREAM_STRING( &constant_bin[ 1633394 ], 1387, 0 );
    const_str_digest_7525f41ae25b32b5ae040b76992d907b = UNSTREAM_STRING( &constant_bin[ 1634781 ], 83, 0 );
    const_str_digest_76ad672554caf5e4ae0ce3d708784295 = UNSTREAM_STRING( &constant_bin[ 1634864 ], 28, 0 );
    const_str_digest_5528a54872ed3f6e644fc93ddc6e4329 = UNSTREAM_STRING( &constant_bin[ 1634892 ], 33, 0 );
    const_str_digest_4c53af9b18e731d13a6eaff3cd61c1bd = UNSTREAM_STRING( &constant_bin[ 1634925 ], 25, 0 );
    const_str_digest_a20a4a402871289db2df557bee02c305 = UNSTREAM_STRING( &constant_bin[ 1634950 ], 52, 0 );
    const_str_digest_7c7abce5be464c1a2373a819305d6607 = UNSTREAM_STRING( &constant_bin[ 1635002 ], 31, 0 );
    const_str_digest_5ee1bd137846e03700116c37b66c1e9a = UNSTREAM_STRING( &constant_bin[ 1635033 ], 555, 0 );
    const_str_plain__get_yacc_lookahead_token = UNSTREAM_STRING( &constant_bin[ 1626751 ], 25, 1 );
    const_str_plain_p_selection_statement_3 = UNSTREAM_STRING( &constant_bin[ 1629168 ], 23, 1 );
    const_str_digest_e13114f89598d7e65c91b632f0cadbb8 = UNSTREAM_STRING( &constant_bin[ 1635588 ], 20, 0 );
    const_str_digest_4bcc04ea9ec07560edae21db6b5348a0 = UNSTREAM_STRING( &constant_bin[ 1635608 ], 19, 0 );
    const_str_digest_47d71f45ed595c6bc27351f58c7aaad0 = UNSTREAM_STRING( &constant_bin[ 1635627 ], 40, 0 );
    const_tuple_str_plain_self_str_plain_p_str_plain_klass_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_p_str_plain_klass_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_p_str_plain_klass_tuple, 1, const_str_plain_p ); Py_INCREF( const_str_plain_p );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_p_str_plain_klass_tuple, 2, const_str_plain_klass ); Py_INCREF( const_str_plain_klass );
    const_str_digest_218c48307caf6bfda88fe53635606a43 = UNSTREAM_STRING( &constant_bin[ 1635667 ], 120, 0 );
    const_str_digest_c921c8f322b3fd46a59553d2e5dfc401 = UNSTREAM_STRING( &constant_bin[ 1635787 ], 67, 0 );
    const_str_digest_c5fd27a7e790f10912398117eb633879 = UNSTREAM_STRING( &constant_bin[ 1635854 ], 185, 0 );
    const_str_digest_8a34c5f5b79e2060c67f54d2ea359c5c = UNSTREAM_STRING( &constant_bin[ 1636039 ], 29, 0 );
    const_str_digest_67949f32b9c50c7570da61d6f3116a3c = UNSTREAM_STRING( &constant_bin[ 1636068 ], 93, 0 );
    const_str_plain__lex_type_lookup_func = UNSTREAM_STRING( &constant_bin[ 1626728 ], 21, 1 );
    const_str_plain_modifier = UNSTREAM_STRING( &constant_bin[ 1632893 ], 8, 1 );
    const_str_plain_p_empty = UNSTREAM_STRING( &constant_bin[ 1624284 ], 7, 1 );
    const_str_plain_p_identifier = UNSTREAM_STRING( &constant_bin[ 1628559 ], 12, 1 );
    const_str_digest_e362d81bd9b3e85900445f8c349b8841 = UNSTREAM_STRING( &constant_bin[ 1636161 ], 31, 0 );
    const_str_digest_df2387d02cc8652fc0588206818d2a5b = UNSTREAM_STRING( &constant_bin[ 1636192 ], 32, 0 );
    const_str_plain_p_iteration_statement_1 = UNSTREAM_STRING( &constant_bin[ 1629193 ], 23, 1 );
    const_str_plain_p_function_definition_1 = UNSTREAM_STRING( &constant_bin[ 1627150 ], 23, 1 );
    const_str_digest_99ef339a31ce34c0e20749e73057955b = UNSTREAM_STRING( &constant_bin[ 1636224 ], 26, 0 );
    const_str_digest_8e675f7522c50836436091bad083eade = UNSTREAM_STRING( &constant_bin[ 1636250 ], 24, 0 );
    const_str_plain_LBRACE = UNSTREAM_STRING( &constant_bin[ 1617405 ], 6, 1 );
    const_str_digest_6e95ffeb0e7816beaeca0e8f138f7c30 = UNSTREAM_STRING( &constant_bin[ 1636274 ], 38, 0 );
    const_str_plain_p_declaration_specifiers_3 = UNSTREAM_STRING( &constant_bin[ 1627425 ], 26, 1 );
    const_tuple_str_plain_self_str_plain_p_str_plain_init_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_p_str_plain_init_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_p_str_plain_init_tuple, 1, const_str_plain_p ); Py_INCREF( const_str_plain_p );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_p_str_plain_init_tuple, 2, const_str_plain_init ); Py_INCREF( const_str_plain_init );
    const_str_digest_67292cb13e9197e2fb2c1781dd68cf71 = UNSTREAM_STRING( &constant_bin[ 1636312 ], 223, 0 );
    const_str_digest_388dfcadefec749acf799f03439e30db = UNSTREAM_STRING( &constant_bin[ 1624242 ], 24, 0 );
    const_str_digest_4b825c9f3babefb0715ce67102552636 = UNSTREAM_STRING( &constant_bin[ 1636535 ], 104, 0 );
    const_str_plain_p_declaration_specifiers_5 = UNSTREAM_STRING( &constant_bin[ 1627481 ], 26, 1 );
    const_str_digest_420d2d0b3c68fd79b820d0f6672b0a25 = UNSTREAM_STRING( &constant_bin[ 1636639 ], 40, 0 );
    const_str_digest_6ab508e6c2405e1a94cf3d2c7c0831cb = UNSTREAM_STRING( &constant_bin[ 1636679 ], 65, 0 );
    const_str_plain__lex_error_func = UNSTREAM_STRING( &constant_bin[ 1626669 ], 15, 1 );
    const_str_plain__is_type_in_scope = UNSTREAM_STRING( &constant_bin[ 1626650 ], 17, 1 );
    const_str_digest_f5a05b9f3549c638d7908479c708f6c5 = UNSTREAM_STRING( &constant_bin[ 1636744 ], 34, 0 );
    const_str_plain_is_type = UNSTREAM_STRING( &constant_bin[ 1626651 ], 7, 1 );
    const_tuple_b9ac4cd6be84011bb32a829063c1f63d_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 1636778 ], 180 );
    const_str_digest_35fa98ecde313fbb87f970e5b6d1309e = UNSTREAM_STRING( &constant_bin[ 1636958 ], 27, 0 );
    const_str_plain_p_declaration_specifiers_no_type_3 = UNSTREAM_STRING( &constant_bin[ 1624299 ], 34, 1 );
    const_str_digest_b42a0c796084440910713d8694dbdc5e = UNSTREAM_STRING( &constant_bin[ 1636985 ], 20, 0 );
    const_str_plain_p_jump_statement_1 = UNSTREAM_STRING( &constant_bin[ 1629293 ], 18, 1 );
    const_tuple_751da5b1a920ae509d273d698c85b4d3_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_751da5b1a920ae509d273d698c85b4d3_tuple, 0, const_tuple_str_plain_id_str_plain_ID_tuple ); Py_INCREF( const_tuple_str_plain_id_str_plain_ID_tuple );
    PyTuple_SET_ITEM( const_tuple_751da5b1a920ae509d273d698c85b4d3_tuple, 1, const_tuple_str_plain_typeid_str_plain_TYPEID_tuple ); Py_INCREF( const_tuple_str_plain_typeid_str_plain_TYPEID_tuple );
    const_str_digest_9bb26e7c3ad302320772fd07b96a4189 = UNSTREAM_STRING( &constant_bin[ 1637005 ], 70, 0 );
    const_str_plain_typedef_namespace = UNSTREAM_STRING( &constant_bin[ 1624908 ], 17, 1 );
    const_str_digest_1a34dbec4760d533fb71694a481d5e82 = UNSTREAM_STRING( &constant_bin[ 1637075 ], 27, 0 );
    const_str_digest_3a2b2d446e67b8b60dcfe60187bbb94a = UNSTREAM_STRING( &constant_bin[ 1637102 ], 83, 0 );
    const_str_digest_67ab4d59a0c077231f5627abe5a96096 = UNSTREAM_STRING( &constant_bin[ 1637185 ], 90, 0 );
    const_str_digest_d5fcd1840d9fbc06c9c5a3527fc1847d = UNSTREAM_STRING( &constant_bin[ 1637275 ], 16, 0 );
    const_str_digest_821acde88c2af9a2f13af52e0c27fed6 = UNSTREAM_STRING( &constant_bin[ 1637291 ], 64, 0 );
    const_str_digest_05d595f63bad393233213e890f949113 = UNSTREAM_STRING( &constant_bin[ 1637355 ], 42, 0 );
    const_tuple_dd6b1b91cc0261088d31198011b3777b_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_dd6b1b91cc0261088d31198011b3777b_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_dd6b1b91cc0261088d31198011b3777b_tuple, 1, const_str_plain_declspec ); Py_INCREF( const_str_plain_declspec );
    const_str_plain_newspec = UNSTREAM_STRING( &constant_bin[ 1637397 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_dd6b1b91cc0261088d31198011b3777b_tuple, 2, const_str_plain_newspec ); Py_INCREF( const_str_plain_newspec );
    PyTuple_SET_ITEM( const_tuple_dd6b1b91cc0261088d31198011b3777b_tuple, 3, const_str_plain_kind ); Py_INCREF( const_str_plain_kind );
    PyTuple_SET_ITEM( const_tuple_dd6b1b91cc0261088d31198011b3777b_tuple, 4, const_str_plain_append ); Py_INCREF( const_str_plain_append );
    PyTuple_SET_ITEM( const_tuple_dd6b1b91cc0261088d31198011b3777b_tuple, 5, const_str_plain_spec ); Py_INCREF( const_str_plain_spec );
    const_str_digest_571f26da7d7ba7969e33ae47d529100a = UNSTREAM_STRING( &constant_bin[ 1637404 ], 40, 0 );
    const_str_plain_p_initializer_list = UNSTREAM_STRING( &constant_bin[ 1628612 ], 18, 1 );
    const_tuple_str_plain_CLexer_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_CLexer_tuple, 0, const_str_plain_CLexer ); Py_INCREF( const_str_plain_CLexer );
    const_str_digest_b69fc3ce48390b0e9cfa18d81a30a6e0 = UNSTREAM_STRING( &constant_bin[ 1637444 ], 64, 0 );
    const_str_digest_f6e25df3d800bc64ee76c249251a121b = UNSTREAM_STRING( &constant_bin[ 1637508 ], 15, 0 );
    const_str_digest_2e1cbe41f85e408c79a828dbf5edff43 = UNSTREAM_STRING( &constant_bin[ 1637523 ], 255, 0 );
    const_str_digest_0c8f1309a535f9f28741353a49e7264a = UNSTREAM_STRING( &constant_bin[ 1637778 ], 42, 0 );
    const_str_plain_dummytype = UNSTREAM_STRING( &constant_bin[ 1637820 ], 9, 1 );
    const_str_digest_483f66f5df35d692c60dbf8d94b9ce53 = UNSTREAM_STRING( &constant_bin[ 1637829 ], 77, 0 );
    const_tuple_92a4268d571593236672ed5e2ec111d7_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_92a4268d571593236672ed5e2ec111d7_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_92a4268d571593236672ed5e2ec111d7_tuple, 1, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    const_str_plain_scope = UNSTREAM_STRING( &constant_bin[ 16333 ], 5, 1 );
    PyTuple_SET_ITEM( const_tuple_92a4268d571593236672ed5e2ec111d7_tuple, 2, const_str_plain_scope ); Py_INCREF( const_str_plain_scope );
    PyTuple_SET_ITEM( const_tuple_92a4268d571593236672ed5e2ec111d7_tuple, 3, const_str_plain_in_scope ); Py_INCREF( const_str_plain_in_scope );
    const_str_digest_aa59018a8d0d3fcfa3ad474999db574d = UNSTREAM_STRING( &constant_bin[ 1637906 ], 196, 0 );
    const_str_digest_647a6e3276e06f7939544595fc801eba = UNSTREAM_STRING( &constant_bin[ 1638102 ], 111, 0 );
    const_str_digest_3e10b62863993a2cc69fa833b1c10828 = UNSTREAM_STRING( &constant_bin[ 1638213 ], 33, 0 );
    const_str_digest_7cdb66da260f8b202170173dc4a6470f = UNSTREAM_STRING( &constant_bin[ 1638246 ], 27, 0 );
    const_str_plain_p_designator_list = UNSTREAM_STRING( &constant_bin[ 1628647 ], 17, 1 );
    const_str_digest_0e25af74743e7bbe803c3850cf908d5e = UNSTREAM_STRING( &constant_bin[ 1638273 ], 81, 0 );
    const_str_digest_3502e26f1e7e9795bcde23e020a1c6c2 = UNSTREAM_STRING( &constant_bin[ 1638354 ], 22, 0 );
    const_str_plain_decl_tail = UNSTREAM_STRING( &constant_bin[ 1638376 ], 9, 1 );
    const_str_digest_fb1821a12d9337038c5f0ba339bff7bc = UNSTREAM_STRING( &constant_bin[ 1638385 ], 33, 0 );
    const_str_plain_p_primary_expression_1 = UNSTREAM_STRING( &constant_bin[ 1629815 ], 22, 1 );
    const_str_digest_fdd5d372186562e91a02b35106e75db3 = UNSTREAM_STRING( &constant_bin[ 1638418 ], 89, 0 );
    const_str_digest_03c3aa4a35ee337fabd3abd65350cf72 = UNSTREAM_STRING( &constant_bin[ 1638507 ], 139, 0 );
    const_str_digest_d86600b943a4c7555073e3e4856d1089 = UNSTREAM_STRING( &constant_bin[ 1638646 ], 20, 0 );
    const_str_digest_7aa878e9a432a70b1be9c111bdefc021 = UNSTREAM_STRING( &constant_bin[ 1638666 ], 57, 0 );
    const_tuple_str_plain_bitsize_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_bitsize_tuple, 0, const_str_plain_bitsize ); Py_INCREF( const_str_plain_bitsize );
    const_str_plain_p_unary_expression_3 = UNSTREAM_STRING( &constant_bin[ 1629631 ], 20, 1 );
    const_str_plain_p_abstract_declarator_2 = UNSTREAM_STRING( &constant_bin[ 1628718 ], 23, 1 );
    const_str_digest_07bf1055960239c6afdf14732b3e2626 = UNSTREAM_STRING( &constant_bin[ 1638723 ], 311, 0 );
    const_str_plain_translation_unit_or_empty = UNSTREAM_STRING( &constant_bin[ 1626937 ], 25, 1 );
    const_str_digest_be14d60093071f59d0507692040d9a94 = UNSTREAM_STRING( &constant_bin[ 1639034 ], 25, 0 );
    const_str_plain_p_postfix_expression_2 = UNSTREAM_STRING( &constant_bin[ 1629695 ], 22, 1 );
    const_str_digest_f25f218a0c1f5cad198347bc47b76ed9 = UNSTREAM_STRING( &constant_bin[ 1639059 ], 28, 0 );
    const_str_digest_467f5498c75043f32be58f16f19f8328 = UNSTREAM_STRING( &constant_bin[ 1631589 ], 25, 0 );
    const_str_digest_8d8f57fbf9ace4a819eb9da34e88ef83 = UNSTREAM_STRING( &constant_bin[ 1639087 ], 31, 0 );
    const_str_digest_5494df6239ebd6d1e5bb525f10a0f6cd = UNSTREAM_STRING( &constant_bin[ 1639118 ], 92, 0 );
    const_str_digest_d16adbea55fe0967a56b6e6ba6b8aa8a = UNSTREAM_STRING( &constant_bin[ 1639210 ], 27, 0 );
    const_str_digest_55677b557b6476d90f099cb7f3f3bf9c = UNSTREAM_STRING( &constant_bin[ 1639237 ], 27, 0 );
    const_tuple_str_plain_self_str_plain_p_str_plain_quals_str_plain_arr_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_p_str_plain_quals_str_plain_arr_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_p_str_plain_quals_str_plain_arr_tuple, 1, const_str_plain_p ); Py_INCREF( const_str_plain_p );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_p_str_plain_quals_str_plain_arr_tuple, 2, const_str_plain_quals ); Py_INCREF( const_str_plain_quals );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_p_str_plain_quals_str_plain_arr_tuple, 3, const_str_plain_arr ); Py_INCREF( const_str_plain_arr );
    const_str_digest_432c60fb536d6a5750f1ead762b4062e = UNSTREAM_STRING( &constant_bin[ 1639264 ], 29, 0 );
    const_str_digest_7d9088072ecc638c9f57de60088a1028 = UNSTREAM_STRING( &constant_bin[ 1639293 ], 38, 0 );
    const_str_plain_p_declaration_specifiers_1 = UNSTREAM_STRING( &constant_bin[ 1627369 ], 26, 1 );
    const_str_digest_d19791b80d76ff0c0c5ce1c5dc8220b7 = UNSTREAM_STRING( &constant_bin[ 1639331 ], 34, 0 );
    const_str_digest_673754ad82ad40b5e8cfbef5f26fa28b = UNSTREAM_STRING( &constant_bin[ 1639365 ], 160, 0 );
    const_tuple_f1ccb3db058b3624653c84c90fc9f384_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_f1ccb3db058b3624653c84c90fc9f384_tuple, 0, const_tuple_str_plain_id_str_plain_ID_tuple ); Py_INCREF( const_tuple_str_plain_id_str_plain_ID_tuple );
    PyTuple_SET_ITEM( const_tuple_f1ccb3db058b3624653c84c90fc9f384_tuple, 1, const_tuple_str_plain_typeid_str_plain_TYPEID_tuple ); Py_INCREF( const_tuple_str_plain_typeid_str_plain_TYPEID_tuple );
    PyTuple_SET_ITEM( const_tuple_f1ccb3db058b3624653c84c90fc9f384_tuple, 2, const_tuple_str_plain_typeid_noparen_str_plain_TYPEID_tuple ); Py_INCREF( const_tuple_str_plain_typeid_noparen_str_plain_TYPEID_tuple );
    const_str_digest_4d5064fee01745e0edfcfd695c906323 = UNSTREAM_STRING( &constant_bin[ 1639525 ], 82, 0 );
    const_str_plain_p_labeled_statement_2 = UNSTREAM_STRING( &constant_bin[ 1629072 ], 21, 1 );
    const_str_plain_p_direct_abstract_declarator_1 = UNSTREAM_STRING( &constant_bin[ 1628768 ], 30, 1 );
    const_str_plain_p_type_qualifier_list = UNSTREAM_STRING( &constant_bin[ 1628441 ], 21, 1 );
    const_str_digest_0cf7bbaa709fa7445d261c18853462db = UNSTREAM_STRING( &constant_bin[ 1639607 ], 31, 0 );
    const_str_digest_23aa0dacc3c1436a615874779d7ba221 = UNSTREAM_STRING( &constant_bin[ 1639638 ], 13, 0 );
    const_str_digest_7f1585ee0758766cedaf1624cb16edb0 = UNSTREAM_STRING( &constant_bin[ 1639651 ], 26, 0 );
    const_str_digest_e6054102b697f4379243ef2e481d9de1 = UNSTREAM_STRING( &constant_bin[ 1639677 ], 42, 0 );
    const_str_digest_12f9e6fe12f7541fa2b46186a390fa7e = UNSTREAM_STRING( &constant_bin[ 1639719 ], 123, 0 );
    const_tuple_str_plain_self_str_plain_name_str_plain_is_type_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_name_str_plain_is_type_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_name_str_plain_is_type_tuple, 1, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_name_str_plain_is_type_tuple, 2, const_str_plain_is_type ); Py_INCREF( const_str_plain_is_type );
    const_str_digest_eae5a57ac505c9fd51dcee063c70c12f = UNSTREAM_STRING( &constant_bin[ 1639842 ], 20, 0 );
    const_str_plain_p_brace_close = UNSTREAM_STRING( &constant_bin[ 1630116 ], 13, 1 );
    const_str_digest_c07bd5cfbc553d3631d0a1668f710914 = UNSTREAM_STRING( &constant_bin[ 1639862 ], 98, 0 );
    const_str_plain_p_enum_specifier_1 = UNSTREAM_STRING( &constant_bin[ 1628121 ], 18, 1 );
    const_str_digest_576430d2ecd57cd9248634515b4042e1 = UNSTREAM_STRING( &constant_bin[ 1639960 ], 59, 0 );
    const_str_plain_p_struct_or_union = UNSTREAM_STRING( &constant_bin[ 1627862 ], 17, 1 );
    const_str_plain_p_postfix_expression_4 = UNSTREAM_STRING( &constant_bin[ 1626244 ], 22, 1 );
    const_str_digest_df25ccf54e7b8d881231a8646232b4c5 = UNSTREAM_STRING( &constant_bin[ 1640019 ], 50, 0 );
    const_str_digest_abe9cf4d34820d00ecbbe01507e8a236 = UNSTREAM_STRING( &constant_bin[ 1640069 ], 167, 0 );
    const_str_plain_p_direct_xxx_declarator_4 = UNSTREAM_STRING( &constant_bin[ 1628349 ], 25, 1 );
    const_str_plain_p_specifier_qualifier_list_4 = UNSTREAM_STRING( &constant_bin[ 1627832 ], 28, 1 );
    const_dict_9d1be102e274ebd5d21e13e40f132db0 = _PyDict_NewPresized( 1 );
    PyDict_SetItem( const_dict_9d1be102e274ebd5d21e13e40f132db0, const_str_plain_append, Py_True );
    assert( PyDict_Size( const_dict_9d1be102e274ebd5d21e13e40f132db0 ) == 1 );
    const_str_plain_p_storage_class_specifier = UNSTREAM_STRING( &constant_bin[ 1627537 ], 25, 1 );
    const_str_digest_52b362b68c1a3994b3c354ae840e20f1 = UNSTREAM_STRING( &constant_bin[ 1640236 ], 255, 0 );
    const_str_digest_e60fde1ce3556920242aca8b3c191efe = UNSTREAM_STRING( &constant_bin[ 1640491 ], 30, 0 );
    const_str_plain__push_scope = UNSTREAM_STRING( &constant_bin[ 1626589 ], 11, 1 );
    const_str_digest_294b43969495463422d51c2e0af683fa = UNSTREAM_STRING( &constant_bin[ 1640521 ], 23, 0 );
    const_list_dict_empty_list = PyList_New( 1 );
    PyList_SET_ITEM( const_list_dict_empty_list, 0, const_dict_empty ); Py_INCREF( const_dict_empty );
    const_str_digest_f4c586e057933351dce958e95b28310c = UNSTREAM_STRING( &constant_bin[ 1640544 ], 43, 0 );
    const_str_digest_aee4be64fec3aac8f4cc13847cf5d34c = UNSTREAM_STRING( &constant_bin[ 1640587 ], 97, 0 );
    const_str_digest_436d5669d5bef2966850e86231313d36 = UNSTREAM_STRING( &constant_bin[ 1640684 ], 20, 0 );
    const_str_plain__lex_on_rbrace_func = UNSTREAM_STRING( &constant_bin[ 1626707 ], 19, 1 );
    const_str_digest_86e7bc379ddaa437cb4d0740b0f09628 = UNSTREAM_STRING( &constant_bin[ 1640704 ], 77, 0 );
    const_str_plain_p_direct_abstract_declarator_6 = UNSTREAM_STRING( &constant_bin[ 1628928 ], 30, 1 );
    const_str_digest_f902c40d06583479323f2a0e09f149d0 = UNSTREAM_STRING( &constant_bin[ 1640781 ], 30, 0 );
    const_str_digest_52db91b7c1f71ae57834d48da56bbc3e = UNSTREAM_STRING( &constant_bin[ 1640811 ], 32, 0 );
    const_str_digest_05db319dd614b03c1a9c5cbdcfc77915 = UNSTREAM_STRING( &constant_bin[ 1640843 ], 30, 0 );
    const_str_digest_4d9f5a102c6e338e4518642310a06235 = UNSTREAM_STRING( &constant_bin[ 1640873 ], 105, 0 );
    const_str_digest_c9f59b1fa5017cb9005bb768b7c0c697 = UNSTREAM_STRING( &constant_bin[ 1640978 ], 31, 0 );
    const_str_digest_124cdd6e5c1c3bca0c3f9db3c722414e = UNSTREAM_STRING( &constant_bin[ 1641009 ], 29, 0 );
    const_str_plain_p_translation_unit_or_empty = UNSTREAM_STRING( &constant_bin[ 1626935 ], 27, 1 );
    const_str_digest_f652614c068fd18ab6b54821e3f5e567 = UNSTREAM_STRING( &constant_bin[ 1641038 ], 33, 0 );
    const_str_digest_5818384d85f9531b5d1a4dc60515c5ef = UNSTREAM_STRING( &constant_bin[ 1641071 ], 167, 0 );
    const_str_plain_p_designation = UNSTREAM_STRING( &constant_bin[ 1628632 ], 13, 1 );
    const_str_plain_p_declaration_specifiers_4 = UNSTREAM_STRING( &constant_bin[ 1627453 ], 26, 1 );
    const_str_digest_97d8cb402d283686d305a0534205cf16 = UNSTREAM_STRING( &constant_bin[ 1641238 ], 106, 0 );
    const_str_digest_55a08934bb62f870d418c2065396356a = UNSTREAM_STRING( &constant_bin[ 1641344 ], 26, 0 );
    const_tuple_f42d7b470c00f28d1af65a7593268b5b_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_f42d7b470c00f28d1af65a7593268b5b_tuple, 0, const_str_digest_b9c4baf879ebd882d40843df3a4dead7 ); Py_INCREF( const_str_digest_b9c4baf879ebd882d40843df3a4dead7 );
    const_str_plain_sublist = UNSTREAM_STRING( &constant_bin[ 248352 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_f42d7b470c00f28d1af65a7593268b5b_tuple, 1, const_str_plain_sublist ); Py_INCREF( const_str_plain_sublist );
    PyTuple_SET_ITEM( const_tuple_f42d7b470c00f28d1af65a7593268b5b_tuple, 2, const_str_plain_qual ); Py_INCREF( const_str_plain_qual );
    const_str_digest_41f6ebfa89aad8d3dfc1d7132e5ff63a = UNSTREAM_STRING( &constant_bin[ 1641370 ], 36, 0 );
    const_str_digest_568b35cedd50be265c02bbdb7a7eb88d = UNSTREAM_STRING( &constant_bin[ 1641406 ], 37, 0 );
    const_str_plain_p_postfix_expression_6 = UNSTREAM_STRING( &constant_bin[ 1629791 ], 22, 1 );
    const_str_plain_p_initializer_2 = UNSTREAM_STRING( &constant_bin[ 1628595 ], 15, 1 );
    const_str_digest_04b031e3a95a05949b8673c1377c8678 = UNSTREAM_STRING( &constant_bin[ 1641443 ], 32, 0 );
    const_str_digest_e50bcc58dedc95a40e88a177d13094dc = UNSTREAM_STRING( &constant_bin[ 1641475 ], 132, 0 );
    const_str_plain_p_abstract_declarator_3 = UNSTREAM_STRING( &constant_bin[ 1628743 ], 23, 1 );
    const_str_plain_lex_optimize = UNSTREAM_STRING( &constant_bin[ 1641607 ], 12, 1 );
    const_str_digest_ca8a32ff5c72a1ecfed53d1c8b17063d = UNSTREAM_STRING( &constant_bin[ 1622966 ], 25, 0 );
    const_str_plain_p_function_specifier = UNSTREAM_STRING( &constant_bin[ 1627564 ], 20, 1 );
    const_str_digest_90a2bfabec7dd4c758b77580ec12f8b8 = UNSTREAM_STRING( &constant_bin[ 1641619 ], 33, 0 );
    const_str_digest_6e6c77e24cfc9a052b7d222f6e6f60cf = UNSTREAM_STRING( &constant_bin[ 1641652 ], 36, 0 );
    const_str_digest_d0dce591a53a04884750228ee0143163 = UNSTREAM_STRING( &constant_bin[ 1641688 ], 30, 0 );
    const_str_digest_a3ba25157bfdb97c14e3f422913e6e9a = UNSTREAM_STRING( &constant_bin[ 1641718 ], 24, 0 );
    const_str_digest_74fea7cff33b7bf42ce4fcb20f366d7e = UNSTREAM_STRING( &constant_bin[ 1641742 ], 36, 0 );
    const_str_digest_bf7acc4751dc5b6ecae6da620bd3895d = UNSTREAM_STRING( &constant_bin[ 1641778 ], 33, 0 );
    const_str_digest_0ba0c181eb95710a8b10bf6f48d47eb7 = UNSTREAM_STRING( &constant_bin[ 1641811 ], 19, 0 );
    const_str_plain_p_decl_body = UNSTREAM_STRING( &constant_bin[ 1627213 ], 11, 1 );
    const_str_digest_0ebf677191c7d5c09c299499be874cec = UNSTREAM_STRING( &constant_bin[ 1641830 ], 143, 0 );
    const_str_digest_c88ddef41084d2b01880f788a8e1915e = UNSTREAM_STRING( &constant_bin[ 1641973 ], 110, 0 );
    const_str_digest_9ca4962d95812b4146545cad53121567 = UNSTREAM_STRING( &constant_bin[ 1642083 ], 34, 0 );
    const_str_plain_p_enum_specifier_3 = UNSTREAM_STRING( &constant_bin[ 1628161 ], 18, 1 );
    const_str_plain_p_direct_abstract_declarator_2 = UNSTREAM_STRING( &constant_bin[ 1628800 ], 30, 1 );
    const_str_digest_791b8912d692e91ab59be831ef8bc1a7 = UNSTREAM_STRING( &constant_bin[ 1642117 ], 49, 0 );
    const_str_digest_0037b7bb71b496183bd8ef3fbe80fbf7 = UNSTREAM_STRING( &constant_bin[ 1642166 ], 32, 0 );
    const_str_plain_listed_quals = UNSTREAM_STRING( &constant_bin[ 1642198 ], 12, 1 );
    const_str_digest_b4df5602eb44336fd139f1d9d4f707a8 = UNSTREAM_STRING( &constant_bin[ 1642210 ], 18, 0 );
    const_str_plain_p_unary_expression_1 = UNSTREAM_STRING( &constant_bin[ 1629587 ], 20, 1 );
    const_str_plain_p_enumerator_list = UNSTREAM_STRING( &constant_bin[ 1628181 ], 17, 1 );
    const_str_digest_ed337dbead15c0fdcf05f046938efb38 = UNSTREAM_STRING( &constant_bin[ 1642228 ], 27, 0 );
    const_str_plain_yacc_optimize = UNSTREAM_STRING( &constant_bin[ 1642255 ], 13, 1 );
    const_str_digest_547b0820a3a668896a8f847d79c3b158 = UNSTREAM_STRING( &constant_bin[ 1642268 ], 128, 0 );
    const_str_digest_8ad640be40d1e51038889c0ad468a995 = UNSTREAM_STRING( &constant_bin[ 1642396 ], 79, 0 );
    const_str_digest_59e6ee836c87207f91389c76e8f37211 = UNSTREAM_STRING( &constant_bin[ 1642475 ], 144, 0 );
    const_str_plain_p_unified_wstring_literal = UNSTREAM_STRING( &constant_bin[ 1630075 ], 25, 1 );
    const_tuple_a4b7bb804c3c87f7b7aff1f402fad3af_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_a4b7bb804c3c87f7b7aff1f402fad3af_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_a4b7bb804c3c87f7b7aff1f402fad3af_tuple, 1, const_str_plain_p ); Py_INCREF( const_str_plain_p );
    PyTuple_SET_ITEM( const_tuple_a4b7bb804c3c87f7b7aff1f402fad3af_tuple, 2, const_str_plain_listed_quals ); Py_INCREF( const_str_plain_listed_quals );
    PyTuple_SET_ITEM( const_tuple_a4b7bb804c3c87f7b7aff1f402fad3af_tuple, 3, const_str_plain_dim_quals ); Py_INCREF( const_str_plain_dim_quals );
    PyTuple_SET_ITEM( const_tuple_a4b7bb804c3c87f7b7aff1f402fad3af_tuple, 4, const_str_plain_arr ); Py_INCREF( const_str_plain_arr );
    const_str_plain_p_enum_specifier_2 = UNSTREAM_STRING( &constant_bin[ 1628141 ], 18, 1 );
    const_str_digest_9b2521a2a4f11b3568e8ad30e3a505ca = UNSTREAM_STRING( &constant_bin[ 1642619 ], 72, 0 );
    const_str_digest_6c52cb702432c3d80308420329a005f0 = UNSTREAM_STRING( &constant_bin[ 1642691 ], 37, 0 );
    const_str_digest_e658ac8c4b7c2299a86f760a10b99615 = UNSTREAM_STRING( &constant_bin[ 1626501 ], 20, 0 );
    const_str_digest_5e2d8ee1259d7fabe59ee8fbc3b91004 = UNSTREAM_STRING( &constant_bin[ 1642728 ], 30, 0 );
    const_str_digest_aefe7a31071e8b90b70d14309835c4e8 = UNSTREAM_STRING( &constant_bin[ 1642758 ], 72, 0 );
    const_str_digest_eb88e54a205432a72790f32cf3ad216c = UNSTREAM_STRING( &constant_bin[ 1642830 ], 87, 0 );
    const_tuple_75d110c860c3329371e02201c24c7204_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_75d110c860c3329371e02201c24c7204_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_75d110c860c3329371e02201c24c7204_tuple, 1, const_str_plain_text ); Py_INCREF( const_str_plain_text );
    PyTuple_SET_ITEM( const_tuple_75d110c860c3329371e02201c24c7204_tuple, 2, const_str_plain_filename ); Py_INCREF( const_str_plain_filename );
    PyTuple_SET_ITEM( const_tuple_75d110c860c3329371e02201c24c7204_tuple, 3, const_str_plain_debuglevel ); Py_INCREF( const_str_plain_debuglevel );
    const_str_plain_taboutputdir = UNSTREAM_STRING( &constant_bin[ 1642917 ], 12, 1 );
    const_str_digest_ee647972fdff9211886cabce258b38a4 = UNSTREAM_STRING( &constant_bin[ 1642929 ], 19, 0 );
    const_tuple_f2e4debd813b1d9581312e122bd2eee4_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_f2e4debd813b1d9581312e122bd2eee4_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_f2e4debd813b1d9581312e122bd2eee4_tuple, 1, const_str_plain_p ); Py_INCREF( const_str_plain_p );
    PyTuple_SET_ITEM( const_tuple_f2e4debd813b1d9581312e122bd2eee4_tuple, 2, const_str_plain_spec ); Py_INCREF( const_str_plain_spec );
    PyTuple_SET_ITEM( const_tuple_f2e4debd813b1d9581312e122bd2eee4_tuple, 3, const_str_plain_decls ); Py_INCREF( const_str_plain_decls );
    PyTuple_SET_ITEM( const_tuple_f2e4debd813b1d9581312e122bd2eee4_tuple, 4, const_str_plain_node ); Py_INCREF( const_str_plain_node );
    const_str_plain_decl_type = UNSTREAM_STRING( &constant_bin[ 1642948 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_f2e4debd813b1d9581312e122bd2eee4_tuple, 5, const_str_plain_decl_type ); Py_INCREF( const_str_plain_decl_type );
    const_str_digest_33b3b26831c9fdeed6fb503fb3235253 = UNSTREAM_STRING( &constant_bin[ 1642957 ], 29, 0 );
    const_str_digest_51cb11be562c4e62872e5a99fb92c982 = UNSTREAM_STRING( &constant_bin[ 1642986 ], 156, 0 );
    const_str_digest_711802f92e6a2899ad0c3a102d2f0802 = UNSTREAM_STRING( &constant_bin[ 1643142 ], 32, 0 );
    const_str_digest_d22a9d10bffbeaa38403c3c0bb0d1558 = UNSTREAM_STRING( &constant_bin[ 1643174 ], 65, 0 );
    const_tuple_05106f1143fd548d61395e9607a1282d_tuple = PyTuple_New( 10 );
    PyTuple_SET_ITEM( const_tuple_05106f1143fd548d61395e9607a1282d_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_05106f1143fd548d61395e9607a1282d_tuple, 1, const_str_plain_lex_optimize ); Py_INCREF( const_str_plain_lex_optimize );
    PyTuple_SET_ITEM( const_tuple_05106f1143fd548d61395e9607a1282d_tuple, 2, const_str_plain_lexer ); Py_INCREF( const_str_plain_lexer );
    PyTuple_SET_ITEM( const_tuple_05106f1143fd548d61395e9607a1282d_tuple, 3, const_str_plain_lextab ); Py_INCREF( const_str_plain_lextab );
    PyTuple_SET_ITEM( const_tuple_05106f1143fd548d61395e9607a1282d_tuple, 4, const_str_plain_yacc_optimize ); Py_INCREF( const_str_plain_yacc_optimize );
    const_str_plain_yacctab = UNSTREAM_STRING( &constant_bin[ 1625571 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_05106f1143fd548d61395e9607a1282d_tuple, 5, const_str_plain_yacctab ); Py_INCREF( const_str_plain_yacctab );
    const_str_plain_yacc_debug = UNSTREAM_STRING( &constant_bin[ 1643239 ], 10, 1 );
    PyTuple_SET_ITEM( const_tuple_05106f1143fd548d61395e9607a1282d_tuple, 6, const_str_plain_yacc_debug ); Py_INCREF( const_str_plain_yacc_debug );
    PyTuple_SET_ITEM( const_tuple_05106f1143fd548d61395e9607a1282d_tuple, 7, const_str_plain_taboutputdir ); Py_INCREF( const_str_plain_taboutputdir );
    PyTuple_SET_ITEM( const_tuple_05106f1143fd548d61395e9607a1282d_tuple, 8, const_str_plain_rules_with_opt ); Py_INCREF( const_str_plain_rules_with_opt );
    PyTuple_SET_ITEM( const_tuple_05106f1143fd548d61395e9607a1282d_tuple, 9, const_str_plain_rule ); Py_INCREF( const_str_plain_rule );
    const_str_plain_p_iteration_statement_4 = UNSTREAM_STRING( &constant_bin[ 1629268 ], 23, 1 );
    const_str_digest_4747c94525afd53dfec17ba56a3a01da = UNSTREAM_STRING( &constant_bin[ 1643249 ], 33, 0 );
    const_str_plain_p_labeled_statement_1 = UNSTREAM_STRING( &constant_bin[ 1629049 ], 21, 1 );
    const_tuple_str_plain_self_str_plain_p_str_plain_dummytype_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_p_str_plain_dummytype_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_p_str_plain_dummytype_tuple, 1, const_str_plain_p ); Py_INCREF( const_str_plain_p );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_p_str_plain_dummytype_tuple, 2, const_str_plain_dummytype ); Py_INCREF( const_str_plain_dummytype );
    const_str_plain_p_primary_expression_3 = UNSTREAM_STRING( &constant_bin[ 1629863 ], 22, 1 );
    const_str_plain_p_expression_statement = UNSTREAM_STRING( &constant_bin[ 1626509 ], 22, 1 );
    const_str_plain_p_direct_xxx_declarator_1 = UNSTREAM_STRING( &constant_bin[ 1628268 ], 25, 1 );
    const_str_digest_57444e9b5b325fc1be7aff5d9f3b4c3e = UNSTREAM_STRING( &constant_bin[ 1643282 ], 157, 0 );
    const_str_digest_550126ff38d208154c0902478dbba1ce = UNSTREAM_STRING( &constant_bin[ 1643439 ], 28, 0 );
    const_str_plain_p_unary_operator = UNSTREAM_STRING( &constant_bin[ 1629653 ], 16, 1 );
    const_str_digest_2dcd182a11e70168432f85bd4916de3f = UNSTREAM_STRING( &constant_bin[ 1643467 ], 23, 0 );
    const_str_digest_b8f2e1eb7155c9c1f218f399b31285ac = UNSTREAM_STRING( &constant_bin[ 1643490 ], 25, 0 );
    const_str_plain_p_unary_expression_2 = UNSTREAM_STRING( &constant_bin[ 1629609 ], 20, 1 );
    const_str_digest_01f6ae58b95068740a6086923c913284 = UNSTREAM_STRING( &constant_bin[ 1643515 ], 28, 0 );
    const_str_plain_declarations = UNSTREAM_STRING( &constant_bin[ 29468 ], 12, 1 );
    const_str_digest_98a5d60d6dc1672f0b5dd8b8c452133c = UNSTREAM_STRING( &constant_bin[ 1643543 ], 38, 0 );
    const_str_plain_p_postfix_expression_3 = UNSTREAM_STRING( &constant_bin[ 1629719 ], 22, 1 );
    const_str_digest_d629f9f772cbeff45a83968be4ddd03c = UNSTREAM_STRING( &constant_bin[ 1643581 ], 184, 0 );
    const_str_digest_cf56e81ade3b51653cf6277798267531 = UNSTREAM_STRING( &constant_bin[ 1643765 ], 30, 0 );
    const_str_plain_p_constant_3 = UNSTREAM_STRING( &constant_bin[ 1630035 ], 12, 1 );
    const_str_digest_77451082531ef90d5a12539bac91b84d = UNSTREAM_STRING( &constant_bin[ 1624291 ], 21, 0 );
    const_str_digest_de90f98da1f88f6c37ec30f2101d5029 = UNSTREAM_STRING( &constant_bin[ 1643795 ], 104, 0 );
    const_str_digest_8c97fa18e75807bc919d97720956d8b5 = UNSTREAM_STRING( &constant_bin[ 1643899 ], 48, 0 );
    const_tuple_str_plain_self_str_plain_p_str_plain_coord_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_p_str_plain_coord_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_p_str_plain_coord_tuple, 1, const_str_plain_p ); Py_INCREF( const_str_plain_p );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_p_str_plain_coord_tuple, 2, const_str_plain_coord ); Py_INCREF( const_str_plain_coord );
    const_str_digest_3bf5fc201f146f4078233e173b4cb76d = UNSTREAM_STRING( &constant_bin[ 1643947 ], 32, 0 );
    const_tuple_str_plain_self_str_plain_p_str_plain_field_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_p_str_plain_field_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_p_str_plain_field_tuple, 1, const_str_plain_p ); Py_INCREF( const_str_plain_p );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_p_str_plain_field_tuple, 2, const_str_plain_field ); Py_INCREF( const_str_plain_field );
    const_tuple_481aebbbcf4c8fc7e212b2f24b7348d3_tuple = PyTuple_New( 12 );
    PyTuple_SET_ITEM( const_tuple_481aebbbcf4c8fc7e212b2f24b7348d3_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_481aebbbcf4c8fc7e212b2f24b7348d3_tuple, 1, const_str_plain_spec ); Py_INCREF( const_str_plain_spec );
    PyTuple_SET_ITEM( const_tuple_481aebbbcf4c8fc7e212b2f24b7348d3_tuple, 2, const_str_plain_decls ); Py_INCREF( const_str_plain_decls );
    PyTuple_SET_ITEM( const_tuple_481aebbbcf4c8fc7e212b2f24b7348d3_tuple, 3, const_str_plain_typedef_namespace ); Py_INCREF( const_str_plain_typedef_namespace );
    PyTuple_SET_ITEM( const_tuple_481aebbbcf4c8fc7e212b2f24b7348d3_tuple, 4, const_str_plain_is_typedef ); Py_INCREF( const_str_plain_is_typedef );
    PyTuple_SET_ITEM( const_tuple_481aebbbcf4c8fc7e212b2f24b7348d3_tuple, 5, const_str_plain_declarations ); Py_INCREF( const_str_plain_declarations );
    PyTuple_SET_ITEM( const_tuple_481aebbbcf4c8fc7e212b2f24b7348d3_tuple, 6, const_str_plain_coord ); Py_INCREF( const_str_plain_coord );
    PyTuple_SET_ITEM( const_tuple_481aebbbcf4c8fc7e212b2f24b7348d3_tuple, 7, const_str_plain_t ); Py_INCREF( const_str_plain_t );
    PyTuple_SET_ITEM( const_tuple_481aebbbcf4c8fc7e212b2f24b7348d3_tuple, 8, const_str_plain_decls_0_tail ); Py_INCREF( const_str_plain_decls_0_tail );
    PyTuple_SET_ITEM( const_tuple_481aebbbcf4c8fc7e212b2f24b7348d3_tuple, 9, const_str_plain_decl ); Py_INCREF( const_str_plain_decl );
    PyTuple_SET_ITEM( const_tuple_481aebbbcf4c8fc7e212b2f24b7348d3_tuple, 10, const_str_plain_declaration ); Py_INCREF( const_str_plain_declaration );
    const_str_plain_fixed_decl = UNSTREAM_STRING( &constant_bin[ 1643979 ], 10, 1 );
    PyTuple_SET_ITEM( const_tuple_481aebbbcf4c8fc7e212b2f24b7348d3_tuple, 11, const_str_plain_fixed_decl ); Py_INCREF( const_str_plain_fixed_decl );
    const_tuple_2353d864ddc8d50bf7ddd83b7128ace5_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_2353d864ddc8d50bf7ddd83b7128ace5_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_2353d864ddc8d50bf7ddd83b7128ace5_tuple, 1, const_str_plain_decl ); Py_INCREF( const_str_plain_decl );
    PyTuple_SET_ITEM( const_tuple_2353d864ddc8d50bf7ddd83b7128ace5_tuple, 2, const_str_plain_modifier ); Py_INCREF( const_str_plain_modifier );
    PyTuple_SET_ITEM( const_tuple_2353d864ddc8d50bf7ddd83b7128ace5_tuple, 3, const_str_plain_modifier_head ); Py_INCREF( const_str_plain_modifier_head );
    const_str_plain_modifier_tail = UNSTREAM_STRING( &constant_bin[ 1643989 ], 13, 1 );
    PyTuple_SET_ITEM( const_tuple_2353d864ddc8d50bf7ddd83b7128ace5_tuple, 4, const_str_plain_modifier_tail ); Py_INCREF( const_str_plain_modifier_tail );
    PyTuple_SET_ITEM( const_tuple_2353d864ddc8d50bf7ddd83b7128ace5_tuple, 5, const_str_plain_decl_tail ); Py_INCREF( const_str_plain_decl_tail );
    const_str_plain_p_type_name = UNSTREAM_STRING( &constant_bin[ 1628680 ], 11, 1 );
    const_str_digest_4bd430b578c2bcc6d80843b185fb40e9 = UNSTREAM_STRING( &constant_bin[ 1644002 ], 32, 0 );
    const_str_plain_p_direct_abstract_declarator_5 = UNSTREAM_STRING( &constant_bin[ 1628896 ], 30, 1 );
    const_str_digest_3cd56dd644178e94ac8c95975280e123 = UNSTREAM_STRING( &constant_bin[ 1644034 ], 294, 0 );
    const_str_plain_p_initializer_1 = UNSTREAM_STRING( &constant_bin[ 1625257 ], 15, 1 );
    const_str_digest_04111da496bbf8fa420ef5af2e2ec8c2 = UNSTREAM_STRING( &constant_bin[ 1644328 ], 27, 0 );
    const_str_plain_p_direct_xxx_declarator_3 = UNSTREAM_STRING( &constant_bin[ 1628322 ], 25, 1 );
    const_str_digest_5a2740760b061d16507e2fe95c154990 = UNSTREAM_STRING( &constant_bin[ 1644355 ], 62, 0 );
    const_str_digest_5ffee6bd7e73a82aa69f100a7aa6d022 = UNSTREAM_STRING( &constant_bin[ 1644417 ], 45, 0 );
    const_str_digest_9cdeb6682169eabb916c7a726bd5a898 = UNSTREAM_STRING( &constant_bin[ 1644462 ], 36, 0 );
    const_str_digest_0873233ec7645beb5174dc9e5b721ed2 = UNSTREAM_STRING( &constant_bin[ 1644498 ], 34, 0 );
    const_str_plain__pop_scope = UNSTREAM_STRING( &constant_bin[ 1626602 ], 10, 1 );
    const_str_digest_8d22bfcb2b0b548ef9d27d2e0cd24f7d = UNSTREAM_STRING( &constant_bin[ 1644532 ], 25, 0 );
    const_str_digest_51f8cd619ea97f30dc6589cdec4889ff = UNSTREAM_STRING( &constant_bin[ 1644557 ], 30, 0 );
    const_str_plain_p_translation_unit_2 = UNSTREAM_STRING( &constant_bin[ 1626986 ], 20, 1 );
    const_str_digest_1af3c0955bc51582727db494d6e3b036 = UNSTREAM_STRING( &constant_bin[ 1644587 ], 71, 0 );
    const_str_plain_p_selection_statement_2 = UNSTREAM_STRING( &constant_bin[ 1629143 ], 23, 1 );
    const_str_digest_16dd3aa8de123b64723e9d3f1db8a05b = UNSTREAM_STRING( &constant_bin[ 1644658 ], 19, 0 );
    const_tuple_a4361eef94546b476a1f9f18cdc0dc2d_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_a4361eef94546b476a1f9f18cdc0dc2d_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_a4361eef94546b476a1f9f18cdc0dc2d_tuple, 1, const_str_plain_decl ); Py_INCREF( const_str_plain_decl );
    PyTuple_SET_ITEM( const_tuple_a4361eef94546b476a1f9f18cdc0dc2d_tuple, 2, const_str_plain_typename ); Py_INCREF( const_str_plain_typename );
    PyTuple_SET_ITEM( const_tuple_a4361eef94546b476a1f9f18cdc0dc2d_tuple, 3, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    PyTuple_SET_ITEM( const_tuple_a4361eef94546b476a1f9f18cdc0dc2d_tuple, 4, const_str_plain_tn ); Py_INCREF( const_str_plain_tn );
    const_str_digest_5d8b7746d279b77778a2347a35fac441 = UNSTREAM_STRING( &constant_bin[ 1644677 ], 72, 0 );
    const_str_plain_p_external_declaration_1 = UNSTREAM_STRING( &constant_bin[ 1627008 ], 24, 1 );
    const_str_plain_p_iteration_statement_3 = UNSTREAM_STRING( &constant_bin[ 1629243 ], 23, 1 );
    const_str_digest_a61395ec1f8cbf83baab4a2c6ec5e642 = UNSTREAM_STRING( &constant_bin[ 1644749 ], 138, 0 );
    const_tuple_335994457eed7eca0e0ad48eb3a022bd_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_335994457eed7eca0e0ad48eb3a022bd_tuple, 0, const_str_digest_b9c4baf879ebd882d40843df3a4dead7 ); Py_INCREF( const_str_digest_b9c4baf879ebd882d40843df3a4dead7 );
    PyTuple_SET_ITEM( const_tuple_335994457eed7eca0e0ad48eb3a022bd_tuple, 1, const_str_plain_id ); Py_INCREF( const_str_plain_id );
    PyTuple_SET_ITEM( const_tuple_335994457eed7eca0e0ad48eb3a022bd_tuple, 2, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    const_str_digest_85edeba66ecd8010a3ffbe3e744f2716 = UNSTREAM_STRING( &constant_bin[ 1644887 ], 159, 0 );
    const_str_digest_3f8b6aa31a0455c8989a7d5ca708b30b = UNSTREAM_STRING( &constant_bin[ 1645046 ], 25, 0 );
    const_str_plain_p_primary_expression_4 = UNSTREAM_STRING( &constant_bin[ 1629887 ], 22, 1 );
    const_str_plain__type_modify_decl = UNSTREAM_STRING( &constant_bin[ 1626778 ], 17, 1 );
    const_str_plain_p_unified_string_literal = UNSTREAM_STRING( &constant_bin[ 1623422 ], 24, 1 );
    const_str_plain_p_specifier_qualifier_list_3 = UNSTREAM_STRING( &constant_bin[ 1627802 ], 28, 1 );
    const_str_digest_192b105d8a394fb0ecdd5413c89d71d5 = UNSTREAM_STRING( &constant_bin[ 1645071 ], 56, 0 );
    const_str_plain_p_binary_expression = UNSTREAM_STRING( &constant_bin[ 1623242 ], 19, 1 );
    const_str_plain_p_struct_declarator_list = UNSTREAM_STRING( &constant_bin[ 1628049 ], 24, 1 );
    const_tuple_str_plain_self_str_plain_msg_str_plain_line_str_plain_column_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_msg_str_plain_line_str_plain_column_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_msg_str_plain_line_str_plain_column_tuple, 1, const_str_plain_msg ); Py_INCREF( const_str_plain_msg );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_msg_str_plain_line_str_plain_column_tuple, 2, const_str_plain_line ); Py_INCREF( const_str_plain_line );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_msg_str_plain_line_str_plain_column_tuple, 3, const_str_plain_column ); Py_INCREF( const_str_plain_column );
    const_tuple_str_plain_fix_switch_cases_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_fix_switch_cases_tuple, 0, const_str_plain_fix_switch_cases ); Py_INCREF( const_str_plain_fix_switch_cases );
    const_str_plain_p_function_definition_2 = UNSTREAM_STRING( &constant_bin[ 1627175 ], 23, 1 );
    const_str_digest_034d2d261123545addc18f62de03953f = UNSTREAM_STRING( &constant_bin[ 1645127 ], 42, 0 );
    const_str_digest_643d36ef80210022e8e8988135837871 = UNSTREAM_STRING( &constant_bin[ 1645169 ], 126, 0 );
    const_str_plain_p_init_declarator = UNSTREAM_STRING( &constant_bin[ 1622974 ], 17, 1 );
    const_str_plain_p_struct_or_union_specifier_2 = UNSTREAM_STRING( &constant_bin[ 1627893 ], 29, 1 );
    const_str_digest_2060f4e391866f3f24cf672a745dbddb = UNSTREAM_STRING( &constant_bin[ 1645295 ], 30, 0 );
    const_str_plain_p_typedef_name = UNSTREAM_STRING( &constant_bin[ 1629411 ], 14, 1 );
    const_str_plain_p_external_declaration_2 = UNSTREAM_STRING( &constant_bin[ 1627034 ], 24, 1 );
    const_str_plain_p_constant_1 = UNSTREAM_STRING( &constant_bin[ 1624341 ], 12, 1 );
    const_str_plain__build_function_definition = UNSTREAM_STRING( &constant_bin[ 1626867 ], 26, 1 );
    const_str_digest_e01c24288bb4a048bc585c985f9198c6 = UNSTREAM_STRING( &constant_bin[ 1645325 ], 101, 0 );
    const_str_plain_p_postfix_expression_5 = UNSTREAM_STRING( &constant_bin[ 1629767 ], 22, 1 );
    const_str_digest_d3241665db4061517845a1ec21ea60f2 = UNSTREAM_STRING( &constant_bin[ 1645426 ], 478, 0 );
    const_str_digest_9d630abb686b7666019838011d097aa8 = UNSTREAM_STRING( &constant_bin[ 1645904 ], 26, 0 );
    const_str_digest_307040cd1aee1d586a3e132983f8218a = UNSTREAM_STRING( &constant_bin[ 1645930 ], 26, 0 );
    const_str_digest_e86f7034b1998ca0fd1f83fbc241f439 = UNSTREAM_STRING( &constant_bin[ 1645956 ], 29, 0 );
    const_str_plain_p_labeled_statement_3 = UNSTREAM_STRING( &constant_bin[ 1629095 ], 21, 1 );
    const_str_digest_ef5470f8407896db734faec9dc576857 = UNSTREAM_STRING( &constant_bin[ 1645985 ], 26, 0 );
    const_str_digest_2aaa91cf4331f7a6a55f392233d13676 = UNSTREAM_STRING( &constant_bin[ 1646011 ], 25, 0 );
    const_str_digest_125855f9025066f00bab7e56db3721bd = UNSTREAM_STRING( &constant_bin[ 1646036 ], 31, 0 );
    const_str_plain__add_typedef_name = UNSTREAM_STRING( &constant_bin[ 1626614 ], 17, 1 );
    const_str_digest_2b800f7f12830ca3c74b3d002525a8e9 = UNSTREAM_STRING( &constant_bin[ 1646067 ], 29, 0 );
    const_tuple_str_plain_yacc_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_yacc_tuple, 0, const_str_plain_yacc ); Py_INCREF( const_str_plain_yacc );
    const_str_plain_p_type_specifier_no_typeid = UNSTREAM_STRING( &constant_bin[ 1624250 ], 26, 1 );
    const_str_plain_p_enumerator = UNSTREAM_STRING( &constant_bin[ 1628181 ], 12, 1 );
    const_str_digest_d73a0191fa324324a6b46a5358fae01c = UNSTREAM_STRING( &constant_bin[ 1646096 ], 17, 0 );
    const_str_digest_e804d385509db9b1e7283e5542b56ffc = UNSTREAM_STRING( &constant_bin[ 1646113 ], 77, 0 );
    const_str_digest_58be8217c52b2b0082fd54c328e34edd = UNSTREAM_STRING( &constant_bin[ 1646190 ], 217, 0 );
    const_str_plain_p_block_item_list = UNSTREAM_STRING( &constant_bin[ 1626414 ], 17, 1 );
    const_str_digest_8843e107d9ff99510b99f46b7f76e849 = UNSTREAM_STRING( &constant_bin[ 1646407 ], 129, 0 );
    const_str_plain_tail_type = UNSTREAM_STRING( &constant_bin[ 1646536 ], 9, 1 );
    const_str_plain_p_struct_declarator_2 = UNSTREAM_STRING( &constant_bin[ 1628098 ], 21, 1 );
    const_str_digest_2f6102c4e0aa673d1243e931a1fc5195 = UNSTREAM_STRING( &constant_bin[ 134741 ], 8, 0 );
    const_str_digest_87931e228ae4f4b725f2af333756cf40 = UNSTREAM_STRING( &constant_bin[ 1646545 ], 28, 0 );
    const_str_digest_f5534e5846f0091e2dec27d444fffb08 = UNSTREAM_STRING( &constant_bin[ 1646573 ], 34, 0 );
    const_str_plain_p_direct_abstract_declarator_7 = UNSTREAM_STRING( &constant_bin[ 1628960 ], 30, 1 );
    const_str_digest_db4fbd32244e3e142dfff8ca5ad2d835 = UNSTREAM_STRING( &constant_bin[ 1646607 ], 63, 0 );
    const_str_digest_1beda91f8819e027ad8a23c29f618425 = UNSTREAM_STRING( &constant_bin[ 1646670 ], 77, 0 );
    const_str_plain_p_assignment_operator = UNSTREAM_STRING( &constant_bin[ 1629452 ], 21, 1 );
    const_str_digest_927a3c4fff6d9ce2ff3e8b0311b2a749 = UNSTREAM_STRING( &constant_bin[ 1646747 ], 31, 0 );
    const_str_digest_6fd75982f2b711afbab1aec5063c9027 = UNSTREAM_STRING( &constant_bin[ 1646778 ], 45, 0 );
    const_str_digest_178c771a71db12f844d7380f17f7ef4e = UNSTREAM_STRING( &constant_bin[ 1646823 ], 31, 0 );
    const_str_plain__add_declaration_specifier = UNSTREAM_STRING( &constant_bin[ 1626818 ], 26, 1 );
    const_str_digest_f6874ff50ae284a33e88afa362ab3553 = UNSTREAM_STRING( &constant_bin[ 1646854 ], 106, 0 );
    const_str_digest_6f813f05266ed46ec5181eab859080ad = UNSTREAM_STRING( &constant_bin[ 1646960 ], 55, 0 );
    const_str_digest_732bc606378f1eac79e58256e6deeaca = UNSTREAM_STRING( &constant_bin[ 1647015 ], 70, 0 );
    const_str_digest_a1cd6aed9971dbcb84ca89043785348d = UNSTREAM_STRING( &constant_bin[ 1647085 ], 21, 0 );
    const_str_digest_edd8de4708a55f1ec9dbcdda4529a4c2 = UNSTREAM_STRING( &constant_bin[ 1647106 ], 29, 0 );
    const_str_plain_p_iteration_statement_2 = UNSTREAM_STRING( &constant_bin[ 1629218 ], 23, 1 );
    const_str_digest_d1cc4f42cc56377b00d07035e4578575 = UNSTREAM_STRING( &constant_bin[ 1647135 ], 85, 0 );
    const_str_digest_1c433317a7150a35692bd30cb2425716 = UNSTREAM_STRING( &constant_bin[ 1647220 ], 35, 0 );
    const_str_digest_820fa7852213334e67e36dc54e523377 = UNSTREAM_STRING( &constant_bin[ 1647255 ], 38, 0 );
    const_str_plain_p_cast_expression_1 = UNSTREAM_STRING( &constant_bin[ 1629545 ], 19, 1 );
    const_str_digest_5f379363cdeef01b09cf7f64504042da = UNSTREAM_STRING( &constant_bin[ 1647293 ], 105, 0 );
    const_list_dict_2c030ba937b9e185526e262591ee7db7_list = PyList_New( 1 );
    PyList_SET_ITEM( const_list_dict_2c030ba937b9e185526e262591ee7db7_list, 0, const_dict_2c030ba937b9e185526e262591ee7db7 ); Py_INCREF( const_dict_2c030ba937b9e185526e262591ee7db7 );
    const_str_plain_p_declaration_specifiers_2 = UNSTREAM_STRING( &constant_bin[ 1627397 ], 26, 1 );
    const_str_digest_c187e02bef7c074dcfaa98ea325683fc = UNSTREAM_STRING( &constant_bin[ 1647398 ], 30, 0 );
    const_str_digest_0594790bab68d7c87f42d25d5c5e4a6b = UNSTREAM_STRING( &constant_bin[ 1647428 ], 65, 0 );
    const_str_digest_abf6f1796659b1065c7123daae53e198 = UNSTREAM_STRING( &constant_bin[ 1626406 ], 20, 0 );
    const_str_digest_ea1e7517ff14f16261f797c375173978 = UNSTREAM_STRING( &constant_bin[ 1647493 ], 32, 0 );
    const_str_digest_d981b77bcfe72f3dc742174b23807c08 = UNSTREAM_STRING( &constant_bin[ 1647525 ], 28, 0 );
    const_str_digest_6795256e62ee72e47844fa0e0f009b9a = UNSTREAM_STRING( &constant_bin[ 1647553 ], 59, 0 );
    const_str_digest_d66e9c5c2bcd94289ac5f093c4055dbc = UNSTREAM_STRING( &constant_bin[ 1647612 ], 76, 0 );
    const_str_digest_d88c34830a8f899e0db8bc3194789629 = UNSTREAM_STRING( &constant_bin[ 1647688 ], 96, 0 );
    const_str_plain_p_struct_declarator_1 = UNSTREAM_STRING( &constant_bin[ 1628075 ], 21, 1 );
    const_str_digest_6e4b44069d4b8ebacde4e38969a5851a = UNSTREAM_STRING( &constant_bin[ 1647784 ], 95, 0 );
    const_str_plain__select_struct_union_class = UNSTREAM_STRING( &constant_bin[ 1626895 ], 26, 1 );
    const_str_plain_p_xxx_declarator_1 = UNSTREAM_STRING( &constant_bin[ 1628228 ], 18, 1 );
    const_str_digest_df007a6e044b925abf12d22b7ef3ea75 = UNSTREAM_STRING( &constant_bin[ 1647879 ], 144, 0 );
    const_str_digest_3527e2c43140c9c3fd5fb7fcbbe9a457 = UNSTREAM_STRING( &constant_bin[ 1645046 ], 20, 0 );
    const_str_digest_a8184ddf33f783ca2f5ff9b3b636381f = UNSTREAM_STRING( &constant_bin[ 1648023 ], 30, 0 );
    const_str_plain_p_argument_expression_list = UNSTREAM_STRING( &constant_bin[ 1629965 ], 26, 1 );
    const_str_digest_ea48cf7104d76d4530fca21257b2ac6b = UNSTREAM_STRING( &constant_bin[ 1648053 ], 199, 0 );
    const_str_digest_e7a64a89e5927564e3642a46ab58f1c4 = UNSTREAM_STRING( &constant_bin[ 1648252 ], 15, 0 );
    const_str_digest_6a4952e047321440db18a38bf73040e5 = UNSTREAM_STRING( &constant_bin[ 1648267 ], 115, 0 );
    const_str_digest_df4123329a07844b816ca766a10e3b4d = UNSTREAM_STRING( &constant_bin[ 1648382 ], 30, 0 );
    const_str_digest_ec3069c11ff9407ed42cf10e18b85079 = UNSTREAM_STRING( &constant_bin[ 1648412 ], 34, 0 );
    const_str_plain_p_init_declarator_list = UNSTREAM_STRING( &constant_bin[ 1622974 ], 22, 1 );
    const_str_plain_p_xxx_declarator_2 = UNSTREAM_STRING( &constant_bin[ 1628248 ], 18, 1 );
    const_str_digest_e61ddf064a1db398749ac1d36281c3cb = UNSTREAM_STRING( &constant_bin[ 1648446 ], 71, 0 );
    const_str_digest_54641dd2781e3ae796914e2648dd7e3c = UNSTREAM_STRING( &constant_bin[ 1648517 ], 38, 0 );
    const_str_plain_p_statement = UNSTREAM_STRING( &constant_bin[ 1623001 ], 11, 1 );
    const_tuple_22e763767c9a66d68e45377ac7499ee8_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_22e763767c9a66d68e45377ac7499ee8_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_22e763767c9a66d68e45377ac7499ee8_tuple, 1, const_str_plain_p ); Py_INCREF( const_str_plain_p );
    PyTuple_SET_ITEM( const_tuple_22e763767c9a66d68e45377ac7499ee8_tuple, 2, const_str_plain_coord ); Py_INCREF( const_str_plain_coord );
    PyTuple_SET_ITEM( const_tuple_22e763767c9a66d68e45377ac7499ee8_tuple, 3, const_str_plain_nested_type ); Py_INCREF( const_str_plain_nested_type );
    PyTuple_SET_ITEM( const_tuple_22e763767c9a66d68e45377ac7499ee8_tuple, 4, const_str_plain_tail_type ); Py_INCREF( const_str_plain_tail_type );
    const_tuple_0f1b9a27033e2962bbcd8849947d6d02_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_0f1b9a27033e2962bbcd8849947d6d02_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_0f1b9a27033e2962bbcd8849947d6d02_tuple, 1, const_str_plain_p ); Py_INCREF( const_str_plain_p );
    PyTuple_SET_ITEM( const_tuple_0f1b9a27033e2962bbcd8849947d6d02_tuple, 2, const_str_plain_spec ); Py_INCREF( const_str_plain_spec );
    PyTuple_SET_ITEM( const_tuple_0f1b9a27033e2962bbcd8849947d6d02_tuple, 3, const_str_plain_decl ); Py_INCREF( const_str_plain_decl );
    PyTuple_SET_ITEM( const_tuple_0f1b9a27033e2962bbcd8849947d6d02_tuple, 4, const_str_plain_typename ); Py_INCREF( const_str_plain_typename );
    const_str_plain_p_abstract_declarator_1 = UNSTREAM_STRING( &constant_bin[ 1628693 ], 23, 1 );
    const_str_digest_67f6f0661dcf43443ba5aba2601841f6 = UNSTREAM_STRING( &constant_bin[ 1648555 ], 34, 0 );
    const_str_digest_7fb11837565d2e38ffa2544b3c72440e = UNSTREAM_STRING( &constant_bin[ 1648589 ], 2072, 0 );
    const_str_digest_67c7a592d5ccaa55aa64fc82209437a9 = UNSTREAM_STRING( &constant_bin[ 1650661 ], 31, 0 );
    const_str_plain_p_block_item = UNSTREAM_STRING( &constant_bin[ 1626414 ], 12, 1 );
    const_str_digest_1ba6cb72fde357e6df707af7c40bc09e = UNSTREAM_STRING( &constant_bin[ 1650692 ], 28, 0 );
    const_str_digest_534b5bcecbd2c4f39a6a03b6e5d0a4d9 = UNSTREAM_STRING( &constant_bin[ 1650720 ], 82, 0 );
    const_str_digest_90baefe9843fd00d2fcc6c4fd66a583a = UNSTREAM_STRING( &constant_bin[ 1650802 ], 108, 0 );
    const_str_digest_e83b94dd40a22f9b101921f16536afd9 = UNSTREAM_STRING( &constant_bin[ 1650910 ], 32, 0 );
    const_tuple_str_plain_self_str_plain_p_str_plain_spec_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_p_str_plain_spec_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_p_str_plain_spec_tuple, 1, const_str_plain_p ); Py_INCREF( const_str_plain_p );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_p_str_plain_spec_tuple, 2, const_str_plain_spec ); Py_INCREF( const_str_plain_spec );
    const_str_plain__lex_on_lbrace_func = UNSTREAM_STRING( &constant_bin[ 1626686 ], 19, 1 );
    const_str_digest_4adaae36d1bcfc08aaddc6ab3ca280a1 = UNSTREAM_STRING( &constant_bin[ 1650942 ], 30, 0 );
    const_str_plain_p_jump_statement_3 = UNSTREAM_STRING( &constant_bin[ 1629333 ], 18, 1 );
    const_str_digest_872052bc891e4d940163d196751ac419 = UNSTREAM_STRING( &constant_bin[ 1650972 ], 21, 0 );
    const_tuple_str_plain_self_str_plain_p_str_plain_enumerator_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_p_str_plain_enumerator_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_p_str_plain_enumerator_tuple, 1, const_str_plain_p ); Py_INCREF( const_str_plain_p );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_p_str_plain_enumerator_tuple, 2, const_str_plain_enumerator ); Py_INCREF( const_str_plain_enumerator );
    const_str_digest_59cff374166603b529f71057ce36eaed = UNSTREAM_STRING( &constant_bin[ 1650993 ], 28, 0 );
    const_str_plain_p_parameter_declaration_1 = UNSTREAM_STRING( &constant_bin[ 1628505 ], 25, 1 );
    const_str_plain_p_cast_expression_2 = UNSTREAM_STRING( &constant_bin[ 1629566 ], 19, 1 );
    const_str_plain_p_postfix_expression_1 = UNSTREAM_STRING( &constant_bin[ 1629671 ], 22, 1 );
    const_str_plain_p_direct_abstract_declarator_3 = UNSTREAM_STRING( &constant_bin[ 1628832 ], 30, 1 );
    const_str_digest_7ba0fc454e8e35159e5df23ec4292d59 = UNSTREAM_STRING( &constant_bin[ 1651021 ], 71, 0 );
    const_str_digest_ad6ead784d30f848fe6914fe2453eb23 = UNSTREAM_STRING( &constant_bin[ 1651092 ], 21, 0 );
    const_str_plain_p_type_specifier = UNSTREAM_STRING( &constant_bin[ 1624250 ], 16, 1 );
    const_str_digest_9ea1b38e0d2aa74c23f145dd3e278bab = UNSTREAM_STRING( &constant_bin[ 1651113 ], 24, 0 );
    const_str_digest_18559e92d38108a30eaa5a5cecac76ce = UNSTREAM_STRING( &constant_bin[ 1651137 ], 32, 0 );
    const_str_plain_p_expression = UNSTREAM_STRING( &constant_bin[ 1626509 ], 12, 1 );
    const_str_plain__scope_stack = UNSTREAM_STRING( &constant_bin[ 1651169 ], 12, 1 );
    const_str_digest_84f8f95f98f69c9f598b1943ad4af5e9 = UNSTREAM_STRING( &constant_bin[ 1651181 ], 36, 0 );

    constants_created = true;
}

#ifndef __NUITKA_NO_ASSERT__
void checkModuleConstants_pycparser$c_parser( void )
{
    // The module may not have been used at all.
    if (constants_created == false) return;


}
#endif

// The module code objects.
static PyCodeObject *codeobj_a122c51f99f20e77765ca39c1f6ed2f1;
static PyCodeObject *codeobj_c4d7d483d924a5fff5f3a76668a73267;
static PyCodeObject *codeobj_4bc9e4c6643ef221ad4182ae532b0a87;
static PyCodeObject *codeobj_81959b19e2f92da45fb0e4a88b971619;
static PyCodeObject *codeobj_c59e20d15f8eac5266dae2329206bd8e;
static PyCodeObject *codeobj_fd2885a07b4bce7ac41dae2e3701ce8e;
static PyCodeObject *codeobj_288dc4e82434f2e66f5d247261ad8ef7;
static PyCodeObject *codeobj_5d301616ab586222ed78633c90ffcd8d;
static PyCodeObject *codeobj_bef5532727a45f5b235d041b44d2998c;
static PyCodeObject *codeobj_47d1681d5614a83e5df14808f4fa8d7b;
static PyCodeObject *codeobj_7d6be3b889381e9206fe16ac40003ac8;
static PyCodeObject *codeobj_b46c585229a82084cf4cd60f525bdce1;
static PyCodeObject *codeobj_f288e41b499202bc1365c10c60a14f5b;
static PyCodeObject *codeobj_f1cc1ced8689c1a73b6a22276b413658;
static PyCodeObject *codeobj_a0f37948e5f35b331da261a1dc94d087;
static PyCodeObject *codeobj_f7642558c29696ca9e24e1bcaca82789;
static PyCodeObject *codeobj_3c130929c04ff996d230a179e832aca1;
static PyCodeObject *codeobj_6e8be8813e958c494a98780a36bdc1e2;
static PyCodeObject *codeobj_9369739e178dac98413046a0f356581a;
static PyCodeObject *codeobj_09001c135c5d1963f9dd6f01da960cd0;
static PyCodeObject *codeobj_e70c38497d0ec9a52c2ff1f534573b49;
static PyCodeObject *codeobj_09fa059b553ec32ab362c24c2ae782a0;
static PyCodeObject *codeobj_ac70248d42fae48a157ba1db8b5e4a7b;
static PyCodeObject *codeobj_51b554cea9d0e7f1e3adf8f99cc405e4;
static PyCodeObject *codeobj_dbbbd791f6d9a09e74dbfc14504f2e29;
static PyCodeObject *codeobj_ed8adc41ee899609c66034535486075c;
static PyCodeObject *codeobj_19efd769ae32e39375b5f91ec8fbb547;
static PyCodeObject *codeobj_a7092856904714539f2d6ca7e3306ef6;
static PyCodeObject *codeobj_3beaa24096ba678266b7ce5a127daf1e;
static PyCodeObject *codeobj_d418cf27184b2bf16ca054052e01d977;
static PyCodeObject *codeobj_f876f59d4cd77fb6f7eab21d385ae078;
static PyCodeObject *codeobj_26db2c85ab3d6d0266f0a822b40edf53;
static PyCodeObject *codeobj_a413dcd715e0f7313fbd11c8e102c39a;
static PyCodeObject *codeobj_6c76c6b906bebc731427f45496dd9bfe;
static PyCodeObject *codeobj_44fecbd2cd73bf009220006e0cf1357f;
static PyCodeObject *codeobj_a80f7b2846d23973abaf0cf769aa2159;
static PyCodeObject *codeobj_db82277e54d8ea03459ccc4903704992;
static PyCodeObject *codeobj_dac04a09bf559be9390265aa086c5b1b;
static PyCodeObject *codeobj_4280c780fe5eca45d1548e381c321c2e;
static PyCodeObject *codeobj_22889f6f9c19d187b7c4c8d88b7e4fa6;
static PyCodeObject *codeobj_d1032335e18e686c5a3e07c2a5efdd4f;
static PyCodeObject *codeobj_9ebb7e26c81a6e62f517f5a1634c7145;
static PyCodeObject *codeobj_daf91fd058413412def7e9cba646ba87;
static PyCodeObject *codeobj_a550651500717a2145499cdc22099572;
static PyCodeObject *codeobj_dc55435f67e174458f33671217fef464;
static PyCodeObject *codeobj_955db861391b760644188637061a0be7;
static PyCodeObject *codeobj_ba284b447b2324f31e4033bc80c04da8;
static PyCodeObject *codeobj_1148723a196d3f7376492b433bec02f1;
static PyCodeObject *codeobj_ad0cabf99ebe872bef794caff00c20ff;
static PyCodeObject *codeobj_81f6b03a9095979e8e4c2741dd044885;
static PyCodeObject *codeobj_36fc1a9c2412033462d3fd044b8c43d8;
static PyCodeObject *codeobj_a2b727d56381a053396d12a662497a0c;
static PyCodeObject *codeobj_3ec228d3af3ab7e0d8598e8ae146fa09;
static PyCodeObject *codeobj_337331efd9e8b98ec904248b5729d4b7;
static PyCodeObject *codeobj_85094ef0f04670a999427ff66a78ee6f;
static PyCodeObject *codeobj_c0feafe8bd77b3b88cd6575e93ee8a8a;
static PyCodeObject *codeobj_52eb0d57f6175eba75633633bbe54ef2;
static PyCodeObject *codeobj_5257b1cf3d2353a8c350ec764d19c8d2;
static PyCodeObject *codeobj_f10314a14c8ac1925cc08a640435747f;
static PyCodeObject *codeobj_5290c3915469426265e7f52d66a998a4;
static PyCodeObject *codeobj_1689f9118a658d2fccef32175084540f;
static PyCodeObject *codeobj_0ed528daae5194b75aa45f30a70a7d2a;
static PyCodeObject *codeobj_d0ddb5710ee04c11b9c8b5e7929925bb;
static PyCodeObject *codeobj_40828e27474f8175923acb31cbff0852;
static PyCodeObject *codeobj_10aeb59019f195c42eae9c75e055c5a0;
static PyCodeObject *codeobj_b6926e29a605bdf62681337c32c04bf6;
static PyCodeObject *codeobj_27d82a838ba49194322163c62da6de8b;
static PyCodeObject *codeobj_b329363a2e1d615669c61b6bf24bd116;
static PyCodeObject *codeobj_ed4050f5ceb4859fce3f8015827a9ddd;
static PyCodeObject *codeobj_e4b4c3a4569c493600c917b20c1f31dd;
static PyCodeObject *codeobj_57177e1c43acfad59002f4c79c8dd68b;
static PyCodeObject *codeobj_56043ddf00ef986baf64b5ab4532f55e;
static PyCodeObject *codeobj_795eb7c6f2350e65bc50540431566e11;
static PyCodeObject *codeobj_bdb3c9c7f520adbb0bb977e5f55bd902;
static PyCodeObject *codeobj_fc36fad08403ba995c218b757a509878;
static PyCodeObject *codeobj_f82d0149f91c7c324123f2efb235c3aa;
static PyCodeObject *codeobj_b7acc24f1086e7eb9e18ae8b458bb757;
static PyCodeObject *codeobj_890693400d4202a153b8e1e690365ade;
static PyCodeObject *codeobj_effdb1dfb0ba4b664777a5d6f9df0b8d;
static PyCodeObject *codeobj_24adae7ae88f8e4355b4ba1428992bc6;
static PyCodeObject *codeobj_6879c1e9865b0e5e45bb62efdd824393;
static PyCodeObject *codeobj_208c1d0a5c48fb2f1b2e5a0a8e19fff7;
static PyCodeObject *codeobj_229da5f0e9fa3c82a38b125a410979e1;
static PyCodeObject *codeobj_a679bfacf9dd7eea1a788fa45bb0ce95;
static PyCodeObject *codeobj_48b53f7793e20849ff5aff6a6726fe71;
static PyCodeObject *codeobj_5cfdbbfac2e5693583b5c3bce0a5b55f;
static PyCodeObject *codeobj_aa0f5872a2f8e0828a2d10c20a4ef844;
static PyCodeObject *codeobj_46874747c73603425f19b82b48f68a48;
static PyCodeObject *codeobj_5ef1b3a186f7c83e4c84a68674855a62;
static PyCodeObject *codeobj_867142bdf96c9102a846ef71dc64dcbc;
static PyCodeObject *codeobj_97a3152e541b6ec6c995297d53d9b782;
static PyCodeObject *codeobj_c4664c50857c8a99411c8f15a81eca07;
static PyCodeObject *codeobj_3286b72abfbf9883a8da41cbb843f21f;
static PyCodeObject *codeobj_2981cd55a1d00047fb71fd4a3e5caa1e;
static PyCodeObject *codeobj_7bdedbef7a00776795107daa1bc963d5;
static PyCodeObject *codeobj_802c5dcca4e0dc3da51d1647e1b1c44b;
static PyCodeObject *codeobj_af8b24a7fb187d46cbff465e53ea8988;
static PyCodeObject *codeobj_08768331755421b59b3b286c6aa14448;
static PyCodeObject *codeobj_568ad40762c86bdbb2f4cf4156d8c64e;
static PyCodeObject *codeobj_d4b13e566c43bcd4afcc2455b31001f3;
static PyCodeObject *codeobj_aa10437b2c7b7415d366a3591971e55e;
static PyCodeObject *codeobj_9a7884aa4204ef4dbd3aad792656ee71;
static PyCodeObject *codeobj_42a6c9510c0bdcc207922abe14498274;
static PyCodeObject *codeobj_1310901836337014bc882ee72d64976b;
static PyCodeObject *codeobj_848b6d36ac8046f93895c4f1c5e3f20a;
static PyCodeObject *codeobj_4b2ca4185e772da831d9fd26e5c441de;
static PyCodeObject *codeobj_16109f170a5b0bf37839ac5e2c0e961f;
static PyCodeObject *codeobj_1802192b2a03b205fa58a441ed52b1bb;
static PyCodeObject *codeobj_ec7e7fa34698fe0d0aeabdfc87e00cd0;
static PyCodeObject *codeobj_33c782c9369ccb6646fd10ca5266b9cf;
static PyCodeObject *codeobj_11b37f28b0696e358af2a7dcdff91c68;
static PyCodeObject *codeobj_878a1c18fbce981d7e9ea80408cd4b98;
static PyCodeObject *codeobj_1fb46e7eab0421a5014bc4bf4a5b4563;
static PyCodeObject *codeobj_9d63efb08280aa9f3e1ade085e5671ce;
static PyCodeObject *codeobj_12651dd7f01f4a368063187baf6a9878;
static PyCodeObject *codeobj_21b21c0e9aa6489741377e3025474a8d;
static PyCodeObject *codeobj_2f22fe77305a28e8416b02900417c1b5;
static PyCodeObject *codeobj_2ffe8752d69b5192793518d9b2bd5183;
static PyCodeObject *codeobj_e6bd3ffd6382f6051682737b197f564d;
static PyCodeObject *codeobj_593cfeb60507e7593ca2134a702e323c;
static PyCodeObject *codeobj_7aacc024cef287d47094c2e9272ac6a3;
static PyCodeObject *codeobj_25ef2753338c990d7a75642de258fee4;
static PyCodeObject *codeobj_79eb7006626f9d871293d99e614159a9;
static PyCodeObject *codeobj_6fe279688e2cd7bc46d2d64929e946b5;
static PyCodeObject *codeobj_3ebb659f536809e4475d45060ad98408;
static PyCodeObject *codeobj_3827ee0116b2c686ac4a629dc5c8d41b;
static PyCodeObject *codeobj_02c27f43617c9de50be853bd11a02557;
static PyCodeObject *codeobj_df0dd4c7f3200da012ac0fd7c5300dee;
static PyCodeObject *codeobj_418db9cacfcd09e3118e18f6d0a2849f;
static PyCodeObject *codeobj_6ecdf682fba70e48f758afad9ba925c9;
static PyCodeObject *codeobj_1da590064ef77831c71eb320c8e29b4f;
static PyCodeObject *codeobj_3c330c3797f362655fc43b272c3eb042;
static PyCodeObject *codeobj_7eb54679c49b7375444fb88c8b84b1c2;
static PyCodeObject *codeobj_80b01d1e78e2951d30442bff34e5a4cb;
static PyCodeObject *codeobj_7f70ce3e02d3f2f4e1e4321d7d064669;
static PyCodeObject *codeobj_753414c1c431ae4c5db9c6601df038b5;
static PyCodeObject *codeobj_d92a866aca5ee4bf46d4ac9e314cf35b;
static PyCodeObject *codeobj_f6eb8c7ab6d5260fc9fa696b3c5597c9;
static PyCodeObject *codeobj_3ce513362ae9f8a7a7ed0c2ec7b2acad;
static PyCodeObject *codeobj_b0f344fd6a0c4d2abd6db14c8fef82ab;
static PyCodeObject *codeobj_eaf2fded8c31a9dea63e42cdeb65689e;
static PyCodeObject *codeobj_0ea1d0686563ee73ce9af74116275c5f;
static PyCodeObject *codeobj_129c1473716b75fca59a3bb1a8c29dc1;
static PyCodeObject *codeobj_0fd5d9823eacda464fa5a1ee5cd90b6e;
static PyCodeObject *codeobj_a186227811a44983d6a7e67189d06650;
static PyCodeObject *codeobj_aee718468f446ee6274702a5598cc964;
static PyCodeObject *codeobj_25d6673a41ce2601022f3bec8cf9b9f2;
static PyCodeObject *codeobj_febe702af8a1cd2b2bf16ba9e9fd3f58;
static PyCodeObject *codeobj_39de1eccef65c50e3c79de1d987275c6;
static PyCodeObject *codeobj_5d32d7d5b0f216e650e8a6ecb453fe6c;
static PyCodeObject *codeobj_f569cd0da9b9127eb406763c7c607567;
static PyCodeObject *codeobj_463376239af8505f839bcaa0249bfc10;
static PyCodeObject *codeobj_1f4b7bc9508ec89587d97c1950610acf;
static PyCodeObject *codeobj_2805b5236c257d9892595ef331fe32b7;
static PyCodeObject *codeobj_5cc8d94a5e1fe1d058d2dc0e268f0c82;
static PyCodeObject *codeobj_8b7d7117faec7d0aef260da43d40c207;
static PyCodeObject *codeobj_b4c79c4a2dd3535b415a0995f8471cae;
static PyCodeObject *codeobj_58509cdc3d7993928017f618fed741c3;
static PyCodeObject *codeobj_a488ed12a4b6217597f4f94e372f960d;
static PyCodeObject *codeobj_8b41c2cd19aa34d145a09e06a36a06d1;
static PyCodeObject *codeobj_98e40246e2cc3f8becdbf3e10cd918f2;
static PyCodeObject *codeobj_6a3ff42cc3d74ce0db1744142bbec85f;

static void createModuleCodeObjects(void)
{
    module_filename_obj = MAKE_RELATIVE_PATH( const_str_digest_a1cd6aed9971dbcb84ca89043785348d );
    codeobj_a122c51f99f20e77765ca39c1f6ed2f1 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_listcontraction, 347, const_tuple_335994457eed7eca0e0ad48eb3a022bd_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c4d7d483d924a5fff5f3a76668a73267 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_listcontraction, 1068, const_tuple_str_digest_b9c4baf879ebd882d40843df3a4dead7_str_plain_item_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_4bc9e4c6643ef221ad4182ae532b0a87 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_listcontraction, 1070, const_tuple_f42d7b470c00f28d1af65a7593268b5b_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_81959b19e2f92da45fb0e4a88b971619 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_CParser, 20, const_tuple_814fd99db7b828bfc5d54aae3ba8f30f_tuple, 0, 0, CO_NOFREE );
    codeobj_c59e20d15f8eac5266dae2329206bd8e = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 21, const_tuple_05106f1143fd548d61395e9607a1282d_tuple, 8, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_fd2885a07b4bce7ac41dae2e3701ce8e = MAKE_CODEOBJ( module_filename_obj, const_str_plain__add_declaration_specifier, 351, const_tuple_dd6b1b91cc0261088d31198011b3777b_tuple, 5, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_288dc4e82434f2e66f5d247261ad8ef7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__add_identifier, 172, const_tuple_str_plain_self_str_plain_name_str_plain_coord_tuple, 3, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5d301616ab586222ed78633c90ffcd8d = MAKE_CODEOBJ( module_filename_obj, const_str_plain__add_typedef_name, 163, const_tuple_str_plain_self_str_plain_name_str_plain_coord_tuple, 3, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_bef5532727a45f5b235d041b44d2998c = MAKE_CODEOBJ( module_filename_obj, const_str_plain__build_declarations, 375, const_tuple_481aebbbcf4c8fc7e212b2f24b7348d3_tuple, 4, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_47d1681d5614a83e5df14808f4fa8d7b = MAKE_CODEOBJ( module_filename_obj, const_str_plain__build_function_definition, 464, const_tuple_dbc31fde9862f09a6a68bd61c7b8a34c_tuple, 5, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7d6be3b889381e9206fe16ac40003ac8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__fix_decl_name_type, 306, const_tuple_a4361eef94546b476a1f9f18cdc0dc2d_tuple, 3, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b46c585229a82084cf4cd60f525bdce1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__get_yacc_lookahead_token, 210, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f288e41b499202bc1365c10c60a14f5b = MAKE_CODEOBJ( module_filename_obj, const_str_plain__is_type_in_scope, 182, const_tuple_92a4268d571593236672ed5e2ec111d7_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f1cc1ced8689c1a73b6a22276b413658 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__lex_error_func, 192, const_tuple_str_plain_self_str_plain_msg_str_plain_line_str_plain_column_tuple, 4, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a0f37948e5f35b331da261a1dc94d087 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__lex_on_lbrace_func, 195, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f7642558c29696ca9e24e1bcaca82789 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__lex_on_rbrace_func, 198, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3c130929c04ff996d230a179e832aca1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__lex_type_lookup_func, 201, const_tuple_str_plain_self_str_plain_name_str_plain_is_type_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6e8be8813e958c494a98780a36bdc1e2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__pop_scope, 159, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9369739e178dac98413046a0f356581a = MAKE_CODEOBJ( module_filename_obj, const_str_plain__push_scope, 156, const_tuple_str_plain_self_tuple, 1, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_09001c135c5d1963f9dd6f01da960cd0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__select_struct_union_class, 480, const_tuple_str_plain_self_str_plain_token_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e70c38497d0ec9a52c2ff1f534573b49 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__type_modify_decl, 251, const_tuple_2353d864ddc8d50bf7ddd83b7128ace5_tuple, 3, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_09fa059b553ec32ab362c24c2ae782a0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_c_parser, 1, const_tuple_empty, 0, 0, CO_NOFREE );
    codeobj_ac70248d42fae48a157ba1db8b5e4a7b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_abstract_declarator_1, 1298, const_tuple_str_plain_self_str_plain_p_str_plain_dummytype_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_51b554cea9d0e7f1e3adf8f99cc405e4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_abstract_declarator_2, 1306, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_dbbbd791f6d9a09e74dbfc14504f2e29 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_abstract_declarator_3, 1311, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ed8adc41ee899609c66034535486075c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_argument_expression_list, 1673, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_19efd769ae32e39375b5f91ec8fbb547 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_assignment_expression, 1491, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a7092856904714539f2d6ca7e3306ef6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_assignment_operator, 1505, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3beaa24096ba678266b7ce5a127daf1e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_binary_expression, 1533, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d418cf27184b2bf16ca054052e01d977 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_block_item, 1386, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f876f59d4cd77fb6f7eab21d385ae078 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_block_item_list, 1394, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_26db2c85ab3d6d0266f0a822b40edf53 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_brace_close, 1743, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a413dcd715e0f7313fbd11c8e102c39a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_brace_open, 1737, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6c76c6b906bebc731427f45496dd9bfe = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_cast_expression_1, 1559, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_44fecbd2cd73bf009220006e0cf1357f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_cast_expression_2, 1563, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a80f7b2846d23973abaf0cf769aa2159 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_compound_statement_1, 1401, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_db82277e54d8ea03459ccc4903704992 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_conditional_expression, 1524, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_dac04a09bf559be9390265aa086c5b1b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_constant_1, 1687, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_4280c780fe5eca45d1548e381c321c2e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_constant_2, 1696, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_22889f6f9c19d187b7c4c8d88b7e4fa6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_constant_3, 1703, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d1032335e18e686c5a3e07c2a5efdd4f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_constant_expression, 1520, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9ebb7e26c81a6e62f517f5a1634c7145 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_decl_body, 628, const_tuple_08c0da61fe57987f4fb46301e9d60b83_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_daf91fd058413412def7e9cba646ba87 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_declaration, 688, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a550651500717a2145499cdc22099572 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_declaration_list, 697, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_dc55435f67e174458f33671217fef464 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_declaration_specifiers_1, 724, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_955db861391b760644188637061a0be7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_declaration_specifiers_2, 729, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ba284b447b2324f31e4033bc80c04da8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_declaration_specifiers_3, 734, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1148723a196d3f7376492b433bec02f1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_declaration_specifiers_4, 739, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ad0cabf99ebe872bef794caff00c20ff = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_declaration_specifiers_5, 744, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_81f6b03a9095979e8e4c2741dd044885 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_declaration_specifiers_6, 749, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_36fc1a9c2412033462d3fd044b8c43d8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_declaration_specifiers_no_type_1, 708, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a2b727d56381a053396d12a662497a0c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_declaration_specifiers_no_type_2, 713, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3ec228d3af3ab7e0d8598e8ae146fa09 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_declaration_specifiers_no_type_3, 718, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_337331efd9e8b98ec904248b5729d4b7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_declarator, 1011, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_85094ef0f04670a999427ff66a78ee6f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_designation, 1267, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c0feafe8bd77b3b88cd6575e93ee8a8a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_designator, 1281, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_52eb0d57f6175eba75633633bbe54ef2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_designator_list, 1275, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5257b1cf3d2353a8c350ec764d19c8d2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_direct_abstract_declarator_1, 1321, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f10314a14c8ac1925cc08a640435747f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_direct_abstract_declarator_2, 1325, const_tuple_str_plain_self_str_plain_p_str_plain_arr_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5290c3915469426265e7f52d66a998a4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_direct_abstract_declarator_3, 1336, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1689f9118a658d2fccef32175084540f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_direct_abstract_declarator_4, 1345, const_tuple_str_plain_self_str_plain_p_str_plain_arr_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0ed528daae5194b75aa45f30a70a7d2a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_direct_abstract_declarator_5, 1356, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d0ddb5710ee04c11b9c8b5e7929925bb = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_direct_abstract_declarator_6, 1365, const_tuple_str_plain_self_str_plain_p_str_plain_func_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_40828e27474f8175923acb31cbff0852 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_direct_abstract_declarator_7, 1375, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_10aeb59019f195c42eae9c75e055c5a0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_direct_xxx_declarator_1, 1029, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b6926e29a605bdf62681337c32c04bf6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_direct_xxx_declarator_2, 1039, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_27d82a838ba49194322163c62da6de8b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_direct_xxx_declarator_3, 1045, const_tuple_str_plain_self_str_plain_p_str_plain_quals_str_plain_arr_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b329363a2e1d615669c61b6bf24bd116 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_direct_xxx_declarator_4, 1060, const_tuple_a4b7bb804c3c87f7b7aff1f402fad3af_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ed4050f5ceb4859fce3f8015827a9ddd = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_direct_xxx_declarator_5, 1082, const_tuple_str_plain_self_str_plain_p_str_plain_arr_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e4b4c3a4569c493600c917b20c1f31dd = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_direct_xxx_declarator_6, 1094, const_tuple_str_plain_self_str_plain_p_str_plain_func_str_plain_param_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_57177e1c43acfad59002f4c79c8dd68b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_empty, 1749, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_56043ddf00ef986baf64b5ab4532f55e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_enum_specifier_1, 965, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_795eb7c6f2350e65bc50540431566e11 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_enum_specifier_2, 971, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_bdb3c9c7f520adbb0bb977e5f55bd902 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_enum_specifier_3, 976, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_fc36fad08403ba995c218b757a509878 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_enumerator, 995, const_tuple_str_plain_self_str_plain_p_str_plain_enumerator_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f82d0149f91c7c324123f2efb235c3aa = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_enumerator_list, 982, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b7acc24f1086e7eb9e18ae8b458bb757 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_error, 1753, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_890693400d4202a153b8e1e690365ade = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_expression, 1474, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_effdb1dfb0ba4b664777a5d6f9df0b8d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_expression_statement, 1467, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_24adae7ae88f8e4355b4ba1428992bc6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_external_declaration_1, 541, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6879c1e9865b0e5e45bb62efdd824393 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_external_declaration_2, 546, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_208c1d0a5c48fb2f1b2e5a0a8e19fff7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_external_declaration_3, 551, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_229da5f0e9fa3c82a38b125a410979e1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_external_declaration_4, 557, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a679bfacf9dd7eea1a788fa45bb0ce95 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_function_definition_1, 580, const_tuple_str_plain_self_str_plain_p_str_plain_spec_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_48b53f7793e20849ff5aff6a6726fe71 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_function_definition_2, 597, const_tuple_str_plain_self_str_plain_p_str_plain_spec_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5cfdbbfac2e5693583b5c3bce0a5b55f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_function_specifier, 764, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_aa0f5872a2f8e0828a2d10c20a4ef844 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_id_init_declarator, 821, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_46874747c73603425f19b82b48f68a48 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_id_init_declarator_list, 815, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5ef1b3a186f7c83e4c84a68674855a62 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_identifier, 1683, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_867142bdf96c9102a846ef71dc64dcbc = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_identifier_list, 1231, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_97a3152e541b6ec6c995297d53d9b782 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_init_declarator, 809, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c4664c50857c8a99411c8f15a81eca07 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_init_declarator_list, 800, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3286b72abfbf9883a8da41cbb843f21f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_initializer_1, 1241, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_2981cd55a1d00047fb71fd4a3e5caa1e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_initializer_2, 1246, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7bdedbef7a00776795107daa1bc963d5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_initializer_list, 1255, const_tuple_str_plain_self_str_plain_p_str_plain_init_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_802c5dcca4e0dc3da51d1647e1b1c44b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_iteration_statement_1, 1432, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_af8b24a7fb187d46cbff465e53ea8988 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_iteration_statement_2, 1436, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_08768331755421b59b3b286c6aa14448 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_iteration_statement_3, 1440, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_568ad40762c86bdbb2f4cf4156d8c64e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_iteration_statement_4, 1444, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d4b13e566c43bcd4afcc2455b31001f3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_jump_statement_1, 1449, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_aa10437b2c7b7415d366a3591971e55e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_jump_statement_2, 1453, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9a7884aa4204ef4dbd3aad792656ee71 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_jump_statement_3, 1457, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_42a6c9510c0bdcc207922abe14498274 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_jump_statement_4, 1461, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1310901836337014bc882ee72d64976b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_labeled_statement_1, 1407, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_848b6d36ac8046f93895c4f1c5e3f20a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_labeled_statement_2, 1411, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_4b2ca4185e772da831d9fd26e5c441de = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_labeled_statement_3, 1415, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_16109f170a5b0bf37839ac5e2c0e961f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_offsetof_member_designator, 1658, const_tuple_str_plain_self_str_plain_p_str_plain_field_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1802192b2a03b205fa58a441ed52b1bb = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_parameter_declaration_1, 1188, const_tuple_str_plain_self_str_plain_p_str_plain_spec_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ec7e7fa34698fe0d0aeabdfc87e00cd0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_parameter_declaration_2, 1200, const_tuple_0f1b9a27033e2962bbcd8849947d6d02_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_33c782c9369ccb6646fd10ca5266b9cf = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_parameter_list, 1168, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_11b37f28b0696e358af2a7dcdff91c68 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_parameter_type_list, 1159, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_878a1c18fbce981d7e9ea80408cd4b98 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_pointer, 1123, const_tuple_22e763767c9a66d68e45377ac7499ee8_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1fb46e7eab0421a5014bc4bf4a5b4563 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_postfix_expression_1, 1597, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9d63efb08280aa9f3e1ade085e5671ce = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_postfix_expression_2, 1601, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_12651dd7f01f4a368063187baf6a9878 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_postfix_expression_3, 1605, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_21b21c0e9aa6489741377e3025474a8d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_postfix_expression_4, 1611, const_tuple_str_plain_self_str_plain_p_str_plain_field_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_2f22fe77305a28e8416b02900417c1b5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_postfix_expression_5, 1620, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_2ffe8752d69b5192793518d9b2bd5183 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_postfix_expression_6, 1626, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e6bd3ffd6382f6051682737b197f564d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_pp_directive, 562, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_593cfeb60507e7593ca2134a702e323c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_pppragma_directive, 568, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7aacc024cef287d47094c2e9272ac6a3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_primary_expression_1, 1632, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_25ef2753338c990d7a75642de258fee4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_primary_expression_2, 1636, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_79eb7006626f9d871293d99e614159a9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_primary_expression_3, 1640, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6fe279688e2cd7bc46d2d64929e946b5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_primary_expression_4, 1646, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3ebb659f536809e4475d45060ad98408 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_primary_expression_5, 1650, const_tuple_str_plain_self_str_plain_p_str_plain_coord_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3827ee0116b2c686ac4a629dc5c8d41b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_selection_statement_1, 1419, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_02c27f43617c9de50be853bd11a02557 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_selection_statement_2, 1423, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_df0dd4c7f3200da012ac0fd7c5300dee = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_selection_statement_3, 1427, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_418db9cacfcd09e3118e18f6d0a2849f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_specifier_qualifier_list_1, 829, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6ecdf682fba70e48f758afad9ba925c9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_specifier_qualifier_list_2, 834, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1da590064ef77831c71eb320c8e29b4f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_specifier_qualifier_list_3, 839, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3c330c3797f362655fc43b272c3eb042 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_specifier_qualifier_list_4, 844, const_tuple_str_plain_self_str_plain_p_str_plain_spec_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7eb54679c49b7375444fb88c8b84b1c2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_statement, 608, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_80b01d1e78e2951d30442bff34e5a4cb = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_storage_class_specifier, 755, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7f70ce3e02d3f2f4e1e4321d7d064669 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_struct_declaration_1, 899, const_tuple_f2e4debd813b1d9581312e122bd2eee4_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_753414c1c431ae4c5db9c6601df038b5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_struct_declaration_2, 937, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d92a866aca5ee4bf46d4ac9e314cf35b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_struct_declaration_list, 890, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f6eb8c7ab6d5260fc9fa696b3c5597c9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_struct_declarator_1, 951, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3ce513362ae9f8a7a7ed0c2ec7b2acad = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_struct_declarator_2, 956, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b0f344fd6a0c4d2abd6db14c8fef82ab = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_struct_declarator_list, 942, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_eaf2fded8c31a9dea63e42cdeb65689e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_struct_or_union, 882, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0ea1d0686563ee73ce9af74116275c5f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_struct_or_union_specifier_1, 853, const_tuple_str_plain_self_str_plain_p_str_plain_klass_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_129c1473716b75fca59a3bb1a8c29dc1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_struct_or_union_specifier_2, 863, const_tuple_str_plain_self_str_plain_p_str_plain_klass_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0fd5d9823eacda464fa5a1ee5cd90b6e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_struct_or_union_specifier_3, 872, const_tuple_str_plain_self_str_plain_p_str_plain_klass_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a186227811a44983d6a7e67189d06650 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_translation_unit_1, 522, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_aee718468f446ee6274702a5598cc964 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_translation_unit_2, 529, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_25d6673a41ce2601022f3bec8cf9b9f2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_translation_unit_or_empty, 513, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_febe702af8a1cd2b2bf16ba9e9fd3f58 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_type_name, 1287, const_tuple_str_plain_self_str_plain_p_str_plain_typename_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_39de1eccef65c50e3c79de1d987275c6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_type_qualifier, 793, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5d32d7d5b0f216e650e8a6ecb453fe6c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_type_qualifier_list, 1153, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f569cd0da9b9127eb406763c7c607567 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_type_specifier, 785, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_463376239af8505f839bcaa0249bfc10 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_type_specifier_no_typeid, 769, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1f4b7bc9508ec89587d97c1950610acf = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_typedef_name, 1487, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_2805b5236c257d9892595ef331fe32b7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_unary_expression_1, 1567, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5cc8d94a5e1fe1d058d2dc0e268f0c82 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_unary_expression_2, 1571, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8b7d7117faec7d0aef260da43d40c207 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_unary_expression_3, 1578, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b4c79c4a2dd3535b415a0995f8471cae = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_unary_operator, 1587, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_58509cdc3d7993928017f618fed741c3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_unified_string_literal, 1715, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a488ed12a4b6217597f4f94e372f960d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_unified_wstring_literal, 1726, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8b41c2cd19aa34d145a09e06a36a06d1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_xxx_declarator_1, 1017, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_98e40246e2cc3f8becdbf3e10cd918f2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_p_xxx_declarator_2, 1023, const_tuple_str_plain_self_str_plain_p_tuple, 2, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6a3ff42cc3d74ce0db1744142bbec85f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_parse, 132, const_tuple_75d110c860c3329371e02201c24c7204_tuple, 4, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
}

// The module function declarations.
NUITKA_LOCAL_MODULE PyObject *impl_pycparser$c_parser$$$class_1_CParser( PyObject **python_pars, PyObject **closure_pycparser$c_parser_class_creation_1__bases, PyObject **closure_pycparser$c_parser_class_creation_1__class_decl_dict, PyObject **closure_pycparser$c_parser_class_creation_1__metaclass, PyObject **closure_pycparser$c_parser_class_creation_1__prepared );


NUITKA_LOCAL_MODULE PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_14__fix_decl_name_type$$$function_1_listcontraction( PyObject **python_pars );


NUITKA_LOCAL_MODULE PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_77_p_direct_xxx_declarator_4$$$function_1_listcontraction( PyObject **python_pars );


NUITKA_LOCAL_MODULE PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_77_p_direct_xxx_declarator_4$$$function_2_listcontraction( PyObject **python_pars );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_100_p_direct_abstract_declarator_4(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_101_p_direct_abstract_declarator_5(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_102_p_direct_abstract_declarator_6(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_103_p_direct_abstract_declarator_7(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_104_p_block_item(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_105_p_block_item_list(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_106_p_compound_statement_1(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_107_p_labeled_statement_1(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_108_p_labeled_statement_2(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_109_p_labeled_statement_3(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_10__lex_on_rbrace_func(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_110_p_selection_statement_1(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_111_p_selection_statement_2(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_112_p_selection_statement_3(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_113_p_iteration_statement_1(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_114_p_iteration_statement_2(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_115_p_iteration_statement_3(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_116_p_iteration_statement_4(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_117_p_jump_statement_1(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_118_p_jump_statement_2(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_119_p_jump_statement_3(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_11__lex_type_lookup_func(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_120_p_jump_statement_4(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_121_p_expression_statement(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_122_p_expression(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_123_p_typedef_name(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_124_p_assignment_expression(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_125_p_assignment_operator(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_126_p_constant_expression(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_127_p_conditional_expression(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_128_p_binary_expression(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_129_p_cast_expression_1(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_12__get_yacc_lookahead_token(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_130_p_cast_expression_2(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_131_p_unary_expression_1(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_132_p_unary_expression_2(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_133_p_unary_expression_3(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_134_p_unary_operator(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_135_p_postfix_expression_1(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_136_p_postfix_expression_2(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_137_p_postfix_expression_3(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_138_p_postfix_expression_4(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_139_p_postfix_expression_5(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_13__type_modify_decl(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_140_p_postfix_expression_6(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_141_p_primary_expression_1(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_142_p_primary_expression_2(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_143_p_primary_expression_3(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_144_p_primary_expression_4(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_145_p_primary_expression_5(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_146_p_offsetof_member_designator(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_147_p_argument_expression_list(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_148_p_identifier(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_149_p_constant_1(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_14__fix_decl_name_type(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_150_p_constant_2(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_151_p_constant_3(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_152_p_unified_string_literal(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_153_p_unified_wstring_literal(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_154_p_brace_open(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_155_p_brace_close(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_156_p_empty(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_157_p_error(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_15__add_declaration_specifier( PyObject *defaults );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_16__build_declarations( PyObject *defaults );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_17__build_function_definition(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_18__select_struct_union_class(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_19_p_translation_unit_or_empty(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_1___init__( PyObject *defaults );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_20_p_translation_unit_1(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_21_p_translation_unit_2(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_22_p_external_declaration_1(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_23_p_external_declaration_2(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_24_p_external_declaration_3(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_25_p_external_declaration_4(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_26_p_pp_directive(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_27_p_pppragma_directive(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_28_p_function_definition_1(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_29_p_function_definition_2(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_2_parse( PyObject *defaults );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_30_p_statement(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_31_p_decl_body(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_32_p_declaration(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_33_p_declaration_list(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_34_p_declaration_specifiers_no_type_1(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_35_p_declaration_specifiers_no_type_2(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_36_p_declaration_specifiers_no_type_3(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_37_p_declaration_specifiers_1(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_38_p_declaration_specifiers_2(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_39_p_declaration_specifiers_3(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_3__push_scope(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_40_p_declaration_specifiers_4(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_41_p_declaration_specifiers_5(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_42_p_declaration_specifiers_6(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_43_p_storage_class_specifier(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_44_p_function_specifier(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_45_p_type_specifier_no_typeid(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_46_p_type_specifier(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_47_p_type_qualifier(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_48_p_init_declarator_list(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_49_p_init_declarator(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_4__pop_scope(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_50_p_id_init_declarator_list(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_51_p_id_init_declarator(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_52_p_specifier_qualifier_list_1(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_53_p_specifier_qualifier_list_2(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_54_p_specifier_qualifier_list_3(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_55_p_specifier_qualifier_list_4(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_56_p_struct_or_union_specifier_1(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_57_p_struct_or_union_specifier_2(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_58_p_struct_or_union_specifier_3(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_59_p_struct_or_union(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_5__add_typedef_name(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_60_p_struct_declaration_list(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_61_p_struct_declaration_1(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_62_p_struct_declaration_2(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_63_p_struct_declarator_list(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_64_p_struct_declarator_1(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_65_p_struct_declarator_2(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_66_p_enum_specifier_1(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_67_p_enum_specifier_2(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_68_p_enum_specifier_3(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_69_p_enumerator_list(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_6__add_identifier(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_70_p_enumerator(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_71_p_declarator(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_72_p_xxx_declarator_1(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_73_p_xxx_declarator_2(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_74_p_direct_xxx_declarator_1(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_75_p_direct_xxx_declarator_2(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_76_p_direct_xxx_declarator_3(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_77_p_direct_xxx_declarator_4(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_78_p_direct_xxx_declarator_5(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_79_p_direct_xxx_declarator_6(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_7__is_type_in_scope(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_80_p_pointer(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_81_p_type_qualifier_list(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_82_p_parameter_type_list(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_83_p_parameter_list(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_84_p_parameter_declaration_1(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_85_p_parameter_declaration_2(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_86_p_identifier_list(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_87_p_initializer_1(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_88_p_initializer_2(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_89_p_initializer_list(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_8__lex_error_func(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_90_p_designation(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_91_p_designator_list(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_92_p_designator(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_93_p_type_name(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_94_p_abstract_declarator_1(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_95_p_abstract_declarator_2(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_96_p_abstract_declarator_3(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_97_p_direct_abstract_declarator_1(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_98_p_direct_abstract_declarator_2(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_99_p_direct_abstract_declarator_3(  );


static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_9__lex_on_lbrace_func(  );


// The module function definitions.
NUITKA_LOCAL_MODULE PyObject *impl_pycparser$c_parser$$$class_1_CParser( PyObject **python_pars, PyObject **closure_pycparser$c_parser_class_creation_1__bases, PyObject **closure_pycparser$c_parser_class_creation_1__class_decl_dict, PyObject **closure_pycparser$c_parser_class_creation_1__metaclass, PyObject **closure_pycparser$c_parser_class_creation_1__prepared )
{
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
    assert(!had_error); // Do not enter inlined functions with error set.
#endif

    // Local variable declarations.
    // Locals dictionary setup.
    PyObject *locals_dict = PyDict_New();

    PyObject *var___class__ = NULL;
    PyObject *var___qualname__ = NULL;
    PyObject *var___module__ = NULL;
    PyObject *var___init__ = NULL;
    PyObject *var_parse = NULL;
    PyObject *var__push_scope = NULL;
    PyObject *var__pop_scope = NULL;
    PyObject *var__add_typedef_name = NULL;
    PyObject *var__add_identifier = NULL;
    PyObject *var__is_type_in_scope = NULL;
    PyObject *var__lex_error_func = NULL;
    PyObject *var__lex_on_lbrace_func = NULL;
    PyObject *var__lex_on_rbrace_func = NULL;
    PyObject *var__lex_type_lookup_func = NULL;
    PyObject *var__get_yacc_lookahead_token = NULL;
    PyObject *var__type_modify_decl = NULL;
    PyObject *var__fix_decl_name_type = NULL;
    PyObject *var__add_declaration_specifier = NULL;
    PyObject *var__build_declarations = NULL;
    PyObject *var__build_function_definition = NULL;
    PyObject *var__select_struct_union_class = NULL;
    PyObject *var_precedence = NULL;
    PyObject *var_p_translation_unit_or_empty = NULL;
    PyObject *var_p_translation_unit_1 = NULL;
    PyObject *var_p_translation_unit_2 = NULL;
    PyObject *var_p_external_declaration_1 = NULL;
    PyObject *var_p_external_declaration_2 = NULL;
    PyObject *var_p_external_declaration_3 = NULL;
    PyObject *var_p_external_declaration_4 = NULL;
    PyObject *var_p_pp_directive = NULL;
    PyObject *var_p_pppragma_directive = NULL;
    PyObject *var_p_function_definition_1 = NULL;
    PyObject *var_p_function_definition_2 = NULL;
    PyObject *var_p_statement = NULL;
    PyObject *var_p_decl_body = NULL;
    PyObject *var_p_declaration = NULL;
    PyObject *var_p_declaration_list = NULL;
    PyObject *var_p_declaration_specifiers_no_type_1 = NULL;
    PyObject *var_p_declaration_specifiers_no_type_2 = NULL;
    PyObject *var_p_declaration_specifiers_no_type_3 = NULL;
    PyObject *var_p_declaration_specifiers_1 = NULL;
    PyObject *var_p_declaration_specifiers_2 = NULL;
    PyObject *var_p_declaration_specifiers_3 = NULL;
    PyObject *var_p_declaration_specifiers_4 = NULL;
    PyObject *var_p_declaration_specifiers_5 = NULL;
    PyObject *var_p_declaration_specifiers_6 = NULL;
    PyObject *var_p_storage_class_specifier = NULL;
    PyObject *var_p_function_specifier = NULL;
    PyObject *var_p_type_specifier_no_typeid = NULL;
    PyObject *var_p_type_specifier = NULL;
    PyObject *var_p_type_qualifier = NULL;
    PyObject *var_p_init_declarator_list = NULL;
    PyObject *var_p_init_declarator = NULL;
    PyObject *var_p_id_init_declarator_list = NULL;
    PyObject *var_p_id_init_declarator = NULL;
    PyObject *var_p_specifier_qualifier_list_1 = NULL;
    PyObject *var_p_specifier_qualifier_list_2 = NULL;
    PyObject *var_p_specifier_qualifier_list_3 = NULL;
    PyObject *var_p_specifier_qualifier_list_4 = NULL;
    PyObject *var_p_struct_or_union_specifier_1 = NULL;
    PyObject *var_p_struct_or_union_specifier_2 = NULL;
    PyObject *var_p_struct_or_union_specifier_3 = NULL;
    PyObject *var_p_struct_or_union = NULL;
    PyObject *var_p_struct_declaration_list = NULL;
    PyObject *var_p_struct_declaration_1 = NULL;
    PyObject *var_p_struct_declaration_2 = NULL;
    PyObject *var_p_struct_declarator_list = NULL;
    PyObject *var_p_struct_declarator_1 = NULL;
    PyObject *var_p_struct_declarator_2 = NULL;
    PyObject *var_p_enum_specifier_1 = NULL;
    PyObject *var_p_enum_specifier_2 = NULL;
    PyObject *var_p_enum_specifier_3 = NULL;
    PyObject *var_p_enumerator_list = NULL;
    PyObject *var_p_enumerator = NULL;
    PyObject *var_p_declarator = NULL;
    PyObject *var_p_xxx_declarator_1 = NULL;
    PyObject *var_p_xxx_declarator_2 = NULL;
    PyObject *var_p_direct_xxx_declarator_1 = NULL;
    PyObject *var_p_direct_xxx_declarator_2 = NULL;
    PyObject *var_p_direct_xxx_declarator_3 = NULL;
    PyObject *var_p_direct_xxx_declarator_4 = NULL;
    PyObject *var_p_direct_xxx_declarator_5 = NULL;
    PyObject *var_p_direct_xxx_declarator_6 = NULL;
    PyObject *var_p_pointer = NULL;
    PyObject *var_p_type_qualifier_list = NULL;
    PyObject *var_p_parameter_type_list = NULL;
    PyObject *var_p_parameter_list = NULL;
    PyObject *var_p_parameter_declaration_1 = NULL;
    PyObject *var_p_parameter_declaration_2 = NULL;
    PyObject *var_p_identifier_list = NULL;
    PyObject *var_p_initializer_1 = NULL;
    PyObject *var_p_initializer_2 = NULL;
    PyObject *var_p_initializer_list = NULL;
    PyObject *var_p_designation = NULL;
    PyObject *var_p_designator_list = NULL;
    PyObject *var_p_designator = NULL;
    PyObject *var_p_type_name = NULL;
    PyObject *var_p_abstract_declarator_1 = NULL;
    PyObject *var_p_abstract_declarator_2 = NULL;
    PyObject *var_p_abstract_declarator_3 = NULL;
    PyObject *var_p_direct_abstract_declarator_1 = NULL;
    PyObject *var_p_direct_abstract_declarator_2 = NULL;
    PyObject *var_p_direct_abstract_declarator_3 = NULL;
    PyObject *var_p_direct_abstract_declarator_4 = NULL;
    PyObject *var_p_direct_abstract_declarator_5 = NULL;
    PyObject *var_p_direct_abstract_declarator_6 = NULL;
    PyObject *var_p_direct_abstract_declarator_7 = NULL;
    PyObject *var_p_block_item = NULL;
    PyObject *var_p_block_item_list = NULL;
    PyObject *var_p_compound_statement_1 = NULL;
    PyObject *var_p_labeled_statement_1 = NULL;
    PyObject *var_p_labeled_statement_2 = NULL;
    PyObject *var_p_labeled_statement_3 = NULL;
    PyObject *var_p_selection_statement_1 = NULL;
    PyObject *var_p_selection_statement_2 = NULL;
    PyObject *var_p_selection_statement_3 = NULL;
    PyObject *var_p_iteration_statement_1 = NULL;
    PyObject *var_p_iteration_statement_2 = NULL;
    PyObject *var_p_iteration_statement_3 = NULL;
    PyObject *var_p_iteration_statement_4 = NULL;
    PyObject *var_p_jump_statement_1 = NULL;
    PyObject *var_p_jump_statement_2 = NULL;
    PyObject *var_p_jump_statement_3 = NULL;
    PyObject *var_p_jump_statement_4 = NULL;
    PyObject *var_p_expression_statement = NULL;
    PyObject *var_p_expression = NULL;
    PyObject *var_p_typedef_name = NULL;
    PyObject *var_p_assignment_expression = NULL;
    PyObject *var_p_assignment_operator = NULL;
    PyObject *var_p_constant_expression = NULL;
    PyObject *var_p_conditional_expression = NULL;
    PyObject *var_p_binary_expression = NULL;
    PyObject *var_p_cast_expression_1 = NULL;
    PyObject *var_p_cast_expression_2 = NULL;
    PyObject *var_p_unary_expression_1 = NULL;
    PyObject *var_p_unary_expression_2 = NULL;
    PyObject *var_p_unary_expression_3 = NULL;
    PyObject *var_p_unary_operator = NULL;
    PyObject *var_p_postfix_expression_1 = NULL;
    PyObject *var_p_postfix_expression_2 = NULL;
    PyObject *var_p_postfix_expression_3 = NULL;
    PyObject *var_p_postfix_expression_4 = NULL;
    PyObject *var_p_postfix_expression_5 = NULL;
    PyObject *var_p_postfix_expression_6 = NULL;
    PyObject *var_p_primary_expression_1 = NULL;
    PyObject *var_p_primary_expression_2 = NULL;
    PyObject *var_p_primary_expression_3 = NULL;
    PyObject *var_p_primary_expression_4 = NULL;
    PyObject *var_p_primary_expression_5 = NULL;
    PyObject *var_p_offsetof_member_designator = NULL;
    PyObject *var_p_argument_expression_list = NULL;
    PyObject *var_p_identifier = NULL;
    PyObject *var_p_constant_1 = NULL;
    PyObject *var_p_constant_2 = NULL;
    PyObject *var_p_constant_3 = NULL;
    PyObject *var_p_unified_string_literal = NULL;
    PyObject *var_p_unified_wstring_literal = NULL;
    PyObject *var_p_brace_open = NULL;
    PyObject *var_p_brace_close = NULL;
    PyObject *var_p_empty = NULL;
    PyObject *var_p_error = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_assign_source_12;
    PyObject *tmp_assign_source_13;
    PyObject *tmp_assign_source_14;
    PyObject *tmp_assign_source_15;
    PyObject *tmp_assign_source_16;
    PyObject *tmp_assign_source_17;
    PyObject *tmp_assign_source_18;
    PyObject *tmp_assign_source_19;
    PyObject *tmp_assign_source_20;
    PyObject *tmp_assign_source_21;
    PyObject *tmp_assign_source_22;
    PyObject *tmp_assign_source_23;
    PyObject *tmp_assign_source_24;
    PyObject *tmp_assign_source_25;
    PyObject *tmp_assign_source_26;
    PyObject *tmp_assign_source_27;
    PyObject *tmp_assign_source_28;
    PyObject *tmp_assign_source_29;
    PyObject *tmp_assign_source_30;
    PyObject *tmp_assign_source_31;
    PyObject *tmp_assign_source_32;
    PyObject *tmp_assign_source_33;
    PyObject *tmp_assign_source_34;
    PyObject *tmp_assign_source_35;
    PyObject *tmp_assign_source_36;
    PyObject *tmp_assign_source_37;
    PyObject *tmp_assign_source_38;
    PyObject *tmp_assign_source_39;
    PyObject *tmp_assign_source_40;
    PyObject *tmp_assign_source_41;
    PyObject *tmp_assign_source_42;
    PyObject *tmp_assign_source_43;
    PyObject *tmp_assign_source_44;
    PyObject *tmp_assign_source_45;
    PyObject *tmp_assign_source_46;
    PyObject *tmp_assign_source_47;
    PyObject *tmp_assign_source_48;
    PyObject *tmp_assign_source_49;
    PyObject *tmp_assign_source_50;
    PyObject *tmp_assign_source_51;
    PyObject *tmp_assign_source_52;
    PyObject *tmp_assign_source_53;
    PyObject *tmp_assign_source_54;
    PyObject *tmp_assign_source_55;
    PyObject *tmp_assign_source_56;
    PyObject *tmp_assign_source_57;
    PyObject *tmp_assign_source_58;
    PyObject *tmp_assign_source_59;
    PyObject *tmp_assign_source_60;
    PyObject *tmp_assign_source_61;
    PyObject *tmp_assign_source_62;
    PyObject *tmp_assign_source_63;
    PyObject *tmp_assign_source_64;
    PyObject *tmp_assign_source_65;
    PyObject *tmp_assign_source_66;
    PyObject *tmp_assign_source_67;
    PyObject *tmp_assign_source_68;
    PyObject *tmp_assign_source_69;
    PyObject *tmp_assign_source_70;
    PyObject *tmp_assign_source_71;
    PyObject *tmp_assign_source_72;
    PyObject *tmp_assign_source_73;
    PyObject *tmp_assign_source_74;
    PyObject *tmp_assign_source_75;
    PyObject *tmp_assign_source_76;
    PyObject *tmp_assign_source_77;
    PyObject *tmp_assign_source_78;
    PyObject *tmp_assign_source_79;
    PyObject *tmp_assign_source_80;
    PyObject *tmp_assign_source_81;
    PyObject *tmp_assign_source_82;
    PyObject *tmp_assign_source_83;
    PyObject *tmp_assign_source_84;
    PyObject *tmp_assign_source_85;
    PyObject *tmp_assign_source_86;
    PyObject *tmp_assign_source_87;
    PyObject *tmp_assign_source_88;
    PyObject *tmp_assign_source_89;
    PyObject *tmp_assign_source_90;
    PyObject *tmp_assign_source_91;
    PyObject *tmp_assign_source_92;
    PyObject *tmp_assign_source_93;
    PyObject *tmp_assign_source_94;
    PyObject *tmp_assign_source_95;
    PyObject *tmp_assign_source_96;
    PyObject *tmp_assign_source_97;
    PyObject *tmp_assign_source_98;
    PyObject *tmp_assign_source_99;
    PyObject *tmp_assign_source_100;
    PyObject *tmp_assign_source_101;
    PyObject *tmp_assign_source_102;
    PyObject *tmp_assign_source_103;
    PyObject *tmp_assign_source_104;
    PyObject *tmp_assign_source_105;
    PyObject *tmp_assign_source_106;
    PyObject *tmp_assign_source_107;
    PyObject *tmp_assign_source_108;
    PyObject *tmp_assign_source_109;
    PyObject *tmp_assign_source_110;
    PyObject *tmp_assign_source_111;
    PyObject *tmp_assign_source_112;
    PyObject *tmp_assign_source_113;
    PyObject *tmp_assign_source_114;
    PyObject *tmp_assign_source_115;
    PyObject *tmp_assign_source_116;
    PyObject *tmp_assign_source_117;
    PyObject *tmp_assign_source_118;
    PyObject *tmp_assign_source_119;
    PyObject *tmp_assign_source_120;
    PyObject *tmp_assign_source_121;
    PyObject *tmp_assign_source_122;
    PyObject *tmp_assign_source_123;
    PyObject *tmp_assign_source_124;
    PyObject *tmp_assign_source_125;
    PyObject *tmp_assign_source_126;
    PyObject *tmp_assign_source_127;
    PyObject *tmp_assign_source_128;
    PyObject *tmp_assign_source_129;
    PyObject *tmp_assign_source_130;
    PyObject *tmp_assign_source_131;
    PyObject *tmp_assign_source_132;
    PyObject *tmp_assign_source_133;
    PyObject *tmp_assign_source_134;
    PyObject *tmp_assign_source_135;
    PyObject *tmp_assign_source_136;
    PyObject *tmp_assign_source_137;
    PyObject *tmp_assign_source_138;
    PyObject *tmp_assign_source_139;
    PyObject *tmp_assign_source_140;
    PyObject *tmp_assign_source_141;
    PyObject *tmp_assign_source_142;
    PyObject *tmp_assign_source_143;
    PyObject *tmp_assign_source_144;
    PyObject *tmp_assign_source_145;
    PyObject *tmp_assign_source_146;
    PyObject *tmp_assign_source_147;
    PyObject *tmp_assign_source_148;
    PyObject *tmp_assign_source_149;
    PyObject *tmp_assign_source_150;
    PyObject *tmp_assign_source_151;
    PyObject *tmp_assign_source_152;
    PyObject *tmp_assign_source_153;
    PyObject *tmp_assign_source_154;
    PyObject *tmp_assign_source_155;
    PyObject *tmp_assign_source_156;
    PyObject *tmp_assign_source_157;
    PyObject *tmp_assign_source_158;
    PyObject *tmp_assign_source_159;
    PyObject *tmp_assign_source_160;
    PyObject *tmp_assign_source_161;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    PyObject *tmp_called_name_10;
    PyObject *tmp_called_name_11;
    PyObject *tmp_called_name_12;
    PyObject *tmp_called_name_13;
    PyObject *tmp_called_name_14;
    PyObject *tmp_called_name_15;
    PyObject *tmp_called_name_16;
    PyObject *tmp_called_name_17;
    PyObject *tmp_defaults_1;
    PyObject *tmp_defaults_2;
    PyObject *tmp_defaults_3;
    PyObject *tmp_defaults_4;
    PyObject *tmp_kw_name_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_set_locals;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_tuple_element_2;
    static struct Nuitka_FrameObject *cache_frame_81959b19e2f92da45fb0e4a88b971619 = NULL;

    struct Nuitka_FrameObject *frame_81959b19e2f92da45fb0e4a88b971619;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_set_locals = *closure_pycparser$c_parser_class_creation_1__prepared;

    CHECK_OBJECT( tmp_set_locals );
    Py_DECREF(locals_dict);
    locals_dict = tmp_set_locals;
    Py_INCREF(locals_dict);
    tmp_assign_source_1 = const_str_digest_738bb76ee3cb1d75ac2eedcc90bfedb8;
    assert( var___module__ == NULL );
    Py_INCREF( tmp_assign_source_1 );
    var___module__ = tmp_assign_source_1;

    tmp_assign_source_2 = const_str_plain_CParser;
    assert( var___qualname__ == NULL );
    Py_INCREF( tmp_assign_source_2 );
    var___qualname__ = tmp_assign_source_2;

    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_81959b19e2f92da45fb0e4a88b971619, codeobj_81959b19e2f92da45fb0e4a88b971619, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_81959b19e2f92da45fb0e4a88b971619 = cache_frame_81959b19e2f92da45fb0e4a88b971619;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_81959b19e2f92da45fb0e4a88b971619 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_81959b19e2f92da45fb0e4a88b971619 ) == 2 ); // Frame stack

    // Framed code:
    tmp_defaults_1 = PyTuple_New( 7 );
    tmp_tuple_element_1 = Py_True;
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_defaults_1, 0, tmp_tuple_element_1 );
    tmp_tuple_element_1 = PyDict_GetItem( locals_dict, const_str_plain_CLexer );

    if ( tmp_tuple_element_1 == NULL )
    {
        tmp_tuple_element_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_CLexer );

        if (unlikely( tmp_tuple_element_1 == NULL ))
        {
            tmp_tuple_element_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_CLexer );
        }

        if ( tmp_tuple_element_1 == NULL )
        {
            Py_DECREF( tmp_defaults_1 );
            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "CLexer" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 24;
            type_description = "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
            goto frame_exception_exit_1;
        }

    }

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_defaults_1, 1, tmp_tuple_element_1 );
    tmp_tuple_element_1 = const_str_digest_f8343e16e92e519e6585339ebb169a13;
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_defaults_1, 2, tmp_tuple_element_1 );
    tmp_tuple_element_1 = Py_True;
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_defaults_1, 3, tmp_tuple_element_1 );
    tmp_tuple_element_1 = const_str_digest_705568b41dc44e9db67a41d3b2108e29;
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_defaults_1, 4, tmp_tuple_element_1 );
    tmp_tuple_element_1 = Py_False;
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_defaults_1, 5, tmp_tuple_element_1 );
    tmp_tuple_element_1 = const_str_empty;
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_defaults_1, 6, tmp_tuple_element_1 );
    tmp_assign_source_3 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_1___init__( tmp_defaults_1 );
    assert( var___init__ == NULL );
    var___init__ = tmp_assign_source_3;

    tmp_defaults_2 = const_tuple_str_empty_int_0_tuple;
    Py_INCREF( tmp_defaults_2 );
    tmp_assign_source_4 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_2_parse( tmp_defaults_2 );
    assert( var_parse == NULL );
    var_parse = tmp_assign_source_4;

    tmp_assign_source_5 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_3__push_scope(  );
    assert( var__push_scope == NULL );
    var__push_scope = tmp_assign_source_5;

    tmp_assign_source_6 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_4__pop_scope(  );
    assert( var__pop_scope == NULL );
    var__pop_scope = tmp_assign_source_6;

    tmp_assign_source_7 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_5__add_typedef_name(  );
    assert( var__add_typedef_name == NULL );
    var__add_typedef_name = tmp_assign_source_7;

    tmp_assign_source_8 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_6__add_identifier(  );
    assert( var__add_identifier == NULL );
    var__add_identifier = tmp_assign_source_8;

    tmp_assign_source_9 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_7__is_type_in_scope(  );
    assert( var__is_type_in_scope == NULL );
    var__is_type_in_scope = tmp_assign_source_9;

    tmp_assign_source_10 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_8__lex_error_func(  );
    assert( var__lex_error_func == NULL );
    var__lex_error_func = tmp_assign_source_10;

    tmp_assign_source_11 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_9__lex_on_lbrace_func(  );
    assert( var__lex_on_lbrace_func == NULL );
    var__lex_on_lbrace_func = tmp_assign_source_11;

    tmp_assign_source_12 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_10__lex_on_rbrace_func(  );
    assert( var__lex_on_rbrace_func == NULL );
    var__lex_on_rbrace_func = tmp_assign_source_12;

    tmp_assign_source_13 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_11__lex_type_lookup_func(  );
    assert( var__lex_type_lookup_func == NULL );
    var__lex_type_lookup_func = tmp_assign_source_13;

    tmp_assign_source_14 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_12__get_yacc_lookahead_token(  );
    assert( var__get_yacc_lookahead_token == NULL );
    var__get_yacc_lookahead_token = tmp_assign_source_14;

    tmp_assign_source_15 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_13__type_modify_decl(  );
    assert( var__type_modify_decl == NULL );
    var__type_modify_decl = tmp_assign_source_15;

    tmp_assign_source_16 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_14__fix_decl_name_type(  );
    assert( var__fix_decl_name_type == NULL );
    var__fix_decl_name_type = tmp_assign_source_16;

    tmp_defaults_3 = const_tuple_false_tuple;
    Py_INCREF( tmp_defaults_3 );
    tmp_assign_source_17 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_15__add_declaration_specifier( tmp_defaults_3 );
    assert( var__add_declaration_specifier == NULL );
    var__add_declaration_specifier = tmp_assign_source_17;

    tmp_defaults_4 = const_tuple_false_tuple;
    Py_INCREF( tmp_defaults_4 );
    tmp_assign_source_18 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_16__build_declarations( tmp_defaults_4 );
    assert( var__build_declarations == NULL );
    var__build_declarations = tmp_assign_source_18;

    tmp_assign_source_19 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_17__build_function_definition(  );
    assert( var__build_function_definition == NULL );
    var__build_function_definition = tmp_assign_source_19;

    tmp_assign_source_20 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_18__select_struct_union_class(  );
    assert( var__select_struct_union_class == NULL );
    var__select_struct_union_class = tmp_assign_source_20;

    tmp_assign_source_21 = const_tuple_b9ac4cd6be84011bb32a829063c1f63d_tuple;
    assert( var_precedence == NULL );
    Py_INCREF( tmp_assign_source_21 );
    var_precedence = tmp_assign_source_21;

    tmp_assign_source_22 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_19_p_translation_unit_or_empty(  );
    assert( var_p_translation_unit_or_empty == NULL );
    var_p_translation_unit_or_empty = tmp_assign_source_22;

    tmp_assign_source_23 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_20_p_translation_unit_1(  );
    assert( var_p_translation_unit_1 == NULL );
    var_p_translation_unit_1 = tmp_assign_source_23;

    tmp_assign_source_24 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_21_p_translation_unit_2(  );
    assert( var_p_translation_unit_2 == NULL );
    var_p_translation_unit_2 = tmp_assign_source_24;

    tmp_assign_source_25 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_22_p_external_declaration_1(  );
    assert( var_p_external_declaration_1 == NULL );
    var_p_external_declaration_1 = tmp_assign_source_25;

    tmp_assign_source_26 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_23_p_external_declaration_2(  );
    assert( var_p_external_declaration_2 == NULL );
    var_p_external_declaration_2 = tmp_assign_source_26;

    tmp_assign_source_27 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_24_p_external_declaration_3(  );
    assert( var_p_external_declaration_3 == NULL );
    var_p_external_declaration_3 = tmp_assign_source_27;

    tmp_assign_source_28 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_25_p_external_declaration_4(  );
    assert( var_p_external_declaration_4 == NULL );
    var_p_external_declaration_4 = tmp_assign_source_28;

    tmp_assign_source_29 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_26_p_pp_directive(  );
    assert( var_p_pp_directive == NULL );
    var_p_pp_directive = tmp_assign_source_29;

    tmp_assign_source_30 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_27_p_pppragma_directive(  );
    assert( var_p_pppragma_directive == NULL );
    var_p_pppragma_directive = tmp_assign_source_30;

    tmp_assign_source_31 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_28_p_function_definition_1(  );
    assert( var_p_function_definition_1 == NULL );
    var_p_function_definition_1 = tmp_assign_source_31;

    tmp_assign_source_32 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_29_p_function_definition_2(  );
    assert( var_p_function_definition_2 == NULL );
    var_p_function_definition_2 = tmp_assign_source_32;

    tmp_assign_source_33 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_30_p_statement(  );
    assert( var_p_statement == NULL );
    var_p_statement = tmp_assign_source_33;

    tmp_assign_source_34 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_31_p_decl_body(  );
    assert( var_p_decl_body == NULL );
    var_p_decl_body = tmp_assign_source_34;

    tmp_assign_source_35 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_32_p_declaration(  );
    assert( var_p_declaration == NULL );
    var_p_declaration = tmp_assign_source_35;

    tmp_assign_source_36 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_33_p_declaration_list(  );
    assert( var_p_declaration_list == NULL );
    var_p_declaration_list = tmp_assign_source_36;

    tmp_assign_source_37 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_34_p_declaration_specifiers_no_type_1(  );
    assert( var_p_declaration_specifiers_no_type_1 == NULL );
    var_p_declaration_specifiers_no_type_1 = tmp_assign_source_37;

    tmp_assign_source_38 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_35_p_declaration_specifiers_no_type_2(  );
    assert( var_p_declaration_specifiers_no_type_2 == NULL );
    var_p_declaration_specifiers_no_type_2 = tmp_assign_source_38;

    tmp_assign_source_39 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_36_p_declaration_specifiers_no_type_3(  );
    assert( var_p_declaration_specifiers_no_type_3 == NULL );
    var_p_declaration_specifiers_no_type_3 = tmp_assign_source_39;

    tmp_assign_source_40 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_37_p_declaration_specifiers_1(  );
    assert( var_p_declaration_specifiers_1 == NULL );
    var_p_declaration_specifiers_1 = tmp_assign_source_40;

    tmp_assign_source_41 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_38_p_declaration_specifiers_2(  );
    assert( var_p_declaration_specifiers_2 == NULL );
    var_p_declaration_specifiers_2 = tmp_assign_source_41;

    tmp_assign_source_42 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_39_p_declaration_specifiers_3(  );
    assert( var_p_declaration_specifiers_3 == NULL );
    var_p_declaration_specifiers_3 = tmp_assign_source_42;

    tmp_assign_source_43 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_40_p_declaration_specifiers_4(  );
    assert( var_p_declaration_specifiers_4 == NULL );
    var_p_declaration_specifiers_4 = tmp_assign_source_43;

    tmp_assign_source_44 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_41_p_declaration_specifiers_5(  );
    assert( var_p_declaration_specifiers_5 == NULL );
    var_p_declaration_specifiers_5 = tmp_assign_source_44;

    tmp_assign_source_45 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_42_p_declaration_specifiers_6(  );
    assert( var_p_declaration_specifiers_6 == NULL );
    var_p_declaration_specifiers_6 = tmp_assign_source_45;

    tmp_assign_source_46 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_43_p_storage_class_specifier(  );
    assert( var_p_storage_class_specifier == NULL );
    var_p_storage_class_specifier = tmp_assign_source_46;

    tmp_assign_source_47 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_44_p_function_specifier(  );
    assert( var_p_function_specifier == NULL );
    var_p_function_specifier = tmp_assign_source_47;

    tmp_assign_source_48 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_45_p_type_specifier_no_typeid(  );
    assert( var_p_type_specifier_no_typeid == NULL );
    var_p_type_specifier_no_typeid = tmp_assign_source_48;

    tmp_assign_source_49 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_46_p_type_specifier(  );
    assert( var_p_type_specifier == NULL );
    var_p_type_specifier = tmp_assign_source_49;

    tmp_assign_source_50 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_47_p_type_qualifier(  );
    assert( var_p_type_qualifier == NULL );
    var_p_type_qualifier = tmp_assign_source_50;

    tmp_assign_source_51 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_48_p_init_declarator_list(  );
    assert( var_p_init_declarator_list == NULL );
    var_p_init_declarator_list = tmp_assign_source_51;

    tmp_assign_source_52 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_49_p_init_declarator(  );
    assert( var_p_init_declarator == NULL );
    var_p_init_declarator = tmp_assign_source_52;

    tmp_assign_source_53 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_50_p_id_init_declarator_list(  );
    assert( var_p_id_init_declarator_list == NULL );
    var_p_id_init_declarator_list = tmp_assign_source_53;

    tmp_assign_source_54 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_51_p_id_init_declarator(  );
    assert( var_p_id_init_declarator == NULL );
    var_p_id_init_declarator = tmp_assign_source_54;

    tmp_assign_source_55 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_52_p_specifier_qualifier_list_1(  );
    assert( var_p_specifier_qualifier_list_1 == NULL );
    var_p_specifier_qualifier_list_1 = tmp_assign_source_55;

    tmp_assign_source_56 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_53_p_specifier_qualifier_list_2(  );
    assert( var_p_specifier_qualifier_list_2 == NULL );
    var_p_specifier_qualifier_list_2 = tmp_assign_source_56;

    tmp_assign_source_57 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_54_p_specifier_qualifier_list_3(  );
    assert( var_p_specifier_qualifier_list_3 == NULL );
    var_p_specifier_qualifier_list_3 = tmp_assign_source_57;

    tmp_assign_source_58 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_55_p_specifier_qualifier_list_4(  );
    assert( var_p_specifier_qualifier_list_4 == NULL );
    var_p_specifier_qualifier_list_4 = tmp_assign_source_58;

    tmp_assign_source_59 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_56_p_struct_or_union_specifier_1(  );
    assert( var_p_struct_or_union_specifier_1 == NULL );
    var_p_struct_or_union_specifier_1 = tmp_assign_source_59;

    tmp_assign_source_60 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_57_p_struct_or_union_specifier_2(  );
    assert( var_p_struct_or_union_specifier_2 == NULL );
    var_p_struct_or_union_specifier_2 = tmp_assign_source_60;

    tmp_assign_source_61 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_58_p_struct_or_union_specifier_3(  );
    assert( var_p_struct_or_union_specifier_3 == NULL );
    var_p_struct_or_union_specifier_3 = tmp_assign_source_61;

    tmp_assign_source_62 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_59_p_struct_or_union(  );
    assert( var_p_struct_or_union == NULL );
    var_p_struct_or_union = tmp_assign_source_62;

    tmp_assign_source_63 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_60_p_struct_declaration_list(  );
    assert( var_p_struct_declaration_list == NULL );
    var_p_struct_declaration_list = tmp_assign_source_63;

    tmp_assign_source_64 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_61_p_struct_declaration_1(  );
    assert( var_p_struct_declaration_1 == NULL );
    var_p_struct_declaration_1 = tmp_assign_source_64;

    tmp_assign_source_65 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_62_p_struct_declaration_2(  );
    assert( var_p_struct_declaration_2 == NULL );
    var_p_struct_declaration_2 = tmp_assign_source_65;

    tmp_assign_source_66 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_63_p_struct_declarator_list(  );
    assert( var_p_struct_declarator_list == NULL );
    var_p_struct_declarator_list = tmp_assign_source_66;

    tmp_assign_source_67 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_64_p_struct_declarator_1(  );
    assert( var_p_struct_declarator_1 == NULL );
    var_p_struct_declarator_1 = tmp_assign_source_67;

    tmp_assign_source_68 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_65_p_struct_declarator_2(  );
    assert( var_p_struct_declarator_2 == NULL );
    var_p_struct_declarator_2 = tmp_assign_source_68;

    tmp_assign_source_69 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_66_p_enum_specifier_1(  );
    assert( var_p_enum_specifier_1 == NULL );
    var_p_enum_specifier_1 = tmp_assign_source_69;

    tmp_assign_source_70 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_67_p_enum_specifier_2(  );
    assert( var_p_enum_specifier_2 == NULL );
    var_p_enum_specifier_2 = tmp_assign_source_70;

    tmp_assign_source_71 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_68_p_enum_specifier_3(  );
    assert( var_p_enum_specifier_3 == NULL );
    var_p_enum_specifier_3 = tmp_assign_source_71;

    tmp_assign_source_72 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_69_p_enumerator_list(  );
    assert( var_p_enumerator_list == NULL );
    var_p_enumerator_list = tmp_assign_source_72;

    tmp_assign_source_73 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_70_p_enumerator(  );
    assert( var_p_enumerator == NULL );
    var_p_enumerator = tmp_assign_source_73;

    tmp_assign_source_74 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_71_p_declarator(  );
    assert( var_p_declarator == NULL );
    var_p_declarator = tmp_assign_source_74;

    tmp_called_name_2 = PyDict_GetItem( locals_dict, const_str_plain_parameterized );

    if ( tmp_called_name_2 == NULL )
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_parameterized );

        if (unlikely( tmp_called_name_2 == NULL ))
        {
            tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parameterized );
        }

        if ( tmp_called_name_2 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parameterized" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1017;
            type_description = "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
            goto frame_exception_exit_1;
        }

    }

    frame_81959b19e2f92da45fb0e4a88b971619->m_frame.f_lineno = 1017;
    tmp_called_name_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_2, &PyTuple_GET_ITEM( const_tuple_f1ccb3db058b3624653c84c90fc9f384_tuple, 0 ) );

    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1017;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_72_p_xxx_declarator_1(  );
    frame_81959b19e2f92da45fb0e4a88b971619->m_frame.f_lineno = 1017;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_75 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_75 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1017;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_p_xxx_declarator_1 == NULL );
    var_p_xxx_declarator_1 = tmp_assign_source_75;

    tmp_called_name_4 = PyDict_GetItem( locals_dict, const_str_plain_parameterized );

    if ( tmp_called_name_4 == NULL )
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_parameterized );

        if (unlikely( tmp_called_name_4 == NULL ))
        {
            tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parameterized );
        }

        if ( tmp_called_name_4 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parameterized" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1023;
            type_description = "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
            goto frame_exception_exit_1;
        }

    }

    frame_81959b19e2f92da45fb0e4a88b971619->m_frame.f_lineno = 1023;
    tmp_called_name_3 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_4, &PyTuple_GET_ITEM( const_tuple_f1ccb3db058b3624653c84c90fc9f384_tuple, 0 ) );

    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1023;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_73_p_xxx_declarator_2(  );
    frame_81959b19e2f92da45fb0e4a88b971619->m_frame.f_lineno = 1023;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_assign_source_76 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_76 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1023;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_p_xxx_declarator_2 == NULL );
    var_p_xxx_declarator_2 = tmp_assign_source_76;

    tmp_called_name_6 = PyDict_GetItem( locals_dict, const_str_plain_parameterized );

    if ( tmp_called_name_6 == NULL )
    {
        tmp_called_name_6 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_parameterized );

        if (unlikely( tmp_called_name_6 == NULL ))
        {
            tmp_called_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parameterized );
        }

        if ( tmp_called_name_6 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parameterized" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1029;
            type_description = "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
            goto frame_exception_exit_1;
        }

    }

    frame_81959b19e2f92da45fb0e4a88b971619->m_frame.f_lineno = 1029;
    tmp_called_name_5 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_6, &PyTuple_GET_ITEM( const_tuple_f1ccb3db058b3624653c84c90fc9f384_tuple, 0 ) );

    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1029;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_74_p_direct_xxx_declarator_1(  );
    frame_81959b19e2f92da45fb0e4a88b971619->m_frame.f_lineno = 1029;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_assign_source_77 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_assign_source_77 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1029;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_p_direct_xxx_declarator_1 == NULL );
    var_p_direct_xxx_declarator_1 = tmp_assign_source_77;

    tmp_called_name_8 = PyDict_GetItem( locals_dict, const_str_plain_parameterized );

    if ( tmp_called_name_8 == NULL )
    {
        tmp_called_name_8 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_parameterized );

        if (unlikely( tmp_called_name_8 == NULL ))
        {
            tmp_called_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parameterized );
        }

        if ( tmp_called_name_8 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parameterized" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1039;
            type_description = "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
            goto frame_exception_exit_1;
        }

    }

    frame_81959b19e2f92da45fb0e4a88b971619->m_frame.f_lineno = 1039;
    tmp_called_name_7 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_8, &PyTuple_GET_ITEM( const_tuple_751da5b1a920ae509d273d698c85b4d3_tuple, 0 ) );

    if ( tmp_called_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1039;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_75_p_direct_xxx_declarator_2(  );
    frame_81959b19e2f92da45fb0e4a88b971619->m_frame.f_lineno = 1039;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_assign_source_78 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_7, call_args );
    }

    Py_DECREF( tmp_called_name_7 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_assign_source_78 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1039;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_p_direct_xxx_declarator_2 == NULL );
    var_p_direct_xxx_declarator_2 = tmp_assign_source_78;

    tmp_called_name_10 = PyDict_GetItem( locals_dict, const_str_plain_parameterized );

    if ( tmp_called_name_10 == NULL )
    {
        tmp_called_name_10 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_parameterized );

        if (unlikely( tmp_called_name_10 == NULL ))
        {
            tmp_called_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parameterized );
        }

        if ( tmp_called_name_10 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parameterized" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1045;
            type_description = "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
            goto frame_exception_exit_1;
        }

    }

    frame_81959b19e2f92da45fb0e4a88b971619->m_frame.f_lineno = 1045;
    tmp_called_name_9 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_10, &PyTuple_GET_ITEM( const_tuple_f1ccb3db058b3624653c84c90fc9f384_tuple, 0 ) );

    if ( tmp_called_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1045;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_5 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_76_p_direct_xxx_declarator_3(  );
    frame_81959b19e2f92da45fb0e4a88b971619->m_frame.f_lineno = 1045;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_assign_source_79 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_9, call_args );
    }

    Py_DECREF( tmp_called_name_9 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_assign_source_79 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1045;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_p_direct_xxx_declarator_3 == NULL );
    var_p_direct_xxx_declarator_3 = tmp_assign_source_79;

    tmp_called_name_12 = PyDict_GetItem( locals_dict, const_str_plain_parameterized );

    if ( tmp_called_name_12 == NULL )
    {
        tmp_called_name_12 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_parameterized );

        if (unlikely( tmp_called_name_12 == NULL ))
        {
            tmp_called_name_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parameterized );
        }

        if ( tmp_called_name_12 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parameterized" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1060;
            type_description = "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
            goto frame_exception_exit_1;
        }

    }

    frame_81959b19e2f92da45fb0e4a88b971619->m_frame.f_lineno = 1060;
    tmp_called_name_11 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_12, &PyTuple_GET_ITEM( const_tuple_f1ccb3db058b3624653c84c90fc9f384_tuple, 0 ) );

    if ( tmp_called_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1060;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_6 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_77_p_direct_xxx_declarator_4(  );
    frame_81959b19e2f92da45fb0e4a88b971619->m_frame.f_lineno = 1060;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_assign_source_80 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_11, call_args );
    }

    Py_DECREF( tmp_called_name_11 );
    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_assign_source_80 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1060;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_p_direct_xxx_declarator_4 == NULL );
    var_p_direct_xxx_declarator_4 = tmp_assign_source_80;

    tmp_called_name_14 = PyDict_GetItem( locals_dict, const_str_plain_parameterized );

    if ( tmp_called_name_14 == NULL )
    {
        tmp_called_name_14 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_parameterized );

        if (unlikely( tmp_called_name_14 == NULL ))
        {
            tmp_called_name_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parameterized );
        }

        if ( tmp_called_name_14 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parameterized" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1082;
            type_description = "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
            goto frame_exception_exit_1;
        }

    }

    frame_81959b19e2f92da45fb0e4a88b971619->m_frame.f_lineno = 1082;
    tmp_called_name_13 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_14, &PyTuple_GET_ITEM( const_tuple_f1ccb3db058b3624653c84c90fc9f384_tuple, 0 ) );

    if ( tmp_called_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1082;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_7 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_78_p_direct_xxx_declarator_5(  );
    frame_81959b19e2f92da45fb0e4a88b971619->m_frame.f_lineno = 1082;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_assign_source_81 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_13, call_args );
    }

    Py_DECREF( tmp_called_name_13 );
    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_assign_source_81 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1082;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_p_direct_xxx_declarator_5 == NULL );
    var_p_direct_xxx_declarator_5 = tmp_assign_source_81;

    tmp_called_name_16 = PyDict_GetItem( locals_dict, const_str_plain_parameterized );

    if ( tmp_called_name_16 == NULL )
    {
        tmp_called_name_16 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_parameterized );

        if (unlikely( tmp_called_name_16 == NULL ))
        {
            tmp_called_name_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_parameterized );
        }

        if ( tmp_called_name_16 == NULL )
        {

            exception_type = PyExc_NameError;
            Py_INCREF( exception_type );
            exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "parameterized" );
            exception_tb = NULL;
            NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
            CHAIN_EXCEPTION( exception_value );

            exception_lineno = 1094;
            type_description = "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
            goto frame_exception_exit_1;
        }

    }

    frame_81959b19e2f92da45fb0e4a88b971619->m_frame.f_lineno = 1094;
    tmp_called_name_15 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_16, &PyTuple_GET_ITEM( const_tuple_f1ccb3db058b3624653c84c90fc9f384_tuple, 0 ) );

    if ( tmp_called_name_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1094;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_8 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_79_p_direct_xxx_declarator_6(  );
    frame_81959b19e2f92da45fb0e4a88b971619->m_frame.f_lineno = 1094;
    {
        PyObject *call_args[] = { tmp_args_element_name_8 };
        tmp_assign_source_82 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_15, call_args );
    }

    Py_DECREF( tmp_called_name_15 );
    Py_DECREF( tmp_args_element_name_8 );
    if ( tmp_assign_source_82 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1094;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_p_direct_xxx_declarator_6 == NULL );
    var_p_direct_xxx_declarator_6 = tmp_assign_source_82;


#if 0
    RESTORE_FRAME_EXCEPTION( frame_81959b19e2f92da45fb0e4a88b971619 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_81959b19e2f92da45fb0e4a88b971619 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_81959b19e2f92da45fb0e4a88b971619, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_81959b19e2f92da45fb0e4a88b971619->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_81959b19e2f92da45fb0e4a88b971619, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_81959b19e2f92da45fb0e4a88b971619, type_description ,var___class__, var___qualname__, var___module__, var___init__, var_parse, var__push_scope, var__pop_scope, var__add_typedef_name, var__add_identifier, var__is_type_in_scope, var__lex_error_func, var__lex_on_lbrace_func, var__lex_on_rbrace_func, var__lex_type_lookup_func, var__get_yacc_lookahead_token, var__type_modify_decl, var__fix_decl_name_type, var__add_declaration_specifier, var__build_declarations, var__build_function_definition, var__select_struct_union_class, var_precedence, var_p_translation_unit_or_empty, var_p_translation_unit_1, var_p_translation_unit_2, var_p_external_declaration_1, var_p_external_declaration_2, var_p_external_declaration_3, var_p_external_declaration_4, var_p_pp_directive, var_p_pppragma_directive, var_p_function_definition_1, var_p_function_definition_2, var_p_statement, var_p_decl_body, var_p_declaration, var_p_declaration_list, var_p_declaration_specifiers_no_type_1, var_p_declaration_specifiers_no_type_2, var_p_declaration_specifiers_no_type_3, var_p_declaration_specifiers_1, var_p_declaration_specifiers_2, var_p_declaration_specifiers_3, var_p_declaration_specifiers_4, var_p_declaration_specifiers_5, var_p_declaration_specifiers_6, var_p_storage_class_specifier, var_p_function_specifier, var_p_type_specifier_no_typeid, var_p_type_specifier, var_p_type_qualifier, var_p_init_declarator_list, var_p_init_declarator, var_p_id_init_declarator_list, var_p_id_init_declarator, var_p_specifier_qualifier_list_1, var_p_specifier_qualifier_list_2, var_p_specifier_qualifier_list_3, var_p_specifier_qualifier_list_4, var_p_struct_or_union_specifier_1, var_p_struct_or_union_specifier_2, var_p_struct_or_union_specifier_3, var_p_struct_or_union, var_p_struct_declaration_list, var_p_struct_declaration_1, var_p_struct_declaration_2, var_p_struct_declarator_list, var_p_struct_declarator_1, var_p_struct_declarator_2, var_p_enum_specifier_1, var_p_enum_specifier_2, var_p_enum_specifier_3, var_p_enumerator_list, var_p_enumerator, var_p_declarator, var_p_xxx_declarator_1, var_p_xxx_declarator_2, var_p_direct_xxx_declarator_1, var_p_direct_xxx_declarator_2, var_p_direct_xxx_declarator_3, var_p_direct_xxx_declarator_4, var_p_direct_xxx_declarator_5, var_p_direct_xxx_declarator_6, var_p_pointer, var_p_type_qualifier_list, var_p_parameter_type_list, var_p_parameter_list, var_p_parameter_declaration_1, var_p_parameter_declaration_2, var_p_identifier_list, var_p_initializer_1, var_p_initializer_2, var_p_initializer_list, var_p_designation, var_p_designator_list, var_p_designator, var_p_type_name, var_p_abstract_declarator_1, var_p_abstract_declarator_2, var_p_abstract_declarator_3, var_p_direct_abstract_declarator_1, var_p_direct_abstract_declarator_2, var_p_direct_abstract_declarator_3, var_p_direct_abstract_declarator_4, var_p_direct_abstract_declarator_5, var_p_direct_abstract_declarator_6, var_p_direct_abstract_declarator_7, var_p_block_item, var_p_block_item_list, var_p_compound_statement_1, var_p_labeled_statement_1, var_p_labeled_statement_2, var_p_labeled_statement_3, var_p_selection_statement_1, var_p_selection_statement_2, var_p_selection_statement_3, var_p_iteration_statement_1, var_p_iteration_statement_2, var_p_iteration_statement_3, var_p_iteration_statement_4, var_p_jump_statement_1, var_p_jump_statement_2, var_p_jump_statement_3, var_p_jump_statement_4, var_p_expression_statement, var_p_expression, var_p_typedef_name, var_p_assignment_expression, var_p_assignment_operator, var_p_constant_expression, var_p_conditional_expression, var_p_binary_expression, var_p_cast_expression_1, var_p_cast_expression_2, var_p_unary_expression_1, var_p_unary_expression_2, var_p_unary_expression_3, var_p_unary_operator, var_p_postfix_expression_1, var_p_postfix_expression_2, var_p_postfix_expression_3, var_p_postfix_expression_4, var_p_postfix_expression_5, var_p_postfix_expression_6, var_p_primary_expression_1, var_p_primary_expression_2, var_p_primary_expression_3, var_p_primary_expression_4, var_p_primary_expression_5, var_p_offsetof_member_designator, var_p_argument_expression_list, var_p_identifier, var_p_constant_1, var_p_constant_2, var_p_constant_3, var_p_unified_string_literal, var_p_unified_wstring_literal, var_p_brace_open, var_p_brace_close, var_p_empty, var_p_error );

    // Release cached frame.
    if ( frame_81959b19e2f92da45fb0e4a88b971619 == cache_frame_81959b19e2f92da45fb0e4a88b971619 )
    {
        Py_DECREF( frame_81959b19e2f92da45fb0e4a88b971619 );
    }
    cache_frame_81959b19e2f92da45fb0e4a88b971619 = NULL;

    assertFrameObject( frame_81959b19e2f92da45fb0e4a88b971619 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_assign_source_83 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_80_p_pointer(  );
    assert( var_p_pointer == NULL );
    var_p_pointer = tmp_assign_source_83;

    tmp_assign_source_84 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_81_p_type_qualifier_list(  );
    assert( var_p_type_qualifier_list == NULL );
    var_p_type_qualifier_list = tmp_assign_source_84;

    tmp_assign_source_85 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_82_p_parameter_type_list(  );
    assert( var_p_parameter_type_list == NULL );
    var_p_parameter_type_list = tmp_assign_source_85;

    tmp_assign_source_86 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_83_p_parameter_list(  );
    assert( var_p_parameter_list == NULL );
    var_p_parameter_list = tmp_assign_source_86;

    tmp_assign_source_87 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_84_p_parameter_declaration_1(  );
    assert( var_p_parameter_declaration_1 == NULL );
    var_p_parameter_declaration_1 = tmp_assign_source_87;

    tmp_assign_source_88 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_85_p_parameter_declaration_2(  );
    assert( var_p_parameter_declaration_2 == NULL );
    var_p_parameter_declaration_2 = tmp_assign_source_88;

    tmp_assign_source_89 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_86_p_identifier_list(  );
    assert( var_p_identifier_list == NULL );
    var_p_identifier_list = tmp_assign_source_89;

    tmp_assign_source_90 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_87_p_initializer_1(  );
    assert( var_p_initializer_1 == NULL );
    var_p_initializer_1 = tmp_assign_source_90;

    tmp_assign_source_91 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_88_p_initializer_2(  );
    assert( var_p_initializer_2 == NULL );
    var_p_initializer_2 = tmp_assign_source_91;

    tmp_assign_source_92 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_89_p_initializer_list(  );
    assert( var_p_initializer_list == NULL );
    var_p_initializer_list = tmp_assign_source_92;

    tmp_assign_source_93 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_90_p_designation(  );
    assert( var_p_designation == NULL );
    var_p_designation = tmp_assign_source_93;

    tmp_assign_source_94 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_91_p_designator_list(  );
    assert( var_p_designator_list == NULL );
    var_p_designator_list = tmp_assign_source_94;

    tmp_assign_source_95 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_92_p_designator(  );
    assert( var_p_designator == NULL );
    var_p_designator = tmp_assign_source_95;

    tmp_assign_source_96 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_93_p_type_name(  );
    assert( var_p_type_name == NULL );
    var_p_type_name = tmp_assign_source_96;

    tmp_assign_source_97 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_94_p_abstract_declarator_1(  );
    assert( var_p_abstract_declarator_1 == NULL );
    var_p_abstract_declarator_1 = tmp_assign_source_97;

    tmp_assign_source_98 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_95_p_abstract_declarator_2(  );
    assert( var_p_abstract_declarator_2 == NULL );
    var_p_abstract_declarator_2 = tmp_assign_source_98;

    tmp_assign_source_99 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_96_p_abstract_declarator_3(  );
    assert( var_p_abstract_declarator_3 == NULL );
    var_p_abstract_declarator_3 = tmp_assign_source_99;

    tmp_assign_source_100 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_97_p_direct_abstract_declarator_1(  );
    assert( var_p_direct_abstract_declarator_1 == NULL );
    var_p_direct_abstract_declarator_1 = tmp_assign_source_100;

    tmp_assign_source_101 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_98_p_direct_abstract_declarator_2(  );
    assert( var_p_direct_abstract_declarator_2 == NULL );
    var_p_direct_abstract_declarator_2 = tmp_assign_source_101;

    tmp_assign_source_102 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_99_p_direct_abstract_declarator_3(  );
    assert( var_p_direct_abstract_declarator_3 == NULL );
    var_p_direct_abstract_declarator_3 = tmp_assign_source_102;

    tmp_assign_source_103 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_100_p_direct_abstract_declarator_4(  );
    assert( var_p_direct_abstract_declarator_4 == NULL );
    var_p_direct_abstract_declarator_4 = tmp_assign_source_103;

    tmp_assign_source_104 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_101_p_direct_abstract_declarator_5(  );
    assert( var_p_direct_abstract_declarator_5 == NULL );
    var_p_direct_abstract_declarator_5 = tmp_assign_source_104;

    tmp_assign_source_105 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_102_p_direct_abstract_declarator_6(  );
    assert( var_p_direct_abstract_declarator_6 == NULL );
    var_p_direct_abstract_declarator_6 = tmp_assign_source_105;

    tmp_assign_source_106 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_103_p_direct_abstract_declarator_7(  );
    assert( var_p_direct_abstract_declarator_7 == NULL );
    var_p_direct_abstract_declarator_7 = tmp_assign_source_106;

    tmp_assign_source_107 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_104_p_block_item(  );
    assert( var_p_block_item == NULL );
    var_p_block_item = tmp_assign_source_107;

    tmp_assign_source_108 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_105_p_block_item_list(  );
    assert( var_p_block_item_list == NULL );
    var_p_block_item_list = tmp_assign_source_108;

    tmp_assign_source_109 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_106_p_compound_statement_1(  );
    assert( var_p_compound_statement_1 == NULL );
    var_p_compound_statement_1 = tmp_assign_source_109;

    tmp_assign_source_110 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_107_p_labeled_statement_1(  );
    assert( var_p_labeled_statement_1 == NULL );
    var_p_labeled_statement_1 = tmp_assign_source_110;

    tmp_assign_source_111 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_108_p_labeled_statement_2(  );
    assert( var_p_labeled_statement_2 == NULL );
    var_p_labeled_statement_2 = tmp_assign_source_111;

    tmp_assign_source_112 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_109_p_labeled_statement_3(  );
    assert( var_p_labeled_statement_3 == NULL );
    var_p_labeled_statement_3 = tmp_assign_source_112;

    tmp_assign_source_113 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_110_p_selection_statement_1(  );
    assert( var_p_selection_statement_1 == NULL );
    var_p_selection_statement_1 = tmp_assign_source_113;

    tmp_assign_source_114 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_111_p_selection_statement_2(  );
    assert( var_p_selection_statement_2 == NULL );
    var_p_selection_statement_2 = tmp_assign_source_114;

    tmp_assign_source_115 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_112_p_selection_statement_3(  );
    assert( var_p_selection_statement_3 == NULL );
    var_p_selection_statement_3 = tmp_assign_source_115;

    tmp_assign_source_116 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_113_p_iteration_statement_1(  );
    assert( var_p_iteration_statement_1 == NULL );
    var_p_iteration_statement_1 = tmp_assign_source_116;

    tmp_assign_source_117 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_114_p_iteration_statement_2(  );
    assert( var_p_iteration_statement_2 == NULL );
    var_p_iteration_statement_2 = tmp_assign_source_117;

    tmp_assign_source_118 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_115_p_iteration_statement_3(  );
    assert( var_p_iteration_statement_3 == NULL );
    var_p_iteration_statement_3 = tmp_assign_source_118;

    tmp_assign_source_119 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_116_p_iteration_statement_4(  );
    assert( var_p_iteration_statement_4 == NULL );
    var_p_iteration_statement_4 = tmp_assign_source_119;

    tmp_assign_source_120 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_117_p_jump_statement_1(  );
    assert( var_p_jump_statement_1 == NULL );
    var_p_jump_statement_1 = tmp_assign_source_120;

    tmp_assign_source_121 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_118_p_jump_statement_2(  );
    assert( var_p_jump_statement_2 == NULL );
    var_p_jump_statement_2 = tmp_assign_source_121;

    tmp_assign_source_122 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_119_p_jump_statement_3(  );
    assert( var_p_jump_statement_3 == NULL );
    var_p_jump_statement_3 = tmp_assign_source_122;

    tmp_assign_source_123 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_120_p_jump_statement_4(  );
    assert( var_p_jump_statement_4 == NULL );
    var_p_jump_statement_4 = tmp_assign_source_123;

    tmp_assign_source_124 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_121_p_expression_statement(  );
    assert( var_p_expression_statement == NULL );
    var_p_expression_statement = tmp_assign_source_124;

    tmp_assign_source_125 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_122_p_expression(  );
    assert( var_p_expression == NULL );
    var_p_expression = tmp_assign_source_125;

    tmp_assign_source_126 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_123_p_typedef_name(  );
    assert( var_p_typedef_name == NULL );
    var_p_typedef_name = tmp_assign_source_126;

    tmp_assign_source_127 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_124_p_assignment_expression(  );
    assert( var_p_assignment_expression == NULL );
    var_p_assignment_expression = tmp_assign_source_127;

    tmp_assign_source_128 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_125_p_assignment_operator(  );
    assert( var_p_assignment_operator == NULL );
    var_p_assignment_operator = tmp_assign_source_128;

    tmp_assign_source_129 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_126_p_constant_expression(  );
    assert( var_p_constant_expression == NULL );
    var_p_constant_expression = tmp_assign_source_129;

    tmp_assign_source_130 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_127_p_conditional_expression(  );
    assert( var_p_conditional_expression == NULL );
    var_p_conditional_expression = tmp_assign_source_130;

    tmp_assign_source_131 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_128_p_binary_expression(  );
    assert( var_p_binary_expression == NULL );
    var_p_binary_expression = tmp_assign_source_131;

    tmp_assign_source_132 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_129_p_cast_expression_1(  );
    assert( var_p_cast_expression_1 == NULL );
    var_p_cast_expression_1 = tmp_assign_source_132;

    tmp_assign_source_133 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_130_p_cast_expression_2(  );
    assert( var_p_cast_expression_2 == NULL );
    var_p_cast_expression_2 = tmp_assign_source_133;

    tmp_assign_source_134 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_131_p_unary_expression_1(  );
    assert( var_p_unary_expression_1 == NULL );
    var_p_unary_expression_1 = tmp_assign_source_134;

    tmp_assign_source_135 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_132_p_unary_expression_2(  );
    assert( var_p_unary_expression_2 == NULL );
    var_p_unary_expression_2 = tmp_assign_source_135;

    tmp_assign_source_136 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_133_p_unary_expression_3(  );
    assert( var_p_unary_expression_3 == NULL );
    var_p_unary_expression_3 = tmp_assign_source_136;

    tmp_assign_source_137 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_134_p_unary_operator(  );
    assert( var_p_unary_operator == NULL );
    var_p_unary_operator = tmp_assign_source_137;

    tmp_assign_source_138 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_135_p_postfix_expression_1(  );
    assert( var_p_postfix_expression_1 == NULL );
    var_p_postfix_expression_1 = tmp_assign_source_138;

    tmp_assign_source_139 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_136_p_postfix_expression_2(  );
    assert( var_p_postfix_expression_2 == NULL );
    var_p_postfix_expression_2 = tmp_assign_source_139;

    tmp_assign_source_140 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_137_p_postfix_expression_3(  );
    assert( var_p_postfix_expression_3 == NULL );
    var_p_postfix_expression_3 = tmp_assign_source_140;

    tmp_assign_source_141 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_138_p_postfix_expression_4(  );
    assert( var_p_postfix_expression_4 == NULL );
    var_p_postfix_expression_4 = tmp_assign_source_141;

    tmp_assign_source_142 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_139_p_postfix_expression_5(  );
    assert( var_p_postfix_expression_5 == NULL );
    var_p_postfix_expression_5 = tmp_assign_source_142;

    tmp_assign_source_143 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_140_p_postfix_expression_6(  );
    assert( var_p_postfix_expression_6 == NULL );
    var_p_postfix_expression_6 = tmp_assign_source_143;

    tmp_assign_source_144 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_141_p_primary_expression_1(  );
    assert( var_p_primary_expression_1 == NULL );
    var_p_primary_expression_1 = tmp_assign_source_144;

    tmp_assign_source_145 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_142_p_primary_expression_2(  );
    assert( var_p_primary_expression_2 == NULL );
    var_p_primary_expression_2 = tmp_assign_source_145;

    tmp_assign_source_146 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_143_p_primary_expression_3(  );
    assert( var_p_primary_expression_3 == NULL );
    var_p_primary_expression_3 = tmp_assign_source_146;

    tmp_assign_source_147 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_144_p_primary_expression_4(  );
    assert( var_p_primary_expression_4 == NULL );
    var_p_primary_expression_4 = tmp_assign_source_147;

    tmp_assign_source_148 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_145_p_primary_expression_5(  );
    assert( var_p_primary_expression_5 == NULL );
    var_p_primary_expression_5 = tmp_assign_source_148;

    tmp_assign_source_149 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_146_p_offsetof_member_designator(  );
    assert( var_p_offsetof_member_designator == NULL );
    var_p_offsetof_member_designator = tmp_assign_source_149;

    tmp_assign_source_150 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_147_p_argument_expression_list(  );
    assert( var_p_argument_expression_list == NULL );
    var_p_argument_expression_list = tmp_assign_source_150;

    tmp_assign_source_151 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_148_p_identifier(  );
    assert( var_p_identifier == NULL );
    var_p_identifier = tmp_assign_source_151;

    tmp_assign_source_152 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_149_p_constant_1(  );
    assert( var_p_constant_1 == NULL );
    var_p_constant_1 = tmp_assign_source_152;

    tmp_assign_source_153 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_150_p_constant_2(  );
    assert( var_p_constant_2 == NULL );
    var_p_constant_2 = tmp_assign_source_153;

    tmp_assign_source_154 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_151_p_constant_3(  );
    assert( var_p_constant_3 == NULL );
    var_p_constant_3 = tmp_assign_source_154;

    tmp_assign_source_155 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_152_p_unified_string_literal(  );
    assert( var_p_unified_string_literal == NULL );
    var_p_unified_string_literal = tmp_assign_source_155;

    tmp_assign_source_156 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_153_p_unified_wstring_literal(  );
    assert( var_p_unified_wstring_literal == NULL );
    var_p_unified_wstring_literal = tmp_assign_source_156;

    tmp_assign_source_157 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_154_p_brace_open(  );
    assert( var_p_brace_open == NULL );
    var_p_brace_open = tmp_assign_source_157;

    tmp_assign_source_158 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_155_p_brace_close(  );
    assert( var_p_brace_close == NULL );
    var_p_brace_close = tmp_assign_source_158;

    tmp_assign_source_159 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_156_p_empty(  );
    assert( var_p_empty == NULL );
    var_p_empty = tmp_assign_source_159;

    tmp_assign_source_160 = MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_157_p_error(  );
    assert( var_p_error == NULL );
    var_p_error = tmp_assign_source_160;

    tmp_called_name_17 = *closure_pycparser$c_parser_class_creation_1__metaclass;

    CHECK_OBJECT( tmp_called_name_17 );
    tmp_args_name_1 = PyTuple_New( 3 );
    tmp_tuple_element_2 = const_str_plain_CParser;
    Py_INCREF( tmp_tuple_element_2 );
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_2 );
    tmp_tuple_element_2 = *closure_pycparser$c_parser_class_creation_1__bases;

    CHECK_OBJECT( tmp_tuple_element_2 );
    Py_INCREF( tmp_tuple_element_2 );
    PyTuple_SET_ITEM( tmp_args_name_1, 1, tmp_tuple_element_2 );
    tmp_tuple_element_2 = locals_dict;
    Py_INCREF( locals_dict );
    if ( var___qualname__ != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain___qualname__,
            var___qualname__
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain___qualname__
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain___qualname__
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var___module__ != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain___module__,
            var___module__
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain___module__
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain___module__
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var___init__ != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain___init__,
            var___init__
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain___init__
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain___init__
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_parse != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_parse,
            var_parse
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_parse
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_parse
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var__push_scope != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain__push_scope,
            var__push_scope
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain__push_scope
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain__push_scope
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var__pop_scope != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain__pop_scope,
            var__pop_scope
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain__pop_scope
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain__pop_scope
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var__add_typedef_name != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain__add_typedef_name,
            var__add_typedef_name
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain__add_typedef_name
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain__add_typedef_name
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var__add_identifier != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain__add_identifier,
            var__add_identifier
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain__add_identifier
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain__add_identifier
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var__is_type_in_scope != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain__is_type_in_scope,
            var__is_type_in_scope
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain__is_type_in_scope
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain__is_type_in_scope
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var__lex_error_func != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain__lex_error_func,
            var__lex_error_func
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain__lex_error_func
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain__lex_error_func
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var__lex_on_lbrace_func != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain__lex_on_lbrace_func,
            var__lex_on_lbrace_func
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain__lex_on_lbrace_func
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain__lex_on_lbrace_func
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var__lex_on_rbrace_func != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain__lex_on_rbrace_func,
            var__lex_on_rbrace_func
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain__lex_on_rbrace_func
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain__lex_on_rbrace_func
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var__lex_type_lookup_func != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain__lex_type_lookup_func,
            var__lex_type_lookup_func
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain__lex_type_lookup_func
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain__lex_type_lookup_func
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var__get_yacc_lookahead_token != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain__get_yacc_lookahead_token,
            var__get_yacc_lookahead_token
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain__get_yacc_lookahead_token
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain__get_yacc_lookahead_token
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var__type_modify_decl != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain__type_modify_decl,
            var__type_modify_decl
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain__type_modify_decl
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain__type_modify_decl
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var__fix_decl_name_type != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain__fix_decl_name_type,
            var__fix_decl_name_type
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain__fix_decl_name_type
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain__fix_decl_name_type
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var__add_declaration_specifier != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain__add_declaration_specifier,
            var__add_declaration_specifier
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain__add_declaration_specifier
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain__add_declaration_specifier
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var__build_declarations != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain__build_declarations,
            var__build_declarations
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain__build_declarations
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain__build_declarations
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var__build_function_definition != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain__build_function_definition,
            var__build_function_definition
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain__build_function_definition
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain__build_function_definition
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var__select_struct_union_class != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain__select_struct_union_class,
            var__select_struct_union_class
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain__select_struct_union_class
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain__select_struct_union_class
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_precedence != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_precedence,
            var_precedence
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_precedence
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_precedence
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_translation_unit_or_empty != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_translation_unit_or_empty,
            var_p_translation_unit_or_empty
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_translation_unit_or_empty
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_translation_unit_or_empty
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_translation_unit_1 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_translation_unit_1,
            var_p_translation_unit_1
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_translation_unit_1
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_translation_unit_1
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_translation_unit_2 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_translation_unit_2,
            var_p_translation_unit_2
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_translation_unit_2
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_translation_unit_2
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_external_declaration_1 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_external_declaration_1,
            var_p_external_declaration_1
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_external_declaration_1
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_external_declaration_1
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_external_declaration_2 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_external_declaration_2,
            var_p_external_declaration_2
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_external_declaration_2
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_external_declaration_2
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_external_declaration_3 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_external_declaration_3,
            var_p_external_declaration_3
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_external_declaration_3
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_external_declaration_3
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_external_declaration_4 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_external_declaration_4,
            var_p_external_declaration_4
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_external_declaration_4
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_external_declaration_4
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_pp_directive != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_pp_directive,
            var_p_pp_directive
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_pp_directive
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_pp_directive
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_pppragma_directive != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_pppragma_directive,
            var_p_pppragma_directive
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_pppragma_directive
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_pppragma_directive
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_function_definition_1 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_function_definition_1,
            var_p_function_definition_1
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_function_definition_1
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_function_definition_1
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_function_definition_2 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_function_definition_2,
            var_p_function_definition_2
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_function_definition_2
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_function_definition_2
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_statement != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_statement,
            var_p_statement
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_statement
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_statement
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_decl_body != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_decl_body,
            var_p_decl_body
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_decl_body
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_decl_body
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_declaration != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_declaration,
            var_p_declaration
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_declaration
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_declaration
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_declaration_list != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_declaration_list,
            var_p_declaration_list
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_declaration_list
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_declaration_list
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_declaration_specifiers_no_type_1 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_declaration_specifiers_no_type_1,
            var_p_declaration_specifiers_no_type_1
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_declaration_specifiers_no_type_1
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_declaration_specifiers_no_type_1
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_declaration_specifiers_no_type_2 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_declaration_specifiers_no_type_2,
            var_p_declaration_specifiers_no_type_2
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_declaration_specifiers_no_type_2
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_declaration_specifiers_no_type_2
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_declaration_specifiers_no_type_3 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_declaration_specifiers_no_type_3,
            var_p_declaration_specifiers_no_type_3
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_declaration_specifiers_no_type_3
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_declaration_specifiers_no_type_3
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_declaration_specifiers_1 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_declaration_specifiers_1,
            var_p_declaration_specifiers_1
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_declaration_specifiers_1
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_declaration_specifiers_1
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_declaration_specifiers_2 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_declaration_specifiers_2,
            var_p_declaration_specifiers_2
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_declaration_specifiers_2
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_declaration_specifiers_2
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_declaration_specifiers_3 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_declaration_specifiers_3,
            var_p_declaration_specifiers_3
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_declaration_specifiers_3
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_declaration_specifiers_3
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_declaration_specifiers_4 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_declaration_specifiers_4,
            var_p_declaration_specifiers_4
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_declaration_specifiers_4
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_declaration_specifiers_4
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_declaration_specifiers_5 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_declaration_specifiers_5,
            var_p_declaration_specifiers_5
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_declaration_specifiers_5
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_declaration_specifiers_5
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_declaration_specifiers_6 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_declaration_specifiers_6,
            var_p_declaration_specifiers_6
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_declaration_specifiers_6
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_declaration_specifiers_6
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_storage_class_specifier != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_storage_class_specifier,
            var_p_storage_class_specifier
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_storage_class_specifier
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_storage_class_specifier
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_function_specifier != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_function_specifier,
            var_p_function_specifier
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_function_specifier
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_function_specifier
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_type_specifier_no_typeid != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_type_specifier_no_typeid,
            var_p_type_specifier_no_typeid
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_type_specifier_no_typeid
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_type_specifier_no_typeid
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_type_specifier != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_type_specifier,
            var_p_type_specifier
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_type_specifier
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_type_specifier
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_type_qualifier != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_type_qualifier,
            var_p_type_qualifier
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_type_qualifier
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_type_qualifier
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_init_declarator_list != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_init_declarator_list,
            var_p_init_declarator_list
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_init_declarator_list
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_init_declarator_list
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_init_declarator != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_init_declarator,
            var_p_init_declarator
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_init_declarator
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_init_declarator
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_id_init_declarator_list != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_id_init_declarator_list,
            var_p_id_init_declarator_list
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_id_init_declarator_list
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_id_init_declarator_list
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_id_init_declarator != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_id_init_declarator,
            var_p_id_init_declarator
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_id_init_declarator
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_id_init_declarator
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_specifier_qualifier_list_1 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_specifier_qualifier_list_1,
            var_p_specifier_qualifier_list_1
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_specifier_qualifier_list_1
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_specifier_qualifier_list_1
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_specifier_qualifier_list_2 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_specifier_qualifier_list_2,
            var_p_specifier_qualifier_list_2
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_specifier_qualifier_list_2
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_specifier_qualifier_list_2
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_specifier_qualifier_list_3 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_specifier_qualifier_list_3,
            var_p_specifier_qualifier_list_3
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_specifier_qualifier_list_3
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_specifier_qualifier_list_3
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_specifier_qualifier_list_4 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_specifier_qualifier_list_4,
            var_p_specifier_qualifier_list_4
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_specifier_qualifier_list_4
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_specifier_qualifier_list_4
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_struct_or_union_specifier_1 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_struct_or_union_specifier_1,
            var_p_struct_or_union_specifier_1
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_struct_or_union_specifier_1
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_struct_or_union_specifier_1
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_struct_or_union_specifier_2 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_struct_or_union_specifier_2,
            var_p_struct_or_union_specifier_2
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_struct_or_union_specifier_2
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_struct_or_union_specifier_2
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_struct_or_union_specifier_3 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_struct_or_union_specifier_3,
            var_p_struct_or_union_specifier_3
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_struct_or_union_specifier_3
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_struct_or_union_specifier_3
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_struct_or_union != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_struct_or_union,
            var_p_struct_or_union
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_struct_or_union
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_struct_or_union
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_struct_declaration_list != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_struct_declaration_list,
            var_p_struct_declaration_list
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_struct_declaration_list
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_struct_declaration_list
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_struct_declaration_1 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_struct_declaration_1,
            var_p_struct_declaration_1
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_struct_declaration_1
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_struct_declaration_1
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_struct_declaration_2 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_struct_declaration_2,
            var_p_struct_declaration_2
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_struct_declaration_2
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_struct_declaration_2
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_struct_declarator_list != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_struct_declarator_list,
            var_p_struct_declarator_list
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_struct_declarator_list
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_struct_declarator_list
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_struct_declarator_1 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_struct_declarator_1,
            var_p_struct_declarator_1
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_struct_declarator_1
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_struct_declarator_1
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_struct_declarator_2 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_struct_declarator_2,
            var_p_struct_declarator_2
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_struct_declarator_2
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_struct_declarator_2
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_enum_specifier_1 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_enum_specifier_1,
            var_p_enum_specifier_1
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_enum_specifier_1
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_enum_specifier_1
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_enum_specifier_2 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_enum_specifier_2,
            var_p_enum_specifier_2
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_enum_specifier_2
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_enum_specifier_2
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_enum_specifier_3 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_enum_specifier_3,
            var_p_enum_specifier_3
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_enum_specifier_3
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_enum_specifier_3
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_enumerator_list != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_enumerator_list,
            var_p_enumerator_list
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_enumerator_list
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_enumerator_list
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_enumerator != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_enumerator,
            var_p_enumerator
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_enumerator
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_enumerator
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_declarator != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_declarator,
            var_p_declarator
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_declarator
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_declarator
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_xxx_declarator_1 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_xxx_declarator_1,
            var_p_xxx_declarator_1
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_xxx_declarator_1
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_xxx_declarator_1
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_xxx_declarator_2 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_xxx_declarator_2,
            var_p_xxx_declarator_2
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_xxx_declarator_2
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_xxx_declarator_2
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_direct_xxx_declarator_1 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_direct_xxx_declarator_1,
            var_p_direct_xxx_declarator_1
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_direct_xxx_declarator_1
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_direct_xxx_declarator_1
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_direct_xxx_declarator_2 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_direct_xxx_declarator_2,
            var_p_direct_xxx_declarator_2
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_direct_xxx_declarator_2
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_direct_xxx_declarator_2
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_direct_xxx_declarator_3 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_direct_xxx_declarator_3,
            var_p_direct_xxx_declarator_3
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_direct_xxx_declarator_3
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_direct_xxx_declarator_3
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_direct_xxx_declarator_4 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_direct_xxx_declarator_4,
            var_p_direct_xxx_declarator_4
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_direct_xxx_declarator_4
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_direct_xxx_declarator_4
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_direct_xxx_declarator_5 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_direct_xxx_declarator_5,
            var_p_direct_xxx_declarator_5
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_direct_xxx_declarator_5
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_direct_xxx_declarator_5
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_direct_xxx_declarator_6 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_direct_xxx_declarator_6,
            var_p_direct_xxx_declarator_6
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_direct_xxx_declarator_6
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_direct_xxx_declarator_6
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_pointer != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_pointer,
            var_p_pointer
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_pointer
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_pointer
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_type_qualifier_list != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_type_qualifier_list,
            var_p_type_qualifier_list
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_type_qualifier_list
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_type_qualifier_list
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_parameter_type_list != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_parameter_type_list,
            var_p_parameter_type_list
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_parameter_type_list
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_parameter_type_list
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_parameter_list != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_parameter_list,
            var_p_parameter_list
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_parameter_list
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_parameter_list
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_parameter_declaration_1 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_parameter_declaration_1,
            var_p_parameter_declaration_1
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_parameter_declaration_1
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_parameter_declaration_1
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_parameter_declaration_2 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_parameter_declaration_2,
            var_p_parameter_declaration_2
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_parameter_declaration_2
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_parameter_declaration_2
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_identifier_list != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_identifier_list,
            var_p_identifier_list
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_identifier_list
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_identifier_list
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_initializer_1 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_initializer_1,
            var_p_initializer_1
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_initializer_1
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_initializer_1
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_initializer_2 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_initializer_2,
            var_p_initializer_2
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_initializer_2
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_initializer_2
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_initializer_list != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_initializer_list,
            var_p_initializer_list
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_initializer_list
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_initializer_list
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_designation != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_designation,
            var_p_designation
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_designation
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_designation
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_designator_list != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_designator_list,
            var_p_designator_list
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_designator_list
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_designator_list
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_designator != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_designator,
            var_p_designator
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_designator
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_designator
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_type_name != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_type_name,
            var_p_type_name
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_type_name
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_type_name
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_abstract_declarator_1 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_abstract_declarator_1,
            var_p_abstract_declarator_1
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_abstract_declarator_1
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_abstract_declarator_1
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_abstract_declarator_2 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_abstract_declarator_2,
            var_p_abstract_declarator_2
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_abstract_declarator_2
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_abstract_declarator_2
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_abstract_declarator_3 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_abstract_declarator_3,
            var_p_abstract_declarator_3
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_abstract_declarator_3
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_abstract_declarator_3
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_direct_abstract_declarator_1 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_direct_abstract_declarator_1,
            var_p_direct_abstract_declarator_1
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_direct_abstract_declarator_1
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_direct_abstract_declarator_1
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_direct_abstract_declarator_2 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_direct_abstract_declarator_2,
            var_p_direct_abstract_declarator_2
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_direct_abstract_declarator_2
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_direct_abstract_declarator_2
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_direct_abstract_declarator_3 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_direct_abstract_declarator_3,
            var_p_direct_abstract_declarator_3
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_direct_abstract_declarator_3
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_direct_abstract_declarator_3
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_direct_abstract_declarator_4 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_direct_abstract_declarator_4,
            var_p_direct_abstract_declarator_4
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_direct_abstract_declarator_4
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_direct_abstract_declarator_4
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_direct_abstract_declarator_5 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_direct_abstract_declarator_5,
            var_p_direct_abstract_declarator_5
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_direct_abstract_declarator_5
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_direct_abstract_declarator_5
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_direct_abstract_declarator_6 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_direct_abstract_declarator_6,
            var_p_direct_abstract_declarator_6
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_direct_abstract_declarator_6
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_direct_abstract_declarator_6
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_direct_abstract_declarator_7 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_direct_abstract_declarator_7,
            var_p_direct_abstract_declarator_7
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_direct_abstract_declarator_7
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_direct_abstract_declarator_7
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_block_item != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_block_item,
            var_p_block_item
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_block_item
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_block_item
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_block_item_list != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_block_item_list,
            var_p_block_item_list
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_block_item_list
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_block_item_list
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_compound_statement_1 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_compound_statement_1,
            var_p_compound_statement_1
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_compound_statement_1
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_compound_statement_1
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_labeled_statement_1 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_labeled_statement_1,
            var_p_labeled_statement_1
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_labeled_statement_1
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_labeled_statement_1
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_labeled_statement_2 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_labeled_statement_2,
            var_p_labeled_statement_2
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_labeled_statement_2
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_labeled_statement_2
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_labeled_statement_3 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_labeled_statement_3,
            var_p_labeled_statement_3
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_labeled_statement_3
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_labeled_statement_3
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_selection_statement_1 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_selection_statement_1,
            var_p_selection_statement_1
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_selection_statement_1
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_selection_statement_1
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_selection_statement_2 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_selection_statement_2,
            var_p_selection_statement_2
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_selection_statement_2
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_selection_statement_2
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_selection_statement_3 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_selection_statement_3,
            var_p_selection_statement_3
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_selection_statement_3
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_selection_statement_3
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_iteration_statement_1 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_iteration_statement_1,
            var_p_iteration_statement_1
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_iteration_statement_1
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_iteration_statement_1
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_iteration_statement_2 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_iteration_statement_2,
            var_p_iteration_statement_2
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_iteration_statement_2
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_iteration_statement_2
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_iteration_statement_3 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_iteration_statement_3,
            var_p_iteration_statement_3
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_iteration_statement_3
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_iteration_statement_3
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_iteration_statement_4 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_iteration_statement_4,
            var_p_iteration_statement_4
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_iteration_statement_4
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_iteration_statement_4
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_jump_statement_1 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_jump_statement_1,
            var_p_jump_statement_1
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_jump_statement_1
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_jump_statement_1
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_jump_statement_2 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_jump_statement_2,
            var_p_jump_statement_2
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_jump_statement_2
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_jump_statement_2
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_jump_statement_3 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_jump_statement_3,
            var_p_jump_statement_3
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_jump_statement_3
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_jump_statement_3
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_jump_statement_4 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_jump_statement_4,
            var_p_jump_statement_4
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_jump_statement_4
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_jump_statement_4
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_expression_statement != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_expression_statement,
            var_p_expression_statement
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_expression_statement
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_expression_statement
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_expression != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_expression,
            var_p_expression
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_expression
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_expression
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_typedef_name != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_typedef_name,
            var_p_typedef_name
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_typedef_name
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_typedef_name
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_assignment_expression != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_assignment_expression,
            var_p_assignment_expression
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_assignment_expression
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_assignment_expression
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_assignment_operator != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_assignment_operator,
            var_p_assignment_operator
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_assignment_operator
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_assignment_operator
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_constant_expression != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_constant_expression,
            var_p_constant_expression
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_constant_expression
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_constant_expression
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_conditional_expression != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_conditional_expression,
            var_p_conditional_expression
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_conditional_expression
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_conditional_expression
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_binary_expression != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_binary_expression,
            var_p_binary_expression
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_binary_expression
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_binary_expression
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_cast_expression_1 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_cast_expression_1,
            var_p_cast_expression_1
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_cast_expression_1
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_cast_expression_1
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_cast_expression_2 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_cast_expression_2,
            var_p_cast_expression_2
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_cast_expression_2
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_cast_expression_2
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_unary_expression_1 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_unary_expression_1,
            var_p_unary_expression_1
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_unary_expression_1
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_unary_expression_1
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_unary_expression_2 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_unary_expression_2,
            var_p_unary_expression_2
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_unary_expression_2
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_unary_expression_2
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_unary_expression_3 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_unary_expression_3,
            var_p_unary_expression_3
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_unary_expression_3
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_unary_expression_3
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_unary_operator != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_unary_operator,
            var_p_unary_operator
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_unary_operator
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_unary_operator
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_postfix_expression_1 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_postfix_expression_1,
            var_p_postfix_expression_1
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_postfix_expression_1
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_postfix_expression_1
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_postfix_expression_2 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_postfix_expression_2,
            var_p_postfix_expression_2
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_postfix_expression_2
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_postfix_expression_2
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_postfix_expression_3 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_postfix_expression_3,
            var_p_postfix_expression_3
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_postfix_expression_3
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_postfix_expression_3
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_postfix_expression_4 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_postfix_expression_4,
            var_p_postfix_expression_4
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_postfix_expression_4
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_postfix_expression_4
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_postfix_expression_5 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_postfix_expression_5,
            var_p_postfix_expression_5
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_postfix_expression_5
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_postfix_expression_5
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_postfix_expression_6 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_postfix_expression_6,
            var_p_postfix_expression_6
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_postfix_expression_6
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_postfix_expression_6
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_primary_expression_1 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_primary_expression_1,
            var_p_primary_expression_1
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_primary_expression_1
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_primary_expression_1
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_primary_expression_2 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_primary_expression_2,
            var_p_primary_expression_2
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_primary_expression_2
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_primary_expression_2
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_primary_expression_3 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_primary_expression_3,
            var_p_primary_expression_3
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_primary_expression_3
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_primary_expression_3
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_primary_expression_4 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_primary_expression_4,
            var_p_primary_expression_4
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_primary_expression_4
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_primary_expression_4
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_primary_expression_5 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_primary_expression_5,
            var_p_primary_expression_5
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_primary_expression_5
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_primary_expression_5
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_offsetof_member_designator != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_offsetof_member_designator,
            var_p_offsetof_member_designator
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_offsetof_member_designator
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_offsetof_member_designator
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_argument_expression_list != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_argument_expression_list,
            var_p_argument_expression_list
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_argument_expression_list
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_argument_expression_list
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_identifier != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_identifier,
            var_p_identifier
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_identifier
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_identifier
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_constant_1 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_constant_1,
            var_p_constant_1
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_constant_1
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_constant_1
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_constant_2 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_constant_2,
            var_p_constant_2
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_constant_2
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_constant_2
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_constant_3 != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_constant_3,
            var_p_constant_3
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_constant_3
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_constant_3
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_unified_string_literal != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_unified_string_literal,
            var_p_unified_string_literal
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_unified_string_literal
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_unified_string_literal
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_unified_wstring_literal != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_unified_wstring_literal,
            var_p_unified_wstring_literal
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_unified_wstring_literal
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_unified_wstring_literal
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_brace_open != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_brace_open,
            var_p_brace_open
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_brace_open
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_brace_open
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_brace_close != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_brace_close,
            var_p_brace_close
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_brace_close
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_brace_close
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_empty != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_empty,
            var_p_empty
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_empty
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_empty
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    if ( var_p_error != NULL )
    {
        int res = PyObject_SetItem(
            tmp_tuple_element_2,
            const_str_plain_p_error,
            var_p_error
        );

        tmp_result = res == 0;
    }
    else
    {
        PyObject *test_value = PyObject_GetItem(
            tmp_tuple_element_2,
            const_str_plain_p_error
        );

        if ( test_value )
        {
            Py_DECREF( test_value );

            int res = PyObject_DelItem(
                tmp_tuple_element_2,
                const_str_plain_p_error
            );

            tmp_result = res == 0;
        }
        else
        {
            CLEAR_ERROR_OCCURRED();
            tmp_result = true;
        }
    }

    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_2 );



        goto try_except_handler_1;
    }
    PyTuple_SET_ITEM( tmp_args_name_1, 2, tmp_tuple_element_2 );
    tmp_kw_name_1 = *closure_pycparser$c_parser_class_creation_1__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_1 );
    tmp_assign_source_161 = CALL_FUNCTION( tmp_called_name_17, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_args_name_1 );
    if ( tmp_assign_source_161 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );




        goto try_except_handler_1;
    }
    assert( var___class__ == NULL );
    var___class__ = tmp_assign_source_161;

    tmp_return_value = var___class__;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var___class__ );
    Py_DECREF( var___class__ );
    var___class__ = NULL;

    Py_XDECREF( var___qualname__ );
    var___qualname__ = NULL;

    Py_XDECREF( var___module__ );
    var___module__ = NULL;

    Py_XDECREF( var___init__ );
    var___init__ = NULL;

    Py_XDECREF( var_parse );
    var_parse = NULL;

    Py_XDECREF( var__push_scope );
    var__push_scope = NULL;

    Py_XDECREF( var__pop_scope );
    var__pop_scope = NULL;

    Py_XDECREF( var__add_typedef_name );
    var__add_typedef_name = NULL;

    Py_XDECREF( var__add_identifier );
    var__add_identifier = NULL;

    Py_XDECREF( var__is_type_in_scope );
    var__is_type_in_scope = NULL;

    Py_XDECREF( var__lex_error_func );
    var__lex_error_func = NULL;

    Py_XDECREF( var__lex_on_lbrace_func );
    var__lex_on_lbrace_func = NULL;

    Py_XDECREF( var__lex_on_rbrace_func );
    var__lex_on_rbrace_func = NULL;

    Py_XDECREF( var__lex_type_lookup_func );
    var__lex_type_lookup_func = NULL;

    Py_XDECREF( var__get_yacc_lookahead_token );
    var__get_yacc_lookahead_token = NULL;

    Py_XDECREF( var__type_modify_decl );
    var__type_modify_decl = NULL;

    Py_XDECREF( var__fix_decl_name_type );
    var__fix_decl_name_type = NULL;

    Py_XDECREF( var__add_declaration_specifier );
    var__add_declaration_specifier = NULL;

    Py_XDECREF( var__build_declarations );
    var__build_declarations = NULL;

    Py_XDECREF( var__build_function_definition );
    var__build_function_definition = NULL;

    Py_XDECREF( var__select_struct_union_class );
    var__select_struct_union_class = NULL;

    Py_XDECREF( var_precedence );
    var_precedence = NULL;

    Py_XDECREF( var_p_translation_unit_or_empty );
    var_p_translation_unit_or_empty = NULL;

    Py_XDECREF( var_p_translation_unit_1 );
    var_p_translation_unit_1 = NULL;

    Py_XDECREF( var_p_translation_unit_2 );
    var_p_translation_unit_2 = NULL;

    Py_XDECREF( var_p_external_declaration_1 );
    var_p_external_declaration_1 = NULL;

    Py_XDECREF( var_p_external_declaration_2 );
    var_p_external_declaration_2 = NULL;

    Py_XDECREF( var_p_external_declaration_3 );
    var_p_external_declaration_3 = NULL;

    Py_XDECREF( var_p_external_declaration_4 );
    var_p_external_declaration_4 = NULL;

    Py_XDECREF( var_p_pp_directive );
    var_p_pp_directive = NULL;

    Py_XDECREF( var_p_pppragma_directive );
    var_p_pppragma_directive = NULL;

    Py_XDECREF( var_p_function_definition_1 );
    var_p_function_definition_1 = NULL;

    Py_XDECREF( var_p_function_definition_2 );
    var_p_function_definition_2 = NULL;

    Py_XDECREF( var_p_statement );
    var_p_statement = NULL;

    Py_XDECREF( var_p_decl_body );
    var_p_decl_body = NULL;

    Py_XDECREF( var_p_declaration );
    var_p_declaration = NULL;

    Py_XDECREF( var_p_declaration_list );
    var_p_declaration_list = NULL;

    Py_XDECREF( var_p_declaration_specifiers_no_type_1 );
    var_p_declaration_specifiers_no_type_1 = NULL;

    Py_XDECREF( var_p_declaration_specifiers_no_type_2 );
    var_p_declaration_specifiers_no_type_2 = NULL;

    Py_XDECREF( var_p_declaration_specifiers_no_type_3 );
    var_p_declaration_specifiers_no_type_3 = NULL;

    Py_XDECREF( var_p_declaration_specifiers_1 );
    var_p_declaration_specifiers_1 = NULL;

    Py_XDECREF( var_p_declaration_specifiers_2 );
    var_p_declaration_specifiers_2 = NULL;

    Py_XDECREF( var_p_declaration_specifiers_3 );
    var_p_declaration_specifiers_3 = NULL;

    Py_XDECREF( var_p_declaration_specifiers_4 );
    var_p_declaration_specifiers_4 = NULL;

    Py_XDECREF( var_p_declaration_specifiers_5 );
    var_p_declaration_specifiers_5 = NULL;

    Py_XDECREF( var_p_declaration_specifiers_6 );
    var_p_declaration_specifiers_6 = NULL;

    Py_XDECREF( var_p_storage_class_specifier );
    var_p_storage_class_specifier = NULL;

    Py_XDECREF( var_p_function_specifier );
    var_p_function_specifier = NULL;

    Py_XDECREF( var_p_type_specifier_no_typeid );
    var_p_type_specifier_no_typeid = NULL;

    Py_XDECREF( var_p_type_specifier );
    var_p_type_specifier = NULL;

    Py_XDECREF( var_p_type_qualifier );
    var_p_type_qualifier = NULL;

    Py_XDECREF( var_p_init_declarator_list );
    var_p_init_declarator_list = NULL;

    Py_XDECREF( var_p_init_declarator );
    var_p_init_declarator = NULL;

    Py_XDECREF( var_p_id_init_declarator_list );
    var_p_id_init_declarator_list = NULL;

    Py_XDECREF( var_p_id_init_declarator );
    var_p_id_init_declarator = NULL;

    Py_XDECREF( var_p_specifier_qualifier_list_1 );
    var_p_specifier_qualifier_list_1 = NULL;

    Py_XDECREF( var_p_specifier_qualifier_list_2 );
    var_p_specifier_qualifier_list_2 = NULL;

    Py_XDECREF( var_p_specifier_qualifier_list_3 );
    var_p_specifier_qualifier_list_3 = NULL;

    Py_XDECREF( var_p_specifier_qualifier_list_4 );
    var_p_specifier_qualifier_list_4 = NULL;

    Py_XDECREF( var_p_struct_or_union_specifier_1 );
    var_p_struct_or_union_specifier_1 = NULL;

    Py_XDECREF( var_p_struct_or_union_specifier_2 );
    var_p_struct_or_union_specifier_2 = NULL;

    Py_XDECREF( var_p_struct_or_union_specifier_3 );
    var_p_struct_or_union_specifier_3 = NULL;

    Py_XDECREF( var_p_struct_or_union );
    var_p_struct_or_union = NULL;

    Py_XDECREF( var_p_struct_declaration_list );
    var_p_struct_declaration_list = NULL;

    Py_XDECREF( var_p_struct_declaration_1 );
    var_p_struct_declaration_1 = NULL;

    Py_XDECREF( var_p_struct_declaration_2 );
    var_p_struct_declaration_2 = NULL;

    Py_XDECREF( var_p_struct_declarator_list );
    var_p_struct_declarator_list = NULL;

    Py_XDECREF( var_p_struct_declarator_1 );
    var_p_struct_declarator_1 = NULL;

    Py_XDECREF( var_p_struct_declarator_2 );
    var_p_struct_declarator_2 = NULL;

    Py_XDECREF( var_p_enum_specifier_1 );
    var_p_enum_specifier_1 = NULL;

    Py_XDECREF( var_p_enum_specifier_2 );
    var_p_enum_specifier_2 = NULL;

    Py_XDECREF( var_p_enum_specifier_3 );
    var_p_enum_specifier_3 = NULL;

    Py_XDECREF( var_p_enumerator_list );
    var_p_enumerator_list = NULL;

    Py_XDECREF( var_p_enumerator );
    var_p_enumerator = NULL;

    Py_XDECREF( var_p_declarator );
    var_p_declarator = NULL;

    Py_XDECREF( var_p_xxx_declarator_1 );
    var_p_xxx_declarator_1 = NULL;

    Py_XDECREF( var_p_xxx_declarator_2 );
    var_p_xxx_declarator_2 = NULL;

    Py_XDECREF( var_p_direct_xxx_declarator_1 );
    var_p_direct_xxx_declarator_1 = NULL;

    Py_XDECREF( var_p_direct_xxx_declarator_2 );
    var_p_direct_xxx_declarator_2 = NULL;

    Py_XDECREF( var_p_direct_xxx_declarator_3 );
    var_p_direct_xxx_declarator_3 = NULL;

    Py_XDECREF( var_p_direct_xxx_declarator_4 );
    var_p_direct_xxx_declarator_4 = NULL;

    Py_XDECREF( var_p_direct_xxx_declarator_5 );
    var_p_direct_xxx_declarator_5 = NULL;

    Py_XDECREF( var_p_direct_xxx_declarator_6 );
    var_p_direct_xxx_declarator_6 = NULL;

    Py_XDECREF( var_p_pointer );
    var_p_pointer = NULL;

    Py_XDECREF( var_p_type_qualifier_list );
    var_p_type_qualifier_list = NULL;

    Py_XDECREF( var_p_parameter_type_list );
    var_p_parameter_type_list = NULL;

    Py_XDECREF( var_p_parameter_list );
    var_p_parameter_list = NULL;

    Py_XDECREF( var_p_parameter_declaration_1 );
    var_p_parameter_declaration_1 = NULL;

    Py_XDECREF( var_p_parameter_declaration_2 );
    var_p_parameter_declaration_2 = NULL;

    Py_XDECREF( var_p_identifier_list );
    var_p_identifier_list = NULL;

    Py_XDECREF( var_p_initializer_1 );
    var_p_initializer_1 = NULL;

    Py_XDECREF( var_p_initializer_2 );
    var_p_initializer_2 = NULL;

    Py_XDECREF( var_p_initializer_list );
    var_p_initializer_list = NULL;

    Py_XDECREF( var_p_designation );
    var_p_designation = NULL;

    Py_XDECREF( var_p_designator_list );
    var_p_designator_list = NULL;

    Py_XDECREF( var_p_designator );
    var_p_designator = NULL;

    Py_XDECREF( var_p_type_name );
    var_p_type_name = NULL;

    Py_XDECREF( var_p_abstract_declarator_1 );
    var_p_abstract_declarator_1 = NULL;

    Py_XDECREF( var_p_abstract_declarator_2 );
    var_p_abstract_declarator_2 = NULL;

    Py_XDECREF( var_p_abstract_declarator_3 );
    var_p_abstract_declarator_3 = NULL;

    Py_XDECREF( var_p_direct_abstract_declarator_1 );
    var_p_direct_abstract_declarator_1 = NULL;

    Py_XDECREF( var_p_direct_abstract_declarator_2 );
    var_p_direct_abstract_declarator_2 = NULL;

    Py_XDECREF( var_p_direct_abstract_declarator_3 );
    var_p_direct_abstract_declarator_3 = NULL;

    Py_XDECREF( var_p_direct_abstract_declarator_4 );
    var_p_direct_abstract_declarator_4 = NULL;

    Py_XDECREF( var_p_direct_abstract_declarator_5 );
    var_p_direct_abstract_declarator_5 = NULL;

    Py_XDECREF( var_p_direct_abstract_declarator_6 );
    var_p_direct_abstract_declarator_6 = NULL;

    Py_XDECREF( var_p_direct_abstract_declarator_7 );
    var_p_direct_abstract_declarator_7 = NULL;

    Py_XDECREF( var_p_block_item );
    var_p_block_item = NULL;

    Py_XDECREF( var_p_block_item_list );
    var_p_block_item_list = NULL;

    Py_XDECREF( var_p_compound_statement_1 );
    var_p_compound_statement_1 = NULL;

    Py_XDECREF( var_p_labeled_statement_1 );
    var_p_labeled_statement_1 = NULL;

    Py_XDECREF( var_p_labeled_statement_2 );
    var_p_labeled_statement_2 = NULL;

    Py_XDECREF( var_p_labeled_statement_3 );
    var_p_labeled_statement_3 = NULL;

    Py_XDECREF( var_p_selection_statement_1 );
    var_p_selection_statement_1 = NULL;

    Py_XDECREF( var_p_selection_statement_2 );
    var_p_selection_statement_2 = NULL;

    Py_XDECREF( var_p_selection_statement_3 );
    var_p_selection_statement_3 = NULL;

    Py_XDECREF( var_p_iteration_statement_1 );
    var_p_iteration_statement_1 = NULL;

    Py_XDECREF( var_p_iteration_statement_2 );
    var_p_iteration_statement_2 = NULL;

    Py_XDECREF( var_p_iteration_statement_3 );
    var_p_iteration_statement_3 = NULL;

    Py_XDECREF( var_p_iteration_statement_4 );
    var_p_iteration_statement_4 = NULL;

    Py_XDECREF( var_p_jump_statement_1 );
    var_p_jump_statement_1 = NULL;

    Py_XDECREF( var_p_jump_statement_2 );
    var_p_jump_statement_2 = NULL;

    Py_XDECREF( var_p_jump_statement_3 );
    var_p_jump_statement_3 = NULL;

    Py_XDECREF( var_p_jump_statement_4 );
    var_p_jump_statement_4 = NULL;

    Py_XDECREF( var_p_expression_statement );
    var_p_expression_statement = NULL;

    Py_XDECREF( var_p_expression );
    var_p_expression = NULL;

    Py_XDECREF( var_p_typedef_name );
    var_p_typedef_name = NULL;

    Py_XDECREF( var_p_assignment_expression );
    var_p_assignment_expression = NULL;

    Py_XDECREF( var_p_assignment_operator );
    var_p_assignment_operator = NULL;

    Py_XDECREF( var_p_constant_expression );
    var_p_constant_expression = NULL;

    Py_XDECREF( var_p_conditional_expression );
    var_p_conditional_expression = NULL;

    Py_XDECREF( var_p_binary_expression );
    var_p_binary_expression = NULL;

    Py_XDECREF( var_p_cast_expression_1 );
    var_p_cast_expression_1 = NULL;

    Py_XDECREF( var_p_cast_expression_2 );
    var_p_cast_expression_2 = NULL;

    Py_XDECREF( var_p_unary_expression_1 );
    var_p_unary_expression_1 = NULL;

    Py_XDECREF( var_p_unary_expression_2 );
    var_p_unary_expression_2 = NULL;

    Py_XDECREF( var_p_unary_expression_3 );
    var_p_unary_expression_3 = NULL;

    Py_XDECREF( var_p_unary_operator );
    var_p_unary_operator = NULL;

    Py_XDECREF( var_p_postfix_expression_1 );
    var_p_postfix_expression_1 = NULL;

    Py_XDECREF( var_p_postfix_expression_2 );
    var_p_postfix_expression_2 = NULL;

    Py_XDECREF( var_p_postfix_expression_3 );
    var_p_postfix_expression_3 = NULL;

    Py_XDECREF( var_p_postfix_expression_4 );
    var_p_postfix_expression_4 = NULL;

    Py_XDECREF( var_p_postfix_expression_5 );
    var_p_postfix_expression_5 = NULL;

    Py_XDECREF( var_p_postfix_expression_6 );
    var_p_postfix_expression_6 = NULL;

    Py_XDECREF( var_p_primary_expression_1 );
    var_p_primary_expression_1 = NULL;

    Py_XDECREF( var_p_primary_expression_2 );
    var_p_primary_expression_2 = NULL;

    Py_XDECREF( var_p_primary_expression_3 );
    var_p_primary_expression_3 = NULL;

    Py_XDECREF( var_p_primary_expression_4 );
    var_p_primary_expression_4 = NULL;

    Py_XDECREF( var_p_primary_expression_5 );
    var_p_primary_expression_5 = NULL;

    Py_XDECREF( var_p_offsetof_member_designator );
    var_p_offsetof_member_designator = NULL;

    Py_XDECREF( var_p_argument_expression_list );
    var_p_argument_expression_list = NULL;

    Py_XDECREF( var_p_identifier );
    var_p_identifier = NULL;

    Py_XDECREF( var_p_constant_1 );
    var_p_constant_1 = NULL;

    Py_XDECREF( var_p_constant_2 );
    var_p_constant_2 = NULL;

    Py_XDECREF( var_p_constant_3 );
    var_p_constant_3 = NULL;

    Py_XDECREF( var_p_unified_string_literal );
    var_p_unified_string_literal = NULL;

    Py_XDECREF( var_p_unified_wstring_literal );
    var_p_unified_wstring_literal = NULL;

    Py_XDECREF( var_p_brace_open );
    var_p_brace_open = NULL;

    Py_XDECREF( var_p_brace_close );
    var_p_brace_close = NULL;

    Py_XDECREF( var_p_empty );
    var_p_empty = NULL;

    Py_XDECREF( var_p_error );
    var_p_error = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( var___qualname__ );
    var___qualname__ = NULL;

    Py_XDECREF( var___module__ );
    var___module__ = NULL;

    Py_XDECREF( var___init__ );
    var___init__ = NULL;

    Py_XDECREF( var_parse );
    var_parse = NULL;

    Py_XDECREF( var__push_scope );
    var__push_scope = NULL;

    Py_XDECREF( var__pop_scope );
    var__pop_scope = NULL;

    Py_XDECREF( var__add_typedef_name );
    var__add_typedef_name = NULL;

    Py_XDECREF( var__add_identifier );
    var__add_identifier = NULL;

    Py_XDECREF( var__is_type_in_scope );
    var__is_type_in_scope = NULL;

    Py_XDECREF( var__lex_error_func );
    var__lex_error_func = NULL;

    Py_XDECREF( var__lex_on_lbrace_func );
    var__lex_on_lbrace_func = NULL;

    Py_XDECREF( var__lex_on_rbrace_func );
    var__lex_on_rbrace_func = NULL;

    Py_XDECREF( var__lex_type_lookup_func );
    var__lex_type_lookup_func = NULL;

    Py_XDECREF( var__get_yacc_lookahead_token );
    var__get_yacc_lookahead_token = NULL;

    Py_XDECREF( var__type_modify_decl );
    var__type_modify_decl = NULL;

    Py_XDECREF( var__fix_decl_name_type );
    var__fix_decl_name_type = NULL;

    Py_XDECREF( var__add_declaration_specifier );
    var__add_declaration_specifier = NULL;

    Py_XDECREF( var__build_declarations );
    var__build_declarations = NULL;

    Py_XDECREF( var__build_function_definition );
    var__build_function_definition = NULL;

    Py_XDECREF( var__select_struct_union_class );
    var__select_struct_union_class = NULL;

    Py_XDECREF( var_precedence );
    var_precedence = NULL;

    Py_XDECREF( var_p_translation_unit_or_empty );
    var_p_translation_unit_or_empty = NULL;

    Py_XDECREF( var_p_translation_unit_1 );
    var_p_translation_unit_1 = NULL;

    Py_XDECREF( var_p_translation_unit_2 );
    var_p_translation_unit_2 = NULL;

    Py_XDECREF( var_p_external_declaration_1 );
    var_p_external_declaration_1 = NULL;

    Py_XDECREF( var_p_external_declaration_2 );
    var_p_external_declaration_2 = NULL;

    Py_XDECREF( var_p_external_declaration_3 );
    var_p_external_declaration_3 = NULL;

    Py_XDECREF( var_p_external_declaration_4 );
    var_p_external_declaration_4 = NULL;

    Py_XDECREF( var_p_pp_directive );
    var_p_pp_directive = NULL;

    Py_XDECREF( var_p_pppragma_directive );
    var_p_pppragma_directive = NULL;

    Py_XDECREF( var_p_function_definition_1 );
    var_p_function_definition_1 = NULL;

    Py_XDECREF( var_p_function_definition_2 );
    var_p_function_definition_2 = NULL;

    Py_XDECREF( var_p_statement );
    var_p_statement = NULL;

    Py_XDECREF( var_p_decl_body );
    var_p_decl_body = NULL;

    Py_XDECREF( var_p_declaration );
    var_p_declaration = NULL;

    Py_XDECREF( var_p_declaration_list );
    var_p_declaration_list = NULL;

    Py_XDECREF( var_p_declaration_specifiers_no_type_1 );
    var_p_declaration_specifiers_no_type_1 = NULL;

    Py_XDECREF( var_p_declaration_specifiers_no_type_2 );
    var_p_declaration_specifiers_no_type_2 = NULL;

    Py_XDECREF( var_p_declaration_specifiers_no_type_3 );
    var_p_declaration_specifiers_no_type_3 = NULL;

    Py_XDECREF( var_p_declaration_specifiers_1 );
    var_p_declaration_specifiers_1 = NULL;

    Py_XDECREF( var_p_declaration_specifiers_2 );
    var_p_declaration_specifiers_2 = NULL;

    Py_XDECREF( var_p_declaration_specifiers_3 );
    var_p_declaration_specifiers_3 = NULL;

    Py_XDECREF( var_p_declaration_specifiers_4 );
    var_p_declaration_specifiers_4 = NULL;

    Py_XDECREF( var_p_declaration_specifiers_5 );
    var_p_declaration_specifiers_5 = NULL;

    Py_XDECREF( var_p_declaration_specifiers_6 );
    var_p_declaration_specifiers_6 = NULL;

    Py_XDECREF( var_p_storage_class_specifier );
    var_p_storage_class_specifier = NULL;

    Py_XDECREF( var_p_function_specifier );
    var_p_function_specifier = NULL;

    Py_XDECREF( var_p_type_specifier_no_typeid );
    var_p_type_specifier_no_typeid = NULL;

    Py_XDECREF( var_p_type_specifier );
    var_p_type_specifier = NULL;

    Py_XDECREF( var_p_type_qualifier );
    var_p_type_qualifier = NULL;

    Py_XDECREF( var_p_init_declarator_list );
    var_p_init_declarator_list = NULL;

    Py_XDECREF( var_p_init_declarator );
    var_p_init_declarator = NULL;

    Py_XDECREF( var_p_id_init_declarator_list );
    var_p_id_init_declarator_list = NULL;

    Py_XDECREF( var_p_id_init_declarator );
    var_p_id_init_declarator = NULL;

    Py_XDECREF( var_p_specifier_qualifier_list_1 );
    var_p_specifier_qualifier_list_1 = NULL;

    Py_XDECREF( var_p_specifier_qualifier_list_2 );
    var_p_specifier_qualifier_list_2 = NULL;

    Py_XDECREF( var_p_specifier_qualifier_list_3 );
    var_p_specifier_qualifier_list_3 = NULL;

    Py_XDECREF( var_p_specifier_qualifier_list_4 );
    var_p_specifier_qualifier_list_4 = NULL;

    Py_XDECREF( var_p_struct_or_union_specifier_1 );
    var_p_struct_or_union_specifier_1 = NULL;

    Py_XDECREF( var_p_struct_or_union_specifier_2 );
    var_p_struct_or_union_specifier_2 = NULL;

    Py_XDECREF( var_p_struct_or_union_specifier_3 );
    var_p_struct_or_union_specifier_3 = NULL;

    Py_XDECREF( var_p_struct_or_union );
    var_p_struct_or_union = NULL;

    Py_XDECREF( var_p_struct_declaration_list );
    var_p_struct_declaration_list = NULL;

    Py_XDECREF( var_p_struct_declaration_1 );
    var_p_struct_declaration_1 = NULL;

    Py_XDECREF( var_p_struct_declaration_2 );
    var_p_struct_declaration_2 = NULL;

    Py_XDECREF( var_p_struct_declarator_list );
    var_p_struct_declarator_list = NULL;

    Py_XDECREF( var_p_struct_declarator_1 );
    var_p_struct_declarator_1 = NULL;

    Py_XDECREF( var_p_struct_declarator_2 );
    var_p_struct_declarator_2 = NULL;

    Py_XDECREF( var_p_enum_specifier_1 );
    var_p_enum_specifier_1 = NULL;

    Py_XDECREF( var_p_enum_specifier_2 );
    var_p_enum_specifier_2 = NULL;

    Py_XDECREF( var_p_enum_specifier_3 );
    var_p_enum_specifier_3 = NULL;

    Py_XDECREF( var_p_enumerator_list );
    var_p_enumerator_list = NULL;

    Py_XDECREF( var_p_enumerator );
    var_p_enumerator = NULL;

    Py_XDECREF( var_p_declarator );
    var_p_declarator = NULL;

    Py_XDECREF( var_p_xxx_declarator_1 );
    var_p_xxx_declarator_1 = NULL;

    Py_XDECREF( var_p_xxx_declarator_2 );
    var_p_xxx_declarator_2 = NULL;

    Py_XDECREF( var_p_direct_xxx_declarator_1 );
    var_p_direct_xxx_declarator_1 = NULL;

    Py_XDECREF( var_p_direct_xxx_declarator_2 );
    var_p_direct_xxx_declarator_2 = NULL;

    Py_XDECREF( var_p_direct_xxx_declarator_3 );
    var_p_direct_xxx_declarator_3 = NULL;

    Py_XDECREF( var_p_direct_xxx_declarator_4 );
    var_p_direct_xxx_declarator_4 = NULL;

    Py_XDECREF( var_p_direct_xxx_declarator_5 );
    var_p_direct_xxx_declarator_5 = NULL;

    Py_XDECREF( var_p_direct_xxx_declarator_6 );
    var_p_direct_xxx_declarator_6 = NULL;

    Py_XDECREF( var_p_pointer );
    var_p_pointer = NULL;

    Py_XDECREF( var_p_type_qualifier_list );
    var_p_type_qualifier_list = NULL;

    Py_XDECREF( var_p_parameter_type_list );
    var_p_parameter_type_list = NULL;

    Py_XDECREF( var_p_parameter_list );
    var_p_parameter_list = NULL;

    Py_XDECREF( var_p_parameter_declaration_1 );
    var_p_parameter_declaration_1 = NULL;

    Py_XDECREF( var_p_parameter_declaration_2 );
    var_p_parameter_declaration_2 = NULL;

    Py_XDECREF( var_p_identifier_list );
    var_p_identifier_list = NULL;

    Py_XDECREF( var_p_initializer_1 );
    var_p_initializer_1 = NULL;

    Py_XDECREF( var_p_initializer_2 );
    var_p_initializer_2 = NULL;

    Py_XDECREF( var_p_initializer_list );
    var_p_initializer_list = NULL;

    Py_XDECREF( var_p_designation );
    var_p_designation = NULL;

    Py_XDECREF( var_p_designator_list );
    var_p_designator_list = NULL;

    Py_XDECREF( var_p_designator );
    var_p_designator = NULL;

    Py_XDECREF( var_p_type_name );
    var_p_type_name = NULL;

    Py_XDECREF( var_p_abstract_declarator_1 );
    var_p_abstract_declarator_1 = NULL;

    Py_XDECREF( var_p_abstract_declarator_2 );
    var_p_abstract_declarator_2 = NULL;

    Py_XDECREF( var_p_abstract_declarator_3 );
    var_p_abstract_declarator_3 = NULL;

    Py_XDECREF( var_p_direct_abstract_declarator_1 );
    var_p_direct_abstract_declarator_1 = NULL;

    Py_XDECREF( var_p_direct_abstract_declarator_2 );
    var_p_direct_abstract_declarator_2 = NULL;

    Py_XDECREF( var_p_direct_abstract_declarator_3 );
    var_p_direct_abstract_declarator_3 = NULL;

    Py_XDECREF( var_p_direct_abstract_declarator_4 );
    var_p_direct_abstract_declarator_4 = NULL;

    Py_XDECREF( var_p_direct_abstract_declarator_5 );
    var_p_direct_abstract_declarator_5 = NULL;

    Py_XDECREF( var_p_direct_abstract_declarator_6 );
    var_p_direct_abstract_declarator_6 = NULL;

    Py_XDECREF( var_p_direct_abstract_declarator_7 );
    var_p_direct_abstract_declarator_7 = NULL;

    Py_XDECREF( var_p_block_item );
    var_p_block_item = NULL;

    Py_XDECREF( var_p_block_item_list );
    var_p_block_item_list = NULL;

    Py_XDECREF( var_p_compound_statement_1 );
    var_p_compound_statement_1 = NULL;

    Py_XDECREF( var_p_labeled_statement_1 );
    var_p_labeled_statement_1 = NULL;

    Py_XDECREF( var_p_labeled_statement_2 );
    var_p_labeled_statement_2 = NULL;

    Py_XDECREF( var_p_labeled_statement_3 );
    var_p_labeled_statement_3 = NULL;

    Py_XDECREF( var_p_selection_statement_1 );
    var_p_selection_statement_1 = NULL;

    Py_XDECREF( var_p_selection_statement_2 );
    var_p_selection_statement_2 = NULL;

    Py_XDECREF( var_p_selection_statement_3 );
    var_p_selection_statement_3 = NULL;

    Py_XDECREF( var_p_iteration_statement_1 );
    var_p_iteration_statement_1 = NULL;

    Py_XDECREF( var_p_iteration_statement_2 );
    var_p_iteration_statement_2 = NULL;

    Py_XDECREF( var_p_iteration_statement_3 );
    var_p_iteration_statement_3 = NULL;

    Py_XDECREF( var_p_iteration_statement_4 );
    var_p_iteration_statement_4 = NULL;

    Py_XDECREF( var_p_jump_statement_1 );
    var_p_jump_statement_1 = NULL;

    Py_XDECREF( var_p_jump_statement_2 );
    var_p_jump_statement_2 = NULL;

    Py_XDECREF( var_p_jump_statement_3 );
    var_p_jump_statement_3 = NULL;

    Py_XDECREF( var_p_jump_statement_4 );
    var_p_jump_statement_4 = NULL;

    Py_XDECREF( var_p_expression_statement );
    var_p_expression_statement = NULL;

    Py_XDECREF( var_p_expression );
    var_p_expression = NULL;

    Py_XDECREF( var_p_typedef_name );
    var_p_typedef_name = NULL;

    Py_XDECREF( var_p_assignment_expression );
    var_p_assignment_expression = NULL;

    Py_XDECREF( var_p_assignment_operator );
    var_p_assignment_operator = NULL;

    Py_XDECREF( var_p_constant_expression );
    var_p_constant_expression = NULL;

    Py_XDECREF( var_p_conditional_expression );
    var_p_conditional_expression = NULL;

    Py_XDECREF( var_p_binary_expression );
    var_p_binary_expression = NULL;

    Py_XDECREF( var_p_cast_expression_1 );
    var_p_cast_expression_1 = NULL;

    Py_XDECREF( var_p_cast_expression_2 );
    var_p_cast_expression_2 = NULL;

    Py_XDECREF( var_p_unary_expression_1 );
    var_p_unary_expression_1 = NULL;

    Py_XDECREF( var_p_unary_expression_2 );
    var_p_unary_expression_2 = NULL;

    Py_XDECREF( var_p_unary_expression_3 );
    var_p_unary_expression_3 = NULL;

    Py_XDECREF( var_p_unary_operator );
    var_p_unary_operator = NULL;

    Py_XDECREF( var_p_postfix_expression_1 );
    var_p_postfix_expression_1 = NULL;

    Py_XDECREF( var_p_postfix_expression_2 );
    var_p_postfix_expression_2 = NULL;

    Py_XDECREF( var_p_postfix_expression_3 );
    var_p_postfix_expression_3 = NULL;

    Py_XDECREF( var_p_postfix_expression_4 );
    var_p_postfix_expression_4 = NULL;

    Py_XDECREF( var_p_postfix_expression_5 );
    var_p_postfix_expression_5 = NULL;

    Py_XDECREF( var_p_postfix_expression_6 );
    var_p_postfix_expression_6 = NULL;

    Py_XDECREF( var_p_primary_expression_1 );
    var_p_primary_expression_1 = NULL;

    Py_XDECREF( var_p_primary_expression_2 );
    var_p_primary_expression_2 = NULL;

    Py_XDECREF( var_p_primary_expression_3 );
    var_p_primary_expression_3 = NULL;

    Py_XDECREF( var_p_primary_expression_4 );
    var_p_primary_expression_4 = NULL;

    Py_XDECREF( var_p_primary_expression_5 );
    var_p_primary_expression_5 = NULL;

    Py_XDECREF( var_p_offsetof_member_designator );
    var_p_offsetof_member_designator = NULL;

    Py_XDECREF( var_p_argument_expression_list );
    var_p_argument_expression_list = NULL;

    Py_XDECREF( var_p_identifier );
    var_p_identifier = NULL;

    Py_XDECREF( var_p_constant_1 );
    var_p_constant_1 = NULL;

    Py_XDECREF( var_p_constant_2 );
    var_p_constant_2 = NULL;

    Py_XDECREF( var_p_constant_3 );
    var_p_constant_3 = NULL;

    Py_XDECREF( var_p_unified_string_literal );
    var_p_unified_string_literal = NULL;

    Py_XDECREF( var_p_unified_wstring_literal );
    var_p_unified_wstring_literal = NULL;

    Py_XDECREF( var_p_brace_open );
    var_p_brace_open = NULL;

    Py_XDECREF( var_p_brace_close );
    var_p_brace_close = NULL;

    Py_XDECREF( var_p_empty );
    var_p_empty = NULL;

    Py_XDECREF( var_p_error );
    var_p_error = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser );
    return NULL;

function_exception_exit:
Py_DECREF( locals_dict );
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:
        Py_DECREF( locals_dict );

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_1___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_lex_optimize = python_pars[ 1 ];
    PyObject *par_lexer = python_pars[ 2 ];
    PyObject *par_lextab = python_pars[ 3 ];
    PyObject *par_yacc_optimize = python_pars[ 4 ];
    PyObject *par_yacctab = python_pars[ 5 ];
    PyObject *par_yacc_debug = python_pars[ 6 ];
    PyObject *par_taboutputdir = python_pars[ 7 ];
    PyObject *var_rules_with_opt = NULL;
    PyObject *var_rule = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_name_3;
    PyObject *tmp_assattr_name_4;
    PyObject *tmp_assattr_name_5;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assattr_target_3;
    PyObject *tmp_assattr_target_4;
    PyObject *tmp_assattr_target_5;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_key_4;
    PyObject *tmp_dict_key_5;
    PyObject *tmp_dict_key_6;
    PyObject *tmp_dict_key_7;
    PyObject *tmp_dict_key_8;
    PyObject *tmp_dict_key_9;
    PyObject *tmp_dict_key_10;
    PyObject *tmp_dict_key_11;
    PyObject *tmp_dict_key_12;
    PyObject *tmp_dict_key_13;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_dict_value_4;
    PyObject *tmp_dict_value_5;
    PyObject *tmp_dict_value_6;
    PyObject *tmp_dict_value_7;
    PyObject *tmp_dict_value_8;
    PyObject *tmp_dict_value_9;
    PyObject *tmp_dict_value_10;
    PyObject *tmp_dict_value_11;
    PyObject *tmp_dict_value_12;
    PyObject *tmp_dict_value_13;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_kw_name_2;
    PyObject *tmp_kw_name_3;
    PyObject *tmp_next_source_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_c59e20d15f8eac5266dae2329206bd8e = NULL;

    struct Nuitka_FrameObject *frame_c59e20d15f8eac5266dae2329206bd8e;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c59e20d15f8eac5266dae2329206bd8e, codeobj_c59e20d15f8eac5266dae2329206bd8e, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_c59e20d15f8eac5266dae2329206bd8e = cache_frame_c59e20d15f8eac5266dae2329206bd8e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c59e20d15f8eac5266dae2329206bd8e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c59e20d15f8eac5266dae2329206bd8e ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = par_lexer;

    CHECK_OBJECT( tmp_called_name_1 );
    tmp_kw_name_1 = _PyDict_NewPresized( 4 );
    tmp_dict_key_1 = const_str_plain_error_func;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_dict_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__lex_error_func );
    if ( tmp_dict_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 80;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    Py_DECREF( tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_on_lbrace_func;
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 81;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_dict_value_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__lex_on_lbrace_func );
    if ( tmp_dict_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 81;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    Py_DECREF( tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_3 = const_str_plain_on_rbrace_func;
    tmp_source_name_3 = par_self;

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 82;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_dict_value_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__lex_on_rbrace_func );
    if ( tmp_dict_value_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 82;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3 );
    Py_DECREF( tmp_dict_value_3 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_4 = const_str_plain_type_lookup_func;
    tmp_source_name_4 = par_self;

    if ( tmp_source_name_4 == NULL )
    {
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 83;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_dict_value_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__lex_type_lookup_func );
    if ( tmp_dict_value_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 83;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_4, tmp_dict_value_4 );
    Py_DECREF( tmp_dict_value_4 );
    assert( !(tmp_res != 0) );
    frame_c59e20d15f8eac5266dae2329206bd8e->m_frame.f_lineno = 79;
    tmp_assattr_name_1 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 79;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = par_self;

    if ( tmp_assattr_target_1 == NULL )
    {
        Py_DECREF( tmp_assattr_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 79;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_clex, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 79;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );
    tmp_source_name_6 = par_self;

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 85;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_clex );
    if ( tmp_source_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 85;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_build );
    Py_DECREF( tmp_source_name_5 );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 85;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_2 = _PyDict_NewPresized( 3 );
    tmp_dict_key_5 = const_str_plain_optimize;
    tmp_dict_value_5 = par_lex_optimize;

    if ( tmp_dict_value_5 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "lex_optimize" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 86;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_5, tmp_dict_value_5 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_6 = const_str_plain_lextab;
    tmp_dict_value_6 = par_lextab;

    if ( tmp_dict_value_6 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "lextab" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 87;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_6, tmp_dict_value_6 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_7 = const_str_plain_outputdir;
    tmp_dict_value_7 = par_taboutputdir;

    if ( tmp_dict_value_7 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "taboutputdir" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 88;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_7, tmp_dict_value_7 );
    assert( !(tmp_res != 0) );
    frame_c59e20d15f8eac5266dae2329206bd8e->m_frame.f_lineno = 85;
    tmp_unused = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_2, tmp_kw_name_2 );
    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_kw_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 85;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_8 = par_self;

    if ( tmp_source_name_8 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 89;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_clex );
    if ( tmp_source_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 89;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_tokens );
    Py_DECREF( tmp_source_name_7 );
    if ( tmp_assattr_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 89;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_2 = par_self;

    if ( tmp_assattr_target_2 == NULL )
    {
        Py_DECREF( tmp_assattr_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 89;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_tokens, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_2 );

        exception_lineno = 89;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_2 );
    tmp_assign_source_1 = LIST_COPY( const_list_92f625f2146505b2a221686ca03ee1cd_list );
    assert( var_rules_with_opt == NULL );
    var_rules_with_opt = tmp_assign_source_1;

    tmp_iter_arg_1 = var_rules_with_opt;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 108;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_2;

    // Tried code:
    loop_start_1:;
    tmp_next_source_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_next_source_1 );
    tmp_assign_source_3 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            type_description = "oooooooooo";
            exception_lineno = 108;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_3;
        Py_XDECREF( old );
    }

    tmp_assign_source_4 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_4 );
    {
        PyObject *old = var_rule;
        var_rule = tmp_assign_source_4;
        Py_INCREF( var_rule );
        Py_XDECREF( old );
    }

    tmp_source_name_9 = par_self;

    if ( tmp_source_name_9 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 109;
        type_description = "oooooooooo";
        goto try_except_handler_2;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain__create_opt_rule );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 109;
        type_description = "oooooooooo";
        goto try_except_handler_2;
    }
    tmp_args_element_name_1 = var_rule;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "rule" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 109;
        type_description = "oooooooooo";
        goto try_except_handler_2;
    }

    frame_c59e20d15f8eac5266dae2329206bd8e->m_frame.f_lineno = 109;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 109;
        type_description = "oooooooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 108;
        type_description = "oooooooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    Py_XDECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    Py_XDECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_source_name_10 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_yacc );

    if (unlikely( tmp_source_name_10 == NULL ))
    {
        tmp_source_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_yacc );
    }

    if ( tmp_source_name_10 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "yacc" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 111;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_yacc );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 111;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_3 = _PyDict_NewPresized( 6 );
    tmp_dict_key_8 = const_str_plain_module;
    tmp_dict_value_8 = par_self;

    if ( tmp_dict_value_8 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_kw_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 112;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_3, tmp_dict_key_8, tmp_dict_value_8 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_9 = const_str_plain_start;
    tmp_dict_value_9 = const_str_plain_translation_unit_or_empty;
    tmp_res = PyDict_SetItem( tmp_kw_name_3, tmp_dict_key_9, tmp_dict_value_9 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_10 = const_str_plain_debug;
    tmp_dict_value_10 = par_yacc_debug;

    if ( tmp_dict_value_10 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_kw_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "yacc_debug" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 114;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_3, tmp_dict_key_10, tmp_dict_value_10 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_11 = const_str_plain_optimize;
    tmp_dict_value_11 = par_yacc_optimize;

    if ( tmp_dict_value_11 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_kw_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "yacc_optimize" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 115;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_3, tmp_dict_key_11, tmp_dict_value_11 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_12 = const_str_plain_tabmodule;
    tmp_dict_value_12 = par_yacctab;

    if ( tmp_dict_value_12 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_kw_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "yacctab" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 116;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_3, tmp_dict_key_12, tmp_dict_value_12 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_13 = const_str_plain_outputdir;
    tmp_dict_value_13 = par_taboutputdir;

    if ( tmp_dict_value_13 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_kw_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "taboutputdir" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 117;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_3, tmp_dict_key_13, tmp_dict_value_13 );
    assert( !(tmp_res != 0) );
    frame_c59e20d15f8eac5266dae2329206bd8e->m_frame.f_lineno = 111;
    tmp_assattr_name_3 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_4, tmp_kw_name_3 );
    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_kw_name_3 );
    if ( tmp_assattr_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 111;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_3 = par_self;

    if ( tmp_assattr_target_3 == NULL )
    {
        Py_DECREF( tmp_assattr_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 111;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain_cparser, tmp_assattr_name_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_3 );

        exception_lineno = 111;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_3 );
    tmp_assattr_name_4 = DEEP_COPY( const_list_dict_empty_list );
    tmp_assattr_target_4 = par_self;

    if ( tmp_assattr_target_4 == NULL )
    {
        Py_DECREF( tmp_assattr_name_4 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 127;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain__scope_stack, tmp_assattr_name_4 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_4 );

        exception_lineno = 127;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_4 );
    tmp_assattr_name_5 = Py_None;
    tmp_assattr_target_5 = par_self;

    if ( tmp_assattr_target_5 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 130;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_5, const_str_plain__last_yielded_token, tmp_assattr_name_5 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 130;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c59e20d15f8eac5266dae2329206bd8e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c59e20d15f8eac5266dae2329206bd8e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c59e20d15f8eac5266dae2329206bd8e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c59e20d15f8eac5266dae2329206bd8e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c59e20d15f8eac5266dae2329206bd8e, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_c59e20d15f8eac5266dae2329206bd8e, type_description ,par_self, par_lex_optimize, par_lexer, par_lextab, par_yacc_optimize, par_yacctab, par_yacc_debug, par_taboutputdir, var_rules_with_opt, var_rule );

    // Release cached frame.
    if ( frame_c59e20d15f8eac5266dae2329206bd8e == cache_frame_c59e20d15f8eac5266dae2329206bd8e )
    {
        Py_DECREF( frame_c59e20d15f8eac5266dae2329206bd8e );
    }
    cache_frame_c59e20d15f8eac5266dae2329206bd8e = NULL;

    assertFrameObject( frame_c59e20d15f8eac5266dae2329206bd8e );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_1___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_lex_optimize );
    par_lex_optimize = NULL;

    Py_XDECREF( par_lexer );
    par_lexer = NULL;

    Py_XDECREF( par_lextab );
    par_lextab = NULL;

    Py_XDECREF( par_yacc_optimize );
    par_yacc_optimize = NULL;

    Py_XDECREF( par_yacctab );
    par_yacctab = NULL;

    Py_XDECREF( par_yacc_debug );
    par_yacc_debug = NULL;

    Py_XDECREF( par_taboutputdir );
    par_taboutputdir = NULL;

    Py_XDECREF( var_rules_with_opt );
    var_rules_with_opt = NULL;

    Py_XDECREF( var_rule );
    var_rule = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_lex_optimize );
    par_lex_optimize = NULL;

    Py_XDECREF( par_lexer );
    par_lexer = NULL;

    Py_XDECREF( par_lextab );
    par_lextab = NULL;

    Py_XDECREF( par_yacc_optimize );
    par_yacc_optimize = NULL;

    Py_XDECREF( par_yacctab );
    par_yacctab = NULL;

    Py_XDECREF( par_yacc_debug );
    par_yacc_debug = NULL;

    Py_XDECREF( par_taboutputdir );
    par_taboutputdir = NULL;

    Py_XDECREF( var_rules_with_opt );
    var_rules_with_opt = NULL;

    Py_XDECREF( var_rule );
    var_rule = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_1___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_2_parse( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_text = python_pars[ 1 ];
    PyObject *par_filename = python_pars[ 2 ];
    PyObject *par_debuglevel = python_pars[ 3 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_name_3;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assattr_target_3;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_kw_name_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_6a3ff42cc3d74ce0db1744142bbec85f = NULL;

    struct Nuitka_FrameObject *frame_6a3ff42cc3d74ce0db1744142bbec85f;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6a3ff42cc3d74ce0db1744142bbec85f, codeobj_6a3ff42cc3d74ce0db1744142bbec85f, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_6a3ff42cc3d74ce0db1744142bbec85f = cache_frame_6a3ff42cc3d74ce0db1744142bbec85f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6a3ff42cc3d74ce0db1744142bbec85f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6a3ff42cc3d74ce0db1744142bbec85f ) == 2 ); // Frame stack

    // Framed code:
    tmp_assattr_name_1 = par_filename;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_assattr_target_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_clex );
    if ( tmp_assattr_target_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 145;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_filename, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_target_1 );

        exception_lineno = 145;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_target_1 );
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 146;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_clex );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 146;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    frame_6a3ff42cc3d74ce0db1744142bbec85f->m_frame.f_lineno = 146;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_reset_lineno );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 146;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assattr_name_2 = DEEP_COPY( const_list_dict_empty_list );
    tmp_assattr_target_2 = par_self;

    if ( tmp_assattr_target_2 == NULL )
    {
        Py_DECREF( tmp_assattr_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 147;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__scope_stack, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_2 );

        exception_lineno = 147;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_2 );
    tmp_assattr_name_3 = Py_None;
    tmp_assattr_target_3 = par_self;

    if ( tmp_assattr_target_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 148;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain__last_yielded_token, tmp_assattr_name_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 148;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = par_self;

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 149;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_cparser );
    if ( tmp_source_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 149;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_parse );
    Py_DECREF( tmp_source_name_3 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 149;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_1 = _PyDict_NewPresized( 3 );
    tmp_dict_key_1 = const_str_plain_input;
    tmp_dict_value_1 = par_text;

    if ( tmp_dict_value_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "text" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 150;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_lexer;
    tmp_source_name_5 = par_self;

    if ( tmp_source_name_5 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 151;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_dict_value_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_clex );
    if ( tmp_dict_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 151;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    Py_DECREF( tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_3 = const_str_plain_debug;
    tmp_dict_value_3 = par_debuglevel;

    if ( tmp_dict_value_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "debuglevel" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 152;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3 );
    assert( !(tmp_res != 0) );
    frame_6a3ff42cc3d74ce0db1744142bbec85f->m_frame.f_lineno = 149;
    tmp_return_value = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 149;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6a3ff42cc3d74ce0db1744142bbec85f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_6a3ff42cc3d74ce0db1744142bbec85f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6a3ff42cc3d74ce0db1744142bbec85f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6a3ff42cc3d74ce0db1744142bbec85f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6a3ff42cc3d74ce0db1744142bbec85f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6a3ff42cc3d74ce0db1744142bbec85f, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_6a3ff42cc3d74ce0db1744142bbec85f, type_description ,par_self, par_text, par_filename, par_debuglevel );

    // Release cached frame.
    if ( frame_6a3ff42cc3d74ce0db1744142bbec85f == cache_frame_6a3ff42cc3d74ce0db1744142bbec85f )
    {
        Py_DECREF( frame_6a3ff42cc3d74ce0db1744142bbec85f );
    }
    cache_frame_6a3ff42cc3d74ce0db1744142bbec85f = NULL;

    assertFrameObject( frame_6a3ff42cc3d74ce0db1744142bbec85f );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_2_parse );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_text );
    par_text = NULL;

    Py_XDECREF( par_filename );
    par_filename = NULL;

    Py_XDECREF( par_debuglevel );
    par_debuglevel = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_text );
    par_text = NULL;

    Py_XDECREF( par_filename );
    par_filename = NULL;

    Py_XDECREF( par_debuglevel );
    par_debuglevel = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_2_parse );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_3__push_scope( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_call_arg_element_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_9369739e178dac98413046a0f356581a = NULL;

    struct Nuitka_FrameObject *frame_9369739e178dac98413046a0f356581a;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9369739e178dac98413046a0f356581a, codeobj_9369739e178dac98413046a0f356581a, module_pycparser$c_parser, sizeof(PyObject *) );
    frame_9369739e178dac98413046a0f356581a = cache_frame_9369739e178dac98413046a0f356581a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9369739e178dac98413046a0f356581a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9369739e178dac98413046a0f356581a ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__scope_stack );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 157;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_call_arg_element_1 = PyDict_New();
    frame_9369739e178dac98413046a0f356581a->m_frame.f_lineno = 157;
    {
        PyObject *call_args[] = { tmp_call_arg_element_1 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_append, call_args );
    }

    Py_DECREF( tmp_called_instance_1 );
    Py_DECREF( tmp_call_arg_element_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 157;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9369739e178dac98413046a0f356581a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9369739e178dac98413046a0f356581a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9369739e178dac98413046a0f356581a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9369739e178dac98413046a0f356581a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9369739e178dac98413046a0f356581a, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_9369739e178dac98413046a0f356581a, type_description ,par_self );

    // Release cached frame.
    if ( frame_9369739e178dac98413046a0f356581a == cache_frame_9369739e178dac98413046a0f356581a )
    {
        Py_DECREF( frame_9369739e178dac98413046a0f356581a );
    }
    cache_frame_9369739e178dac98413046a0f356581a = NULL;

    assertFrameObject( frame_9369739e178dac98413046a0f356581a );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_3__push_scope );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_3__push_scope );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_4__pop_scope( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    int tmp_cmp_Gt_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_6e8be8813e958c494a98780a36bdc1e2 = NULL;

    struct Nuitka_FrameObject *frame_6e8be8813e958c494a98780a36bdc1e2;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6e8be8813e958c494a98780a36bdc1e2, codeobj_6e8be8813e958c494a98780a36bdc1e2, module_pycparser$c_parser, sizeof(PyObject *) );
    frame_6e8be8813e958c494a98780a36bdc1e2 = cache_frame_6e8be8813e958c494a98780a36bdc1e2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6e8be8813e958c494a98780a36bdc1e2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6e8be8813e958c494a98780a36bdc1e2 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_len_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__scope_stack );
    if ( tmp_len_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 160;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    Py_DECREF( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 160;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_pos_1;
    tmp_cmp_Gt_1 = RICH_COMPARE_BOOL_GT( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Gt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 160;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Gt_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_raise_type_1 = PyExc_AssertionError;
    exception_type = tmp_raise_type_1;
    Py_INCREF( tmp_raise_type_1 );
    exception_lineno = 160;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "o";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 161;
        type_description = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__scope_stack );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 161;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    frame_6e8be8813e958c494a98780a36bdc1e2->m_frame.f_lineno = 161;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_pop );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 161;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6e8be8813e958c494a98780a36bdc1e2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6e8be8813e958c494a98780a36bdc1e2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6e8be8813e958c494a98780a36bdc1e2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6e8be8813e958c494a98780a36bdc1e2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6e8be8813e958c494a98780a36bdc1e2, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_6e8be8813e958c494a98780a36bdc1e2, type_description ,par_self );

    // Release cached frame.
    if ( frame_6e8be8813e958c494a98780a36bdc1e2 == cache_frame_6e8be8813e958c494a98780a36bdc1e2 )
    {
        Py_DECREF( frame_6e8be8813e958c494a98780a36bdc1e2 );
    }
    cache_frame_6e8be8813e958c494a98780a36bdc1e2 = NULL;

    assertFrameObject( frame_6e8be8813e958c494a98780a36bdc1e2 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_4__pop_scope );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_4__pop_scope );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_5__add_typedef_name( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    PyObject *par_coord = python_pars[ 2 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_left_name_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_5d301616ab586222ed78633c90ffcd8d = NULL;

    struct Nuitka_FrameObject *frame_5d301616ab586222ed78633c90ffcd8d;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5d301616ab586222ed78633c90ffcd8d, codeobj_5d301616ab586222ed78633c90ffcd8d, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_5d301616ab586222ed78633c90ffcd8d = cache_frame_5d301616ab586222ed78633c90ffcd8d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5d301616ab586222ed78633c90ffcd8d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5d301616ab586222ed78633c90ffcd8d ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__scope_stack );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 166;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_1 = const_int_neg_1;
    tmp_source_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 166;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_get );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 166;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_name;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 166;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = Py_True;
    frame_5d301616ab586222ed78633c90ffcd8d->m_frame.f_lineno = 166;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_cond_value_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 166;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 166;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_source_name_3 = par_self;

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 167;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__parse_error );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 167;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_1 = const_str_digest_dd774f65546147d7cec683569068da92;
    tmp_right_name_1 = par_name;

    if ( tmp_right_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 169;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 168;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = par_coord;

    if ( tmp_args_element_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "coord" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 169;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    frame_5d301616ab586222ed78633c90ffcd8d->m_frame.f_lineno = 167;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 167;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_1:;
    tmp_ass_subvalue_1 = Py_True;
    tmp_source_name_4 = par_self;

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 170;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscribed_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__scope_stack );
    if ( tmp_subscribed_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 170;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_2 = const_int_neg_1;
    tmp_ass_subscribed_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    Py_DECREF( tmp_subscribed_name_2 );
    if ( tmp_ass_subscribed_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 170;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscript_1 = par_name;

    if ( tmp_ass_subscript_1 == NULL )
    {
        Py_DECREF( tmp_ass_subscribed_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 170;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_1, tmp_ass_subscript_1, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subscribed_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 170;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5d301616ab586222ed78633c90ffcd8d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5d301616ab586222ed78633c90ffcd8d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5d301616ab586222ed78633c90ffcd8d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5d301616ab586222ed78633c90ffcd8d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5d301616ab586222ed78633c90ffcd8d, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_5d301616ab586222ed78633c90ffcd8d, type_description ,par_self, par_name, par_coord );

    // Release cached frame.
    if ( frame_5d301616ab586222ed78633c90ffcd8d == cache_frame_5d301616ab586222ed78633c90ffcd8d )
    {
        Py_DECREF( frame_5d301616ab586222ed78633c90ffcd8d );
    }
    cache_frame_5d301616ab586222ed78633c90ffcd8d = NULL;

    assertFrameObject( frame_5d301616ab586222ed78633c90ffcd8d );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_5__add_typedef_name );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_name );
    par_name = NULL;

    Py_XDECREF( par_coord );
    par_coord = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_name );
    par_name = NULL;

    Py_XDECREF( par_coord );
    par_coord = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_5__add_typedef_name );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_6__add_identifier( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    PyObject *par_coord = python_pars[ 2 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_left_name_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_288dc4e82434f2e66f5d247261ad8ef7 = NULL;

    struct Nuitka_FrameObject *frame_288dc4e82434f2e66f5d247261ad8ef7;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_288dc4e82434f2e66f5d247261ad8ef7, codeobj_288dc4e82434f2e66f5d247261ad8ef7, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_288dc4e82434f2e66f5d247261ad8ef7 = cache_frame_288dc4e82434f2e66f5d247261ad8ef7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_288dc4e82434f2e66f5d247261ad8ef7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_288dc4e82434f2e66f5d247261ad8ef7 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_subscribed_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__scope_stack );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 176;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_1 = const_int_neg_1;
    tmp_source_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 176;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_get );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 176;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_name;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 176;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = Py_False;
    frame_288dc4e82434f2e66f5d247261ad8ef7->m_frame.f_lineno = 176;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_cond_value_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 176;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 176;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_3 = par_self;

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 177;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__parse_error );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 177;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_1 = const_str_digest_576430d2ecd57cd9248634515b4042e1;
    tmp_right_name_1 = par_name;

    if ( tmp_right_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 179;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 178;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = par_coord;

    if ( tmp_args_element_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "coord" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 179;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    frame_288dc4e82434f2e66f5d247261ad8ef7->m_frame.f_lineno = 177;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 177;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_1:;
    tmp_ass_subvalue_1 = Py_False;
    tmp_source_name_4 = par_self;

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 180;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscribed_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__scope_stack );
    if ( tmp_subscribed_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 180;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_2 = const_int_neg_1;
    tmp_ass_subscribed_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    Py_DECREF( tmp_subscribed_name_2 );
    if ( tmp_ass_subscribed_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 180;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscript_1 = par_name;

    if ( tmp_ass_subscript_1 == NULL )
    {
        Py_DECREF( tmp_ass_subscribed_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 180;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_1, tmp_ass_subscript_1, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subscribed_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 180;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_288dc4e82434f2e66f5d247261ad8ef7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_288dc4e82434f2e66f5d247261ad8ef7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_288dc4e82434f2e66f5d247261ad8ef7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_288dc4e82434f2e66f5d247261ad8ef7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_288dc4e82434f2e66f5d247261ad8ef7, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_288dc4e82434f2e66f5d247261ad8ef7, type_description ,par_self, par_name, par_coord );

    // Release cached frame.
    if ( frame_288dc4e82434f2e66f5d247261ad8ef7 == cache_frame_288dc4e82434f2e66f5d247261ad8ef7 )
    {
        Py_DECREF( frame_288dc4e82434f2e66f5d247261ad8ef7 );
    }
    cache_frame_288dc4e82434f2e66f5d247261ad8ef7 = NULL;

    assertFrameObject( frame_288dc4e82434f2e66f5d247261ad8ef7 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_6__add_identifier );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_name );
    par_name = NULL;

    Py_XDECREF( par_coord );
    par_coord = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_name );
    par_name = NULL;

    Py_XDECREF( par_coord );
    par_coord = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_6__add_identifier );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_7__is_type_in_scope( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    PyObject *var_scope = NULL;
    PyObject *var_in_scope = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    bool tmp_isnot_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_next_source_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_f288e41b499202bc1365c10c60a14f5b = NULL;

    struct Nuitka_FrameObject *frame_f288e41b499202bc1365c10c60a14f5b;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f288e41b499202bc1365c10c60a14f5b, codeobj_f288e41b499202bc1365c10c60a14f5b, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_f288e41b499202bc1365c10c60a14f5b = cache_frame_f288e41b499202bc1365c10c60a14f5b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f288e41b499202bc1365c10c60a14f5b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f288e41b499202bc1365c10c60a14f5b ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = (PyObject *)&PyReversed_Type;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__scope_stack );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 185;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    frame_f288e41b499202bc1365c10c60a14f5b->m_frame.f_lineno = 185;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_iter_arg_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 185;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 185;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_1;

    // Tried code:
    loop_start_1:;
    tmp_next_source_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_next_source_1 );
    tmp_assign_source_2 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            type_description = "oooo";
            exception_lineno = 185;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_2;
        Py_XDECREF( old );
    }

    tmp_assign_source_3 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_3 );
    {
        PyObject *old = var_scope;
        var_scope = tmp_assign_source_3;
        Py_INCREF( var_scope );
        Py_XDECREF( old );
    }

    tmp_source_name_2 = var_scope;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_get );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 188;
        type_description = "oooo";
        goto try_except_handler_2;
    }
    tmp_args_element_name_2 = par_name;

    if ( tmp_args_element_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 188;
        type_description = "oooo";
        goto try_except_handler_2;
    }

    frame_f288e41b499202bc1365c10c60a14f5b->m_frame.f_lineno = 188;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 188;
        type_description = "oooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_in_scope;
        var_in_scope = tmp_assign_source_4;
        Py_XDECREF( old );
    }

    tmp_compare_left_1 = var_in_scope;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = Py_None;
    tmp_isnot_1 = ( tmp_compare_left_1 != tmp_compare_right_1 );
    if ( tmp_isnot_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_return_value = var_in_scope;

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "in_scope" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 189;
        type_description = "oooo";
        goto try_except_handler_2;
    }

    Py_INCREF( tmp_return_value );
    goto try_return_handler_2;
    branch_no_1:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 185;
        type_description = "oooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Return handler code:
    try_return_handler_2:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    Py_XDECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    goto frame_return_exit_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    Py_XDECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f288e41b499202bc1365c10c60a14f5b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_f288e41b499202bc1365c10c60a14f5b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f288e41b499202bc1365c10c60a14f5b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f288e41b499202bc1365c10c60a14f5b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f288e41b499202bc1365c10c60a14f5b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f288e41b499202bc1365c10c60a14f5b, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_f288e41b499202bc1365c10c60a14f5b, type_description ,par_self, par_name, var_scope, var_in_scope );

    // Release cached frame.
    if ( frame_f288e41b499202bc1365c10c60a14f5b == cache_frame_f288e41b499202bc1365c10c60a14f5b )
    {
        Py_DECREF( frame_f288e41b499202bc1365c10c60a14f5b );
    }
    cache_frame_f288e41b499202bc1365c10c60a14f5b = NULL;

    assertFrameObject( frame_f288e41b499202bc1365c10c60a14f5b );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    Py_XDECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = Py_False;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_7__is_type_in_scope );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_name );
    par_name = NULL;

    Py_XDECREF( var_scope );
    var_scope = NULL;

    Py_XDECREF( var_in_scope );
    var_in_scope = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_name );
    par_name = NULL;

    Py_XDECREF( var_scope );
    var_scope = NULL;

    Py_XDECREF( var_in_scope );
    var_in_scope = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_7__is_type_in_scope );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_8__lex_error_func( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_msg = python_pars[ 1 ];
    PyObject *par_line = python_pars[ 2 ];
    PyObject *par_column = python_pars[ 3 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_f1cc1ced8689c1a73b6a22276b413658 = NULL;

    struct Nuitka_FrameObject *frame_f1cc1ced8689c1a73b6a22276b413658;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f1cc1ced8689c1a73b6a22276b413658, codeobj_f1cc1ced8689c1a73b6a22276b413658, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_f1cc1ced8689c1a73b6a22276b413658 = cache_frame_f1cc1ced8689c1a73b6a22276b413658;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f1cc1ced8689c1a73b6a22276b413658 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f1cc1ced8689c1a73b6a22276b413658 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__parse_error );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 193;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_msg;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "msg" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 193;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 193;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 193;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = par_line;

    if ( tmp_args_element_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "line" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 193;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = par_column;

    if ( tmp_args_element_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "column" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 193;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

    frame_f1cc1ced8689c1a73b6a22276b413658->m_frame.f_lineno = 193;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_args_element_name_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 193;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    frame_f1cc1ced8689c1a73b6a22276b413658->m_frame.f_lineno = 193;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 193;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f1cc1ced8689c1a73b6a22276b413658 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f1cc1ced8689c1a73b6a22276b413658 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f1cc1ced8689c1a73b6a22276b413658, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f1cc1ced8689c1a73b6a22276b413658->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f1cc1ced8689c1a73b6a22276b413658, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_f1cc1ced8689c1a73b6a22276b413658, type_description ,par_self, par_msg, par_line, par_column );

    // Release cached frame.
    if ( frame_f1cc1ced8689c1a73b6a22276b413658 == cache_frame_f1cc1ced8689c1a73b6a22276b413658 )
    {
        Py_DECREF( frame_f1cc1ced8689c1a73b6a22276b413658 );
    }
    cache_frame_f1cc1ced8689c1a73b6a22276b413658 = NULL;

    assertFrameObject( frame_f1cc1ced8689c1a73b6a22276b413658 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_8__lex_error_func );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_msg );
    par_msg = NULL;

    Py_XDECREF( par_line );
    par_line = NULL;

    Py_XDECREF( par_column );
    par_column = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_msg );
    par_msg = NULL;

    Py_XDECREF( par_line );
    par_line = NULL;

    Py_XDECREF( par_column );
    par_column = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_8__lex_error_func );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_9__lex_on_lbrace_func( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_a0f37948e5f35b331da261a1dc94d087 = NULL;

    struct Nuitka_FrameObject *frame_a0f37948e5f35b331da261a1dc94d087;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a0f37948e5f35b331da261a1dc94d087, codeobj_a0f37948e5f35b331da261a1dc94d087, module_pycparser$c_parser, sizeof(PyObject *) );
    frame_a0f37948e5f35b331da261a1dc94d087 = cache_frame_a0f37948e5f35b331da261a1dc94d087;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a0f37948e5f35b331da261a1dc94d087 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a0f37948e5f35b331da261a1dc94d087 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_a0f37948e5f35b331da261a1dc94d087->m_frame.f_lineno = 196;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__push_scope );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 196;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a0f37948e5f35b331da261a1dc94d087 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a0f37948e5f35b331da261a1dc94d087 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a0f37948e5f35b331da261a1dc94d087, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a0f37948e5f35b331da261a1dc94d087->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a0f37948e5f35b331da261a1dc94d087, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_a0f37948e5f35b331da261a1dc94d087, type_description ,par_self );

    // Release cached frame.
    if ( frame_a0f37948e5f35b331da261a1dc94d087 == cache_frame_a0f37948e5f35b331da261a1dc94d087 )
    {
        Py_DECREF( frame_a0f37948e5f35b331da261a1dc94d087 );
    }
    cache_frame_a0f37948e5f35b331da261a1dc94d087 = NULL;

    assertFrameObject( frame_a0f37948e5f35b331da261a1dc94d087 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_9__lex_on_lbrace_func );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_9__lex_on_lbrace_func );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_10__lex_on_rbrace_func( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_f7642558c29696ca9e24e1bcaca82789 = NULL;

    struct Nuitka_FrameObject *frame_f7642558c29696ca9e24e1bcaca82789;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f7642558c29696ca9e24e1bcaca82789, codeobj_f7642558c29696ca9e24e1bcaca82789, module_pycparser$c_parser, sizeof(PyObject *) );
    frame_f7642558c29696ca9e24e1bcaca82789 = cache_frame_f7642558c29696ca9e24e1bcaca82789;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f7642558c29696ca9e24e1bcaca82789 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f7642558c29696ca9e24e1bcaca82789 ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_f7642558c29696ca9e24e1bcaca82789->m_frame.f_lineno = 199;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__pop_scope );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 199;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f7642558c29696ca9e24e1bcaca82789 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f7642558c29696ca9e24e1bcaca82789 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f7642558c29696ca9e24e1bcaca82789, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f7642558c29696ca9e24e1bcaca82789->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f7642558c29696ca9e24e1bcaca82789, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_f7642558c29696ca9e24e1bcaca82789, type_description ,par_self );

    // Release cached frame.
    if ( frame_f7642558c29696ca9e24e1bcaca82789 == cache_frame_f7642558c29696ca9e24e1bcaca82789 )
    {
        Py_DECREF( frame_f7642558c29696ca9e24e1bcaca82789 );
    }
    cache_frame_f7642558c29696ca9e24e1bcaca82789 = NULL;

    assertFrameObject( frame_f7642558c29696ca9e24e1bcaca82789 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_10__lex_on_rbrace_func );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_10__lex_on_rbrace_func );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_11__lex_type_lookup_func( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    PyObject *var_is_type = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_3c130929c04ff996d230a179e832aca1 = NULL;

    struct Nuitka_FrameObject *frame_3c130929c04ff996d230a179e832aca1;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3c130929c04ff996d230a179e832aca1, codeobj_3c130929c04ff996d230a179e832aca1, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_3c130929c04ff996d230a179e832aca1 = cache_frame_3c130929c04ff996d230a179e832aca1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3c130929c04ff996d230a179e832aca1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3c130929c04ff996d230a179e832aca1 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__is_type_in_scope );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 207;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_name;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "name" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 207;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    frame_3c130929c04ff996d230a179e832aca1->m_frame.f_lineno = 207;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 207;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_is_type == NULL );
    var_is_type = tmp_assign_source_1;


#if 0
    RESTORE_FRAME_EXCEPTION( frame_3c130929c04ff996d230a179e832aca1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3c130929c04ff996d230a179e832aca1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3c130929c04ff996d230a179e832aca1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3c130929c04ff996d230a179e832aca1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3c130929c04ff996d230a179e832aca1, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_3c130929c04ff996d230a179e832aca1, type_description ,par_self, par_name, var_is_type );

    // Release cached frame.
    if ( frame_3c130929c04ff996d230a179e832aca1 == cache_frame_3c130929c04ff996d230a179e832aca1 )
    {
        Py_DECREF( frame_3c130929c04ff996d230a179e832aca1 );
    }
    cache_frame_3c130929c04ff996d230a179e832aca1 = NULL;

    assertFrameObject( frame_3c130929c04ff996d230a179e832aca1 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_is_type;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_11__lex_type_lookup_func );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_name );
    par_name = NULL;

    Py_XDECREF( var_is_type );
    var_is_type = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_name );
    par_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_11__lex_type_lookup_func );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_12__get_yacc_lookahead_token( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_b46c585229a82084cf4cd60f525bdce1 = NULL;

    struct Nuitka_FrameObject *frame_b46c585229a82084cf4cd60f525bdce1;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b46c585229a82084cf4cd60f525bdce1, codeobj_b46c585229a82084cf4cd60f525bdce1, module_pycparser$c_parser, sizeof(PyObject *) );
    frame_b46c585229a82084cf4cd60f525bdce1 = cache_frame_b46c585229a82084cf4cd60f525bdce1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b46c585229a82084cf4cd60f525bdce1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b46c585229a82084cf4cd60f525bdce1 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_clex );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 215;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_last_token );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 215;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b46c585229a82084cf4cd60f525bdce1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_b46c585229a82084cf4cd60f525bdce1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b46c585229a82084cf4cd60f525bdce1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b46c585229a82084cf4cd60f525bdce1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b46c585229a82084cf4cd60f525bdce1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b46c585229a82084cf4cd60f525bdce1, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_b46c585229a82084cf4cd60f525bdce1, type_description ,par_self );

    // Release cached frame.
    if ( frame_b46c585229a82084cf4cd60f525bdce1 == cache_frame_b46c585229a82084cf4cd60f525bdce1 )
    {
        Py_DECREF( frame_b46c585229a82084cf4cd60f525bdce1 );
    }
    cache_frame_b46c585229a82084cf4cd60f525bdce1 = NULL;

    assertFrameObject( frame_b46c585229a82084cf4cd60f525bdce1 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_12__get_yacc_lookahead_token );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_12__get_yacc_lookahead_token );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_13__type_modify_decl( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_decl = python_pars[ 1 ];
    PyObject *par_modifier = python_pars[ 2 ];
    PyObject *var_modifier_head = NULL;
    PyObject *var_modifier_tail = NULL;
    PyObject *var_decl_tail = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_name_3;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assattr_target_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_cls_2;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_isinstance_inst_2;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    static struct Nuitka_FrameObject *cache_frame_e70c38497d0ec9a52c2ff1f534573b49 = NULL;

    struct Nuitka_FrameObject *frame_e70c38497d0ec9a52c2ff1f534573b49;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_assign_source_1 = par_modifier;

    CHECK_OBJECT( tmp_assign_source_1 );
    assert( var_modifier_head == NULL );
    Py_INCREF( tmp_assign_source_1 );
    var_modifier_head = tmp_assign_source_1;

    tmp_assign_source_2 = par_modifier;

    CHECK_OBJECT( tmp_assign_source_2 );
    assert( var_modifier_tail == NULL );
    Py_INCREF( tmp_assign_source_2 );
    var_modifier_tail = tmp_assign_source_2;

    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e70c38497d0ec9a52c2ff1f534573b49, codeobj_e70c38497d0ec9a52c2ff1f534573b49, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_e70c38497d0ec9a52c2ff1f534573b49 = cache_frame_e70c38497d0ec9a52c2ff1f534573b49;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e70c38497d0ec9a52c2ff1f534573b49 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e70c38497d0ec9a52c2ff1f534573b49 ) == 2 ); // Frame stack

    // Framed code:
    loop_start_1:;
    tmp_source_name_1 = var_modifier_tail;

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "modifier_tail" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 267;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_cond_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_type );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 267;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 267;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    goto loop_end_1;
    branch_no_1:;
    tmp_source_name_2 = var_modifier_tail;

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "modifier_tail" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 268;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_assign_source_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_type );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 268;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_modifier_tail;
        var_modifier_tail = tmp_assign_source_3;
        Py_XDECREF( old );
    }

    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 267;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    goto loop_start_1;
    loop_end_1:;
    tmp_isinstance_inst_1 = par_decl;

    if ( tmp_isinstance_inst_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decl" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 273;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 273;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_isinstance_cls_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_TypeDecl );
    if ( tmp_isinstance_cls_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 273;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    Py_DECREF( tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 273;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_assattr_name_1 = par_decl;

    if ( tmp_assattr_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decl" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 274;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_assattr_target_1 = var_modifier_tail;

    if ( tmp_assattr_target_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "modifier_tail" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 274;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_type, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 274;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = par_modifier;

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "modifier" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 275;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    goto branch_end_2;
    branch_no_2:;
    tmp_assign_source_4 = par_decl;

    if ( tmp_assign_source_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decl" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 281;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    assert( var_decl_tail == NULL );
    Py_INCREF( tmp_assign_source_4 );
    var_decl_tail = tmp_assign_source_4;

    loop_start_2:;
    tmp_source_name_4 = var_decl_tail;

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decl_tail" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 283;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_isinstance_inst_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_type );
    if ( tmp_isinstance_inst_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 283;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_5 == NULL )
    {
        Py_DECREF( tmp_isinstance_inst_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 283;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_isinstance_cls_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_TypeDecl );
    if ( tmp_isinstance_cls_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_isinstance_inst_2 );

        exception_lineno = 283;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
    Py_DECREF( tmp_isinstance_inst_2 );
    Py_DECREF( tmp_isinstance_cls_2 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 283;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    goto loop_end_2;
    branch_no_3:;
    tmp_source_name_6 = var_decl_tail;

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decl_tail" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 284;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_assign_source_5 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_type );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 284;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_decl_tail;
        var_decl_tail = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 283;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    goto loop_start_2;
    loop_end_2:;
    tmp_source_name_7 = var_decl_tail;

    if ( tmp_source_name_7 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decl_tail" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 286;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_assattr_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_type );
    if ( tmp_assattr_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 286;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_2 = var_modifier_tail;

    if ( tmp_assattr_target_2 == NULL )
    {
        Py_DECREF( tmp_assattr_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "modifier_tail" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 286;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_type, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_2 );

        exception_lineno = 286;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_2 );
    tmp_assattr_name_3 = var_modifier_head;

    if ( tmp_assattr_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "modifier_head" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 287;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_assattr_target_3 = var_decl_tail;

    if ( tmp_assattr_target_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decl_tail" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 287;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain_type, tmp_assattr_name_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 287;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = par_decl;

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decl" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 288;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_end_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e70c38497d0ec9a52c2ff1f534573b49 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_e70c38497d0ec9a52c2ff1f534573b49 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e70c38497d0ec9a52c2ff1f534573b49 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e70c38497d0ec9a52c2ff1f534573b49, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e70c38497d0ec9a52c2ff1f534573b49->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e70c38497d0ec9a52c2ff1f534573b49, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_e70c38497d0ec9a52c2ff1f534573b49, type_description ,par_self, par_decl, par_modifier, var_modifier_head, var_modifier_tail, var_decl_tail );

    // Release cached frame.
    if ( frame_e70c38497d0ec9a52c2ff1f534573b49 == cache_frame_e70c38497d0ec9a52c2ff1f534573b49 )
    {
        Py_DECREF( frame_e70c38497d0ec9a52c2ff1f534573b49 );
    }
    cache_frame_e70c38497d0ec9a52c2ff1f534573b49 = NULL;

    assertFrameObject( frame_e70c38497d0ec9a52c2ff1f534573b49 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_13__type_modify_decl );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_decl );
    par_decl = NULL;

    Py_XDECREF( par_modifier );
    par_modifier = NULL;

    Py_XDECREF( var_modifier_head );
    var_modifier_head = NULL;

    Py_XDECREF( var_modifier_tail );
    var_modifier_tail = NULL;

    Py_XDECREF( var_decl_tail );
    var_decl_tail = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_decl );
    par_decl = NULL;

    Py_XDECREF( par_modifier );
    par_modifier = NULL;

    Py_XDECREF( var_modifier_head );
    var_modifier_head = NULL;

    Py_XDECREF( var_modifier_tail );
    var_modifier_tail = NULL;

    Py_XDECREF( var_decl_tail );
    var_decl_tail = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_13__type_modify_decl );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_14__fix_decl_name_type( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_decl = python_pars[ 1 ];
    PyObject *par_typename = python_pars[ 2 ];
    PyObject *var_type = NULL;
    PyObject *var_tn = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_name_1;
    PyObject *tmp_args_name_2;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_name_3;
    PyObject *tmp_assattr_name_4;
    PyObject *tmp_assattr_name_5;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assattr_target_3;
    PyObject *tmp_assattr_target_4;
    PyObject *tmp_assattr_target_5;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    int tmp_cmp_Gt_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dircall_arg1_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_cls_2;
    PyObject *tmp_isinstance_cls_3;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_isinstance_inst_2;
    PyObject *tmp_isinstance_inst_3;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_iter_arg_2;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_kw_name_2;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_next_source_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_source_name_11;
    PyObject *tmp_source_name_12;
    PyObject *tmp_source_name_13;
    PyObject *tmp_source_name_14;
    PyObject *tmp_source_name_15;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_tuple_element_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_7d6be3b889381e9206fe16ac40003ac8 = NULL;

    struct Nuitka_FrameObject *frame_7d6be3b889381e9206fe16ac40003ac8;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_assign_source_1 = par_decl;

    CHECK_OBJECT( tmp_assign_source_1 );
    assert( var_type == NULL );
    Py_INCREF( tmp_assign_source_1 );
    var_type = tmp_assign_source_1;

    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7d6be3b889381e9206fe16ac40003ac8, codeobj_7d6be3b889381e9206fe16ac40003ac8, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_7d6be3b889381e9206fe16ac40003ac8 = cache_frame_7d6be3b889381e9206fe16ac40003ac8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7d6be3b889381e9206fe16ac40003ac8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7d6be3b889381e9206fe16ac40003ac8 ) == 2 ); // Frame stack

    // Framed code:
    loop_start_1:;
    tmp_isinstance_inst_1 = var_type;

    if ( tmp_isinstance_inst_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "type" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 312;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 312;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_isinstance_cls_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_TypeDecl );
    if ( tmp_isinstance_cls_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 312;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    Py_DECREF( tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 312;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    goto loop_end_1;
    branch_no_1:;
    tmp_source_name_2 = var_type;

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "type" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 313;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_assign_source_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_type );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 313;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_type;
        var_type = tmp_assign_source_2;
        Py_XDECREF( old );
    }

    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 312;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    goto loop_start_1;
    loop_end_1:;
    tmp_source_name_3 = var_type;

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "type" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 315;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_assattr_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_declname );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 315;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = par_decl;

    if ( tmp_assattr_target_1 == NULL )
    {
        Py_DECREF( tmp_assattr_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decl" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 315;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_name, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 315;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );
    tmp_source_name_4 = par_decl;

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decl" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 316;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_assattr_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_quals );
    if ( tmp_assattr_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 316;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_2 = var_type;

    if ( tmp_assattr_target_2 == NULL )
    {
        Py_DECREF( tmp_assattr_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "type" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 316;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_quals, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_2 );

        exception_lineno = 316;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_2 );
    tmp_iter_arg_1 = par_typename;

    if ( tmp_iter_arg_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "typename" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 324;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_assign_source_3 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 324;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_3;

    // Tried code:
    loop_start_2:;
    tmp_next_source_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_next_source_1 );
    tmp_assign_source_4 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_4 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_2;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            type_description = "ooooo";
            exception_lineno = 324;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_4;
        Py_XDECREF( old );
    }

    tmp_assign_source_5 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_5 );
    {
        PyObject *old = var_tn;
        var_tn = tmp_assign_source_5;
        Py_INCREF( var_tn );
        Py_XDECREF( old );
    }

    tmp_isinstance_inst_2 = var_tn;

    CHECK_OBJECT( tmp_isinstance_inst_2 );
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 325;
        type_description = "ooooo";
        goto try_except_handler_2;
    }

    tmp_isinstance_cls_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_IdentifierType );
    if ( tmp_isinstance_cls_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 325;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
    Py_DECREF( tmp_isinstance_cls_2 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 325;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_len_arg_1 = par_typename;

    if ( tmp_len_arg_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "typename" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 326;
        type_description = "ooooo";
        goto try_except_handler_2;
    }

    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 326;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    tmp_compare_right_1 = const_int_pos_1;
    tmp_cmp_Gt_1 = RICH_COMPARE_BOOL_GT( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Gt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 326;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Gt_1 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_source_name_6 = par_self;

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 327;
        type_description = "ooooo";
        goto try_except_handler_2;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__parse_error );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 327;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    tmp_args_element_name_1 = const_str_digest_0037b7bb71b496183bd8ef3fbe80fbf7;
    tmp_source_name_7 = var_tn;

    if ( tmp_source_name_7 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "tn" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 328;
        type_description = "ooooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_coord );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 328;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    frame_7d6be3b889381e9206fe16ac40003ac8->m_frame.f_lineno = 327;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 327;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_3;
    branch_no_3:;
    tmp_assattr_name_3 = var_tn;

    if ( tmp_assattr_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "tn" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 330;
        type_description = "ooooo";
        goto try_except_handler_2;
    }

    tmp_assattr_target_3 = var_type;

    if ( tmp_assattr_target_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "type" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 330;
        type_description = "ooooo";
        goto try_except_handler_2;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain_type, tmp_assattr_name_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 330;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    tmp_return_value = par_decl;

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decl" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 331;
        type_description = "ooooo";
        goto try_except_handler_2;
    }

    Py_INCREF( tmp_return_value );
    goto try_return_handler_2;
    branch_end_3:;
    branch_no_2:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 324;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    goto loop_start_2;
    loop_end_2:;
    goto try_end_1;
    // Return handler code:
    try_return_handler_2:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    Py_XDECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    goto frame_return_exit_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    Py_XDECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    Py_XDECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_cond_value_1 = par_typename;

    if ( tmp_cond_value_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "typename" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 333;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 333;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_4;
    }
    else
    {
        goto branch_yes_4;
    }
    branch_yes_4:;
    tmp_source_name_8 = par_decl;

    if ( tmp_source_name_8 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decl" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 336;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_isinstance_inst_3 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_type );
    if ( tmp_isinstance_inst_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 336;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_9 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_9 == NULL ))
    {
        tmp_source_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_9 == NULL )
    {
        Py_DECREF( tmp_isinstance_inst_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 336;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_isinstance_cls_3 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_FuncDecl );
    if ( tmp_isinstance_cls_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_isinstance_inst_3 );

        exception_lineno = 336;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_3, tmp_isinstance_cls_3 );
    Py_DECREF( tmp_isinstance_inst_3 );
    Py_DECREF( tmp_isinstance_cls_3 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 336;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_5;
    }
    else
    {
        goto branch_yes_5;
    }
    branch_yes_5:;
    tmp_source_name_10 = par_self;

    if ( tmp_source_name_10 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 337;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain__parse_error );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 337;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = const_str_digest_35fa98ecde313fbb87f970e5b6d1309e;
    tmp_source_name_11 = par_decl;

    if ( tmp_source_name_11 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decl" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 338;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_coord );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 338;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_7d6be3b889381e9206fe16ac40003ac8->m_frame.f_lineno = 337;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 337;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_5:;
    tmp_source_name_12 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_12 == NULL ))
    {
        tmp_source_name_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_12 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 339;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_IdentifierType );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 339;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_name_1 = DEEP_COPY( const_tuple_list_str_plain_int_list_tuple );
    tmp_kw_name_1 = _PyDict_NewPresized( 1 );
    tmp_dict_key_1 = const_str_plain_coord;
    tmp_source_name_13 = par_decl;

    if ( tmp_source_name_13 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decl" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 341;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_dict_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_coord );
    if ( tmp_dict_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 341;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    Py_DECREF( tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    frame_7d6be3b889381e9206fe16ac40003ac8->m_frame.f_lineno = 339;
    tmp_assattr_name_4 = CALL_FUNCTION( tmp_called_name_3, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_assattr_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 339;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_4 = var_type;

    if ( tmp_assattr_target_4 == NULL )
    {
        Py_DECREF( tmp_assattr_name_4 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "type" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 339;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain_type, tmp_assattr_name_4 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_4 );

        exception_lineno = 339;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_4 );
    goto branch_end_4;
    branch_no_4:;
    tmp_source_name_14 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_14 == NULL ))
    {
        tmp_source_name_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_14 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 346;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain_IdentifierType );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 346;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_name_2 = PyTuple_New( 1 );
    tmp_iter_arg_2 = par_typename;

    if ( tmp_iter_arg_2 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "typename" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 347;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_dircall_arg1_1 = MAKE_ITERATOR( tmp_iter_arg_2 );
    if ( tmp_dircall_arg1_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_name_2 );

        exception_lineno = 347;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    {
        PyObject *dir_call_args[] = {tmp_dircall_arg1_1};
        tmp_tuple_element_1 = impl_pycparser$c_parser$$$class_1_CParser$$$function_14__fix_decl_name_type$$$function_1_listcontraction( dir_call_args );
    }
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_name_2 );

        exception_lineno = 347;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_args_name_2, 0, tmp_tuple_element_1 );
    tmp_kw_name_2 = _PyDict_NewPresized( 1 );
    tmp_dict_key_2 = const_str_plain_coord;
    tmp_subscribed_name_1 = par_typename;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_name_2 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "typename" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 348;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_0;
    tmp_source_name_15 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_source_name_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_name_2 );
        Py_DECREF( tmp_kw_name_2 );

        exception_lineno = 348;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_dict_value_2 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain_coord );
    Py_DECREF( tmp_source_name_15 );
    if ( tmp_dict_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_name_2 );
        Py_DECREF( tmp_kw_name_2 );

        exception_lineno = 348;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_2, tmp_dict_value_2 );
    Py_DECREF( tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    frame_7d6be3b889381e9206fe16ac40003ac8->m_frame.f_lineno = 346;
    tmp_assattr_name_5 = CALL_FUNCTION( tmp_called_name_4, tmp_args_name_2, tmp_kw_name_2 );
    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_name_2 );
    Py_DECREF( tmp_kw_name_2 );
    if ( tmp_assattr_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 346;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_5 = var_type;

    if ( tmp_assattr_target_5 == NULL )
    {
        Py_DECREF( tmp_assattr_name_5 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "type" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 346;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_5, const_str_plain_type, tmp_assattr_name_5 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_5 );

        exception_lineno = 346;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_5 );
    branch_end_4:;
    tmp_return_value = par_decl;

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decl" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 349;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7d6be3b889381e9206fe16ac40003ac8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_7d6be3b889381e9206fe16ac40003ac8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7d6be3b889381e9206fe16ac40003ac8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7d6be3b889381e9206fe16ac40003ac8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7d6be3b889381e9206fe16ac40003ac8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7d6be3b889381e9206fe16ac40003ac8, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_7d6be3b889381e9206fe16ac40003ac8, type_description ,par_self, par_decl, par_typename, var_type, var_tn );

    // Release cached frame.
    if ( frame_7d6be3b889381e9206fe16ac40003ac8 == cache_frame_7d6be3b889381e9206fe16ac40003ac8 )
    {
        Py_DECREF( frame_7d6be3b889381e9206fe16ac40003ac8 );
    }
    cache_frame_7d6be3b889381e9206fe16ac40003ac8 = NULL;

    assertFrameObject( frame_7d6be3b889381e9206fe16ac40003ac8 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_14__fix_decl_name_type );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_decl );
    par_decl = NULL;

    Py_XDECREF( par_typename );
    par_typename = NULL;

    Py_XDECREF( var_type );
    var_type = NULL;

    Py_XDECREF( var_tn );
    var_tn = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_decl );
    par_decl = NULL;

    Py_XDECREF( par_typename );
    par_typename = NULL;

    Py_XDECREF( var_type );
    var_type = NULL;

    Py_XDECREF( var_tn );
    var_tn = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_14__fix_decl_name_type );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


NUITKA_LOCAL_MODULE PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_14__fix_decl_name_type$$$function_1_listcontraction( PyObject **python_pars )
{
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
    assert(!had_error); // Do not enter inlined functions with error set.
#endif

    // Local variable declarations.
    PyObject *par_$0 = python_pars[ 0 ];
    PyObject *var_id = NULL;
    PyObject *var_name = NULL;
    PyObject *tmp_contraction_iter_0 = NULL;
    PyObject *tmp_contraction_result = NULL;
    PyObject *tmp_iter_value_0 = NULL;
    PyObject *tmp_iter_value_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_append_list_1;
    PyObject *tmp_append_value_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_next_source_1;
    PyObject *tmp_next_source_2;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_a122c51f99f20e77765ca39c1f6ed2f1 = NULL;

    struct Nuitka_FrameObject *frame_a122c51f99f20e77765ca39c1f6ed2f1;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_assign_source_1 = PyList_New( 0 );
    assert( tmp_contraction_result == NULL );
    tmp_contraction_result = tmp_assign_source_1;

    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a122c51f99f20e77765ca39c1f6ed2f1, codeobj_a122c51f99f20e77765ca39c1f6ed2f1, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_a122c51f99f20e77765ca39c1f6ed2f1 = cache_frame_a122c51f99f20e77765ca39c1f6ed2f1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a122c51f99f20e77765ca39c1f6ed2f1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a122c51f99f20e77765ca39c1f6ed2f1 ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    loop_start_1:;
    tmp_next_source_1 = par_$0;

    CHECK_OBJECT( tmp_next_source_1 );
    tmp_assign_source_2 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            type_description = "ooo";
            exception_lineno = 347;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_iter_value_1;
        tmp_iter_value_1 = tmp_assign_source_2;
        Py_XDECREF( old );
    }

    tmp_assign_source_3 = tmp_iter_value_1;

    CHECK_OBJECT( tmp_assign_source_3 );
    {
        PyObject *old = var_id;
        var_id = tmp_assign_source_3;
        Py_INCREF( var_id );
        Py_XDECREF( old );
    }

    tmp_source_name_1 = var_id;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_iter_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_names );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 347;
        type_description = "ooo";
        goto try_except_handler_2;
    }
    tmp_assign_source_4 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 347;
        type_description = "ooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = tmp_contraction_iter_0;
        tmp_contraction_iter_0 = tmp_assign_source_4;
        Py_XDECREF( old );
    }

    loop_start_2:;
    tmp_next_source_2 = tmp_contraction_iter_0;

    CHECK_OBJECT( tmp_next_source_2 );
    tmp_assign_source_5 = ITERATOR_NEXT( tmp_next_source_2 );
    if ( tmp_assign_source_5 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_2;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            type_description = "ooo";
            exception_lineno = 347;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_iter_value_0;
        tmp_iter_value_0 = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    tmp_assign_source_6 = tmp_iter_value_0;

    CHECK_OBJECT( tmp_assign_source_6 );
    {
        PyObject *old = var_name;
        var_name = tmp_assign_source_6;
        Py_INCREF( var_name );
        Py_XDECREF( old );
    }

    tmp_append_list_1 = tmp_contraction_result;

    CHECK_OBJECT( tmp_append_list_1 );
    tmp_append_value_1 = var_name;

    CHECK_OBJECT( tmp_append_value_1 );
    assert( PyList_Check( tmp_append_list_1 ) );
    tmp_res = PyList_Append( tmp_append_list_1, tmp_append_value_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 347;
        type_description = "ooo";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 347;
        type_description = "ooo";
        goto try_except_handler_2;
    }
    goto loop_start_2;
    loop_end_2:;
    Py_XDECREF( tmp_contraction_iter_0 );
    tmp_contraction_iter_0 = NULL;

    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 347;
        type_description = "ooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    tmp_return_value = tmp_contraction_result;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_2;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_14__fix_decl_name_type$$$function_1_listcontraction );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    Py_XDECREF( tmp_contraction_result );
    tmp_contraction_result = NULL;

    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    Py_XDECREF( tmp_contraction_iter_0 );
    tmp_contraction_iter_0 = NULL;

    Py_XDECREF( tmp_iter_value_1 );
    tmp_iter_value_1 = NULL;

    goto frame_return_exit_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_contraction_result );
    tmp_contraction_result = NULL;

    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    Py_XDECREF( tmp_contraction_iter_0 );
    tmp_contraction_iter_0 = NULL;

    Py_XDECREF( tmp_iter_value_1 );
    tmp_iter_value_1 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a122c51f99f20e77765ca39c1f6ed2f1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_a122c51f99f20e77765ca39c1f6ed2f1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a122c51f99f20e77765ca39c1f6ed2f1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a122c51f99f20e77765ca39c1f6ed2f1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a122c51f99f20e77765ca39c1f6ed2f1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a122c51f99f20e77765ca39c1f6ed2f1, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_a122c51f99f20e77765ca39c1f6ed2f1, type_description ,par_$0, var_id, var_name );

    // Release cached frame.
    if ( frame_a122c51f99f20e77765ca39c1f6ed2f1 == cache_frame_a122c51f99f20e77765ca39c1f6ed2f1 )
    {
        Py_DECREF( frame_a122c51f99f20e77765ca39c1f6ed2f1 );
    }
    cache_frame_a122c51f99f20e77765ca39c1f6ed2f1 = NULL;

    assertFrameObject( frame_a122c51f99f20e77765ca39c1f6ed2f1 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_14__fix_decl_name_type$$$function_1_listcontraction );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_$0 );
    par_$0 = NULL;

    Py_XDECREF( var_id );
    var_id = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_$0 );
    par_$0 = NULL;

    Py_XDECREF( var_id );
    var_id = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_14__fix_decl_name_type$$$function_1_listcontraction );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_15__add_declaration_specifier( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_declspec = python_pars[ 1 ];
    PyObject *par_newspec = python_pars[ 2 ];
    PyObject *par_kind = python_pars[ 3 ];
    PyObject *par_append = python_pars[ 4 ];
    PyObject *var_spec = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    int tmp_or_left_truth_1;
    PyObject *tmp_or_left_value_1;
    PyObject *tmp_or_right_value_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_fd2885a07b4bce7ac41dae2e3701ce8e = NULL;

    struct Nuitka_FrameObject *frame_fd2885a07b4bce7ac41dae2e3701ce8e;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_fd2885a07b4bce7ac41dae2e3701ce8e, codeobj_fd2885a07b4bce7ac41dae2e3701ce8e, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_fd2885a07b4bce7ac41dae2e3701ce8e = cache_frame_fd2885a07b4bce7ac41dae2e3701ce8e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_fd2885a07b4bce7ac41dae2e3701ce8e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_fd2885a07b4bce7ac41dae2e3701ce8e ) == 2 ); // Frame stack

    // Framed code:
    tmp_or_left_value_1 = par_declspec;

    CHECK_OBJECT( tmp_or_left_value_1 );
    tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
    if ( tmp_or_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 366;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_or_left_truth_1 == 1 )
    {
        goto or_left_1;
    }
    else
    {
        goto or_right_1;
    }
    or_right_1:;
    tmp_or_right_value_1 = DEEP_COPY( const_dict_a65047c1ba5fd08918aea9f317bf9947 );
    tmp_assign_source_1 = tmp_or_right_value_1;
    goto or_end_1;
    or_left_1:;
    Py_INCREF( tmp_or_left_value_1 );
    tmp_assign_source_1 = tmp_or_left_value_1;
    or_end_1:;
    assert( var_spec == NULL );
    var_spec = tmp_assign_source_1;

    tmp_cond_value_1 = par_append;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 368;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_subscribed_name_1 = var_spec;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = par_kind;

    CHECK_OBJECT( tmp_subscript_name_1 );
    tmp_source_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 369;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_append );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 369;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_newspec;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "newspec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 369;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    frame_fd2885a07b4bce7ac41dae2e3701ce8e->m_frame.f_lineno = 369;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 369;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_1;
    branch_no_1:;
    tmp_subscribed_name_2 = var_spec;

    CHECK_OBJECT( tmp_subscribed_name_2 );
    tmp_subscript_name_2 = par_kind;

    CHECK_OBJECT( tmp_subscript_name_2 );
    tmp_source_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_source_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 371;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_insert );
    Py_DECREF( tmp_source_name_2 );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 371;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = const_int_0;
    tmp_args_element_name_3 = par_newspec;

    if ( tmp_args_element_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "newspec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 371;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    frame_fd2885a07b4bce7ac41dae2e3701ce8e->m_frame.f_lineno = 371;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 371;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_end_1:;
    tmp_return_value = var_spec;

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 373;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fd2885a07b4bce7ac41dae2e3701ce8e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_fd2885a07b4bce7ac41dae2e3701ce8e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fd2885a07b4bce7ac41dae2e3701ce8e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_fd2885a07b4bce7ac41dae2e3701ce8e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_fd2885a07b4bce7ac41dae2e3701ce8e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_fd2885a07b4bce7ac41dae2e3701ce8e, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_fd2885a07b4bce7ac41dae2e3701ce8e, type_description ,par_self, par_declspec, par_newspec, par_kind, par_append, var_spec );

    // Release cached frame.
    if ( frame_fd2885a07b4bce7ac41dae2e3701ce8e == cache_frame_fd2885a07b4bce7ac41dae2e3701ce8e )
    {
        Py_DECREF( frame_fd2885a07b4bce7ac41dae2e3701ce8e );
    }
    cache_frame_fd2885a07b4bce7ac41dae2e3701ce8e = NULL;

    assertFrameObject( frame_fd2885a07b4bce7ac41dae2e3701ce8e );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_15__add_declaration_specifier );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_declspec );
    par_declspec = NULL;

    Py_XDECREF( par_newspec );
    par_newspec = NULL;

    Py_XDECREF( par_kind );
    par_kind = NULL;

    Py_XDECREF( par_append );
    par_append = NULL;

    Py_XDECREF( var_spec );
    var_spec = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_declspec );
    par_declspec = NULL;

    Py_XDECREF( par_newspec );
    par_newspec = NULL;

    Py_XDECREF( par_kind );
    par_kind = NULL;

    Py_XDECREF( par_append );
    par_append = NULL;

    Py_XDECREF( var_spec );
    var_spec = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_15__add_declaration_specifier );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_16__build_declarations( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_spec = python_pars[ 1 ];
    PyObject *par_decls = python_pars[ 2 ];
    PyObject *par_typedef_namespace = python_pars[ 3 ];
    PyObject *var_is_typedef = NULL;
    PyObject *var_declarations = NULL;
    PyObject *var_coord = NULL;
    PyObject *var_t = NULL;
    PyObject *var_decls_0_tail = NULL;
    PyObject *var_decl = NULL;
    PyObject *var_declaration = NULL;
    PyObject *var_fixed_decl = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_for_loop_2__for_iterator = NULL;
    PyObject *tmp_for_loop_2__iter_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_assign_source_12;
    PyObject *tmp_assign_source_13;
    PyObject *tmp_assign_source_14;
    PyObject *tmp_assign_source_15;
    PyObject *tmp_assign_source_16;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_left_4;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compare_right_4;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_left_3;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    PyObject *tmp_compexpr_right_3;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    int tmp_cond_truth_3;
    int tmp_cond_truth_4;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_cond_value_3;
    PyObject *tmp_cond_value_4;
    PyObject *tmp_delsubscr_subscript_1;
    PyObject *tmp_delsubscr_subscript_2;
    PyObject *tmp_delsubscr_target_1;
    PyObject *tmp_delsubscr_target_2;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_key_4;
    PyObject *tmp_dict_key_5;
    PyObject *tmp_dict_key_6;
    PyObject *tmp_dict_key_7;
    PyObject *tmp_dict_key_8;
    PyObject *tmp_dict_key_9;
    PyObject *tmp_dict_key_10;
    PyObject *tmp_dict_key_11;
    PyObject *tmp_dict_key_12;
    PyObject *tmp_dict_key_13;
    PyObject *tmp_dict_key_14;
    PyObject *tmp_dict_key_15;
    PyObject *tmp_dict_key_16;
    PyObject *tmp_dict_key_17;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_dict_value_4;
    PyObject *tmp_dict_value_5;
    PyObject *tmp_dict_value_6;
    PyObject *tmp_dict_value_7;
    PyObject *tmp_dict_value_8;
    PyObject *tmp_dict_value_9;
    PyObject *tmp_dict_value_10;
    PyObject *tmp_dict_value_11;
    PyObject *tmp_dict_value_12;
    PyObject *tmp_dict_value_13;
    PyObject *tmp_dict_value_14;
    PyObject *tmp_dict_value_15;
    PyObject *tmp_dict_value_16;
    PyObject *tmp_dict_value_17;
    PyObject *tmp_hasattr_attr_1;
    PyObject *tmp_hasattr_source_1;
    bool tmp_is_1;
    bool tmp_is_2;
    bool tmp_is_3;
    bool tmp_is_4;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_cls_2;
    PyObject *tmp_isinstance_cls_3;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_isinstance_inst_2;
    PyObject *tmp_isinstance_inst_3;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_iter_arg_2;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_kw_name_2;
    PyObject *tmp_kw_name_3;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_len_arg_2;
    PyObject *tmp_next_source_1;
    PyObject *tmp_next_source_2;
    PyObject *tmp_operand_name_1;
    int tmp_or_left_truth_1;
    int tmp_or_left_truth_2;
    PyObject *tmp_or_left_value_1;
    PyObject *tmp_or_left_value_2;
    PyObject *tmp_or_right_value_1;
    PyObject *tmp_or_right_value_2;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_source_name_11;
    PyObject *tmp_source_name_12;
    PyObject *tmp_source_name_13;
    PyObject *tmp_source_name_14;
    PyObject *tmp_source_name_15;
    PyObject *tmp_source_name_16;
    PyObject *tmp_source_name_17;
    PyObject *tmp_source_name_18;
    PyObject *tmp_source_name_19;
    PyObject *tmp_source_name_20;
    PyObject *tmp_source_name_21;
    PyObject *tmp_source_name_22;
    PyObject *tmp_source_name_23;
    PyObject *tmp_source_name_24;
    PyObject *tmp_source_name_25;
    PyObject *tmp_source_name_26;
    PyObject *tmp_source_name_27;
    PyObject *tmp_source_name_28;
    PyObject *tmp_source_name_29;
    PyObject *tmp_source_name_30;
    PyObject *tmp_source_name_31;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscribed_name_5;
    PyObject *tmp_subscribed_name_6;
    PyObject *tmp_subscribed_name_7;
    PyObject *tmp_subscribed_name_8;
    PyObject *tmp_subscribed_name_9;
    PyObject *tmp_subscribed_name_10;
    PyObject *tmp_subscribed_name_11;
    PyObject *tmp_subscribed_name_12;
    PyObject *tmp_subscribed_name_13;
    PyObject *tmp_subscribed_name_14;
    PyObject *tmp_subscribed_name_15;
    PyObject *tmp_subscribed_name_16;
    PyObject *tmp_subscribed_name_17;
    PyObject *tmp_subscribed_name_18;
    PyObject *tmp_subscribed_name_19;
    PyObject *tmp_subscribed_name_20;
    PyObject *tmp_subscribed_name_21;
    PyObject *tmp_subscribed_name_22;
    PyObject *tmp_subscribed_name_23;
    PyObject *tmp_subscribed_name_24;
    PyObject *tmp_subscribed_name_25;
    PyObject *tmp_subscribed_name_26;
    PyObject *tmp_subscribed_name_27;
    PyObject *tmp_subscribed_name_28;
    PyObject *tmp_subscribed_name_29;
    PyObject *tmp_subscribed_name_30;
    PyObject *tmp_subscribed_name_31;
    PyObject *tmp_subscribed_name_32;
    PyObject *tmp_subscribed_name_33;
    PyObject *tmp_subscribed_name_34;
    PyObject *tmp_subscribed_name_35;
    PyObject *tmp_subscribed_name_36;
    PyObject *tmp_subscribed_name_37;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    PyObject *tmp_subscript_name_5;
    PyObject *tmp_subscript_name_6;
    PyObject *tmp_subscript_name_7;
    PyObject *tmp_subscript_name_8;
    PyObject *tmp_subscript_name_9;
    PyObject *tmp_subscript_name_10;
    PyObject *tmp_subscript_name_11;
    PyObject *tmp_subscript_name_12;
    PyObject *tmp_subscript_name_13;
    PyObject *tmp_subscript_name_14;
    PyObject *tmp_subscript_name_15;
    PyObject *tmp_subscript_name_16;
    PyObject *tmp_subscript_name_17;
    PyObject *tmp_subscript_name_18;
    PyObject *tmp_subscript_name_19;
    PyObject *tmp_subscript_name_20;
    PyObject *tmp_subscript_name_21;
    PyObject *tmp_subscript_name_22;
    PyObject *tmp_subscript_name_23;
    PyObject *tmp_subscript_name_24;
    PyObject *tmp_subscript_name_25;
    PyObject *tmp_subscript_name_26;
    PyObject *tmp_subscript_name_27;
    PyObject *tmp_subscript_name_28;
    PyObject *tmp_subscript_name_29;
    PyObject *tmp_subscript_name_30;
    PyObject *tmp_subscript_name_31;
    PyObject *tmp_subscript_name_32;
    PyObject *tmp_subscript_name_33;
    PyObject *tmp_subscript_name_34;
    PyObject *tmp_subscript_name_35;
    PyObject *tmp_subscript_name_36;
    PyObject *tmp_subscript_name_37;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_tuple_element_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_bef5532727a45f5b235d041b44d2998c = NULL;

    struct Nuitka_FrameObject *frame_bef5532727a45f5b235d041b44d2998c;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_bef5532727a45f5b235d041b44d2998c, codeobj_bef5532727a45f5b235d041b44d2998c, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_bef5532727a45f5b235d041b44d2998c = cache_frame_bef5532727a45f5b235d041b44d2998c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_bef5532727a45f5b235d041b44d2998c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_bef5532727a45f5b235d041b44d2998c ) == 2 ); // Frame stack

    // Framed code:
    tmp_compexpr_left_1 = const_str_plain_typedef;
    tmp_subscribed_name_1 = par_spec;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_str_plain_storage;
    tmp_compexpr_right_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 381;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = SEQUENCE_CONTAINS( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 381;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_is_typedef == NULL );
    Py_INCREF( tmp_assign_source_1 );
    var_is_typedef = tmp_assign_source_1;

    tmp_assign_source_2 = PyList_New( 0 );
    assert( var_declarations == NULL );
    var_declarations = tmp_assign_source_2;

    tmp_subscribed_name_2 = par_decls;

    if ( tmp_subscribed_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decls" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 386;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_0;
    tmp_called_instance_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 386;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    frame_bef5532727a45f5b235d041b44d2998c->m_frame.f_lineno = 386;
    tmp_compare_left_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_get, &PyTuple_GET_ITEM( const_tuple_str_plain_bitsize_tuple, 0 ) );

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 386;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_subscribed_name_4 = par_decls;

    if ( tmp_subscribed_name_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decls" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 394;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_0;
    tmp_subscribed_name_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_3 );
    if ( tmp_subscribed_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 394;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_4 = const_str_plain_decl;
    tmp_compare_left_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_4 );
    Py_DECREF( tmp_subscribed_name_3 );
    if ( tmp_compare_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 394;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_2 = Py_None;
    tmp_is_2 = ( tmp_compare_left_2 == tmp_compare_right_2 );
    Py_DECREF( tmp_compare_left_2 );
    if ( tmp_is_2 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_subscribed_name_5 = par_spec;

    if ( tmp_subscribed_name_5 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 395;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_5 = const_str_plain_type;
    tmp_len_arg_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_5, tmp_subscript_name_5 );
    if ( tmp_len_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 395;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_left_2 = BUILTIN_LEN( tmp_len_arg_1 );
    Py_DECREF( tmp_len_arg_1 );
    if ( tmp_compexpr_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 395;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_2 = const_int_pos_2;
    tmp_or_left_value_1 = RICH_COMPARE_LT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    Py_DECREF( tmp_compexpr_left_2 );
    if ( tmp_or_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 395;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
    if ( tmp_or_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_or_left_value_1 );

        exception_lineno = 396;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_or_left_truth_1 == 1 )
    {
        goto or_left_1;
    }
    else
    {
        goto or_right_1;
    }
    or_right_1:;
    Py_DECREF( tmp_or_left_value_1 );
    tmp_subscribed_name_7 = par_spec;

    if ( tmp_subscribed_name_7 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 395;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_6 = const_str_plain_type;
    tmp_subscribed_name_6 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_7, tmp_subscript_name_6 );
    if ( tmp_subscribed_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 395;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_7 = const_int_neg_1;
    tmp_source_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_6, tmp_subscript_name_7 );
    Py_DECREF( tmp_subscribed_name_6 );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 395;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_len_arg_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_names );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_len_arg_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 395;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_left_3 = BUILTIN_LEN( tmp_len_arg_2 );
    Py_DECREF( tmp_len_arg_2 );
    if ( tmp_compexpr_left_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 395;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_3 = const_int_pos_1;
    tmp_or_left_value_2 = RICH_COMPARE_NE( tmp_compexpr_left_3, tmp_compexpr_right_3 );
    Py_DECREF( tmp_compexpr_left_3 );
    if ( tmp_or_left_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 395;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_or_left_truth_2 = CHECK_IF_TRUE( tmp_or_left_value_2 );
    if ( tmp_or_left_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_or_left_value_2 );

        exception_lineno = 396;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_or_left_truth_2 == 1 )
    {
        goto or_left_2;
    }
    else
    {
        goto or_right_2;
    }
    or_right_2:;
    Py_DECREF( tmp_or_left_value_2 );
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 396;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__is_type_in_scope );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 396;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_10 = par_spec;

    if ( tmp_subscribed_name_10 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 396;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_8 = const_str_plain_type;
    tmp_subscribed_name_9 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_10, tmp_subscript_name_8 );
    if ( tmp_subscribed_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 396;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_9 = const_int_neg_1;
    tmp_source_name_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_9, tmp_subscript_name_9 );
    Py_DECREF( tmp_subscribed_name_9 );
    if ( tmp_source_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 396;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_names );
    Py_DECREF( tmp_source_name_3 );
    if ( tmp_subscribed_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 396;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_10 = const_int_0;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_8, tmp_subscript_name_10 );
    Py_DECREF( tmp_subscribed_name_8 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 396;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    frame_bef5532727a45f5b235d041b44d2998c->m_frame.f_lineno = 396;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_operand_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 396;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_or_right_value_2 = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_or_right_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 396;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_or_right_value_2 );
    tmp_or_right_value_1 = tmp_or_right_value_2;
    goto or_end_2;
    or_left_2:;
    tmp_or_right_value_1 = tmp_or_left_value_2;
    or_end_2:;
    tmp_cond_value_1 = tmp_or_right_value_1;
    goto or_end_1;
    or_left_1:;
    tmp_cond_value_1 = tmp_or_left_value_1;
    or_end_1:;
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 396;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_assign_source_3 = const_str_chr_63;
    assert( var_coord == NULL );
    Py_INCREF( tmp_assign_source_3 );
    var_coord = tmp_assign_source_3;

    tmp_subscribed_name_11 = par_spec;

    if ( tmp_subscribed_name_11 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 398;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_11 = const_str_plain_type;
    tmp_iter_arg_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_11, tmp_subscript_name_11 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 398;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_4 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 398;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_4;

    // Tried code:
    loop_start_1:;
    tmp_next_source_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_next_source_1 );
    tmp_assign_source_5 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_5 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            type_description = "oooooooooooo";
            exception_lineno = 398;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    tmp_assign_source_6 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_6 );
    {
        PyObject *old = var_t;
        var_t = tmp_assign_source_6;
        Py_INCREF( var_t );
        Py_XDECREF( old );
    }

    tmp_hasattr_source_1 = var_t;

    CHECK_OBJECT( tmp_hasattr_source_1 );
    tmp_hasattr_attr_1 = const_str_plain_coord;
    tmp_res = PyObject_HasAttr( tmp_hasattr_source_1, tmp_hasattr_attr_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 399;
        type_description = "oooooooooooo";
        goto try_except_handler_2;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_source_name_4 = var_t;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_assign_source_7 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_coord );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 400;
        type_description = "oooooooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_coord;
        var_coord = tmp_assign_source_7;
        Py_XDECREF( old );
    }

    goto loop_end_1;
    branch_no_4:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 398;
        type_description = "oooooooooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    Py_XDECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    Py_XDECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_source_name_5 = par_self;

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 402;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__parse_error );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 402;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = const_str_digest_4bcc04ea9ec07560edae21db6b5348a0;
    tmp_args_element_name_3 = var_coord;

    if ( tmp_args_element_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "coord" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 402;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }

    frame_bef5532727a45f5b235d041b44d2998c->m_frame.f_lineno = 402;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 402;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_3:;
    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 405;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_TypeDecl );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 405;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_1 = _PyDict_NewPresized( 4 );
    tmp_dict_key_1 = const_str_plain_declname;
    tmp_subscribed_name_14 = par_spec;

    if ( tmp_subscribed_name_14 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 406;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_12 = const_str_plain_type;
    tmp_subscribed_name_13 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_14, tmp_subscript_name_12 );
    if ( tmp_subscribed_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 406;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_13 = const_int_neg_1;
    tmp_source_name_7 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_13, tmp_subscript_name_13 );
    Py_DECREF( tmp_subscribed_name_13 );
    if ( tmp_source_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 406;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_12 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_names );
    Py_DECREF( tmp_source_name_7 );
    if ( tmp_subscribed_name_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 406;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_14 = const_int_0;
    tmp_dict_value_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_12, tmp_subscript_name_14 );
    Py_DECREF( tmp_subscribed_name_12 );
    if ( tmp_dict_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 406;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    Py_DECREF( tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_type;
    tmp_dict_value_2 = Py_None;
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_3 = const_str_plain_quals;
    tmp_dict_value_3 = Py_None;
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_4 = const_str_plain_coord;
    tmp_subscribed_name_16 = par_spec;

    if ( tmp_subscribed_name_16 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 409;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_15 = const_str_plain_type;
    tmp_subscribed_name_15 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_16, tmp_subscript_name_15 );
    if ( tmp_subscribed_name_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 409;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_16 = const_int_neg_1;
    tmp_source_name_8 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_15, tmp_subscript_name_16 );
    Py_DECREF( tmp_subscribed_name_15 );
    if ( tmp_source_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 409;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_dict_value_4 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_coord );
    Py_DECREF( tmp_source_name_8 );
    if ( tmp_dict_value_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 409;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_4, tmp_dict_value_4 );
    Py_DECREF( tmp_dict_value_4 );
    assert( !(tmp_res != 0) );
    frame_bef5532727a45f5b235d041b44d2998c->m_frame.f_lineno = 405;
    tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_3, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 405;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_17 = par_decls;

    if ( tmp_subscribed_name_17 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decls" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 405;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_17 = const_int_0;
    tmp_ass_subscribed_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_17, tmp_subscript_name_17 );
    if ( tmp_ass_subscribed_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_1 );

        exception_lineno = 405;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscript_1 = const_str_plain_decl;
    tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_1, tmp_ass_subscript_1, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subscribed_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 405;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_18 = par_spec;

    if ( tmp_subscribed_name_18 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 411;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_18 = const_str_plain_type;
    tmp_delsubscr_target_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_18, tmp_subscript_name_18 );
    if ( tmp_delsubscr_target_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 411;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_delsubscr_subscript_1 = const_int_neg_1;
    tmp_result = DEL_SUBSCRIPT( tmp_delsubscr_target_1, tmp_delsubscr_subscript_1 );
    Py_DECREF( tmp_delsubscr_target_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 411;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    goto branch_end_2;
    branch_no_2:;
    tmp_subscribed_name_20 = par_decls;

    if ( tmp_subscribed_name_20 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decls" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 416;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_19 = const_int_0;
    tmp_subscribed_name_19 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_20, tmp_subscript_name_19 );
    if ( tmp_subscribed_name_19 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 416;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_20 = const_str_plain_decl;
    tmp_isinstance_inst_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_19, tmp_subscript_name_20 );
    Py_DECREF( tmp_subscribed_name_19 );
    if ( tmp_isinstance_inst_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 416;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_isinstance_cls_1 = PyTuple_New( 3 );
    tmp_source_name_9 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_9 == NULL ))
    {
        tmp_source_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_9 == NULL )
    {
        Py_DECREF( tmp_isinstance_inst_1 );
        Py_DECREF( tmp_isinstance_cls_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 417;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_Struct );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_isinstance_inst_1 );
        Py_DECREF( tmp_isinstance_cls_1 );

        exception_lineno = 417;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_isinstance_cls_1, 0, tmp_tuple_element_1 );
    tmp_source_name_10 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_10 == NULL ))
    {
        tmp_source_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_10 == NULL )
    {
        Py_DECREF( tmp_isinstance_inst_1 );
        Py_DECREF( tmp_isinstance_cls_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 417;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_Union );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_isinstance_inst_1 );
        Py_DECREF( tmp_isinstance_cls_1 );

        exception_lineno = 417;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_isinstance_cls_1, 1, tmp_tuple_element_1 );
    tmp_source_name_11 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_11 == NULL ))
    {
        tmp_source_name_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_11 == NULL )
    {
        Py_DECREF( tmp_isinstance_inst_1 );
        Py_DECREF( tmp_isinstance_cls_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 417;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_IdentifierType );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_isinstance_inst_1 );
        Py_DECREF( tmp_isinstance_cls_1 );

        exception_lineno = 417;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_isinstance_cls_1, 2, tmp_tuple_element_1 );
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    Py_DECREF( tmp_isinstance_inst_1 );
    Py_DECREF( tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 416;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_5;
    }
    else
    {
        goto branch_yes_5;
    }
    branch_yes_5:;
    tmp_subscribed_name_22 = par_decls;

    if ( tmp_subscribed_name_22 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decls" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 418;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_21 = const_int_0;
    tmp_subscribed_name_21 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_22, tmp_subscript_name_21 );
    if ( tmp_subscribed_name_21 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 418;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_22 = const_str_plain_decl;
    tmp_assign_source_8 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_21, tmp_subscript_name_22 );
    Py_DECREF( tmp_subscribed_name_21 );
    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 418;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_decls_0_tail == NULL );
    var_decls_0_tail = tmp_assign_source_8;

    loop_start_2:;
    tmp_isinstance_inst_2 = var_decls_0_tail;

    if ( tmp_isinstance_inst_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decls_0_tail" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 419;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_12 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_12 == NULL ))
    {
        tmp_source_name_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_12 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 419;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_isinstance_cls_2 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_TypeDecl );
    if ( tmp_isinstance_cls_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 419;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
    Py_DECREF( tmp_isinstance_cls_2 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 419;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_6;
    }
    else
    {
        goto branch_no_6;
    }
    branch_yes_6:;
    goto loop_end_2;
    branch_no_6:;
    tmp_source_name_13 = var_decls_0_tail;

    if ( tmp_source_name_13 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decls_0_tail" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 420;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_assign_source_9 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_type );
    if ( tmp_assign_source_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 420;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_decls_0_tail;
        var_decls_0_tail = tmp_assign_source_9;
        Py_XDECREF( old );
    }

    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 419;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    goto loop_start_2;
    loop_end_2:;
    tmp_source_name_14 = var_decls_0_tail;

    if ( tmp_source_name_14 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decls_0_tail" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 421;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_left_3 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain_declname );
    if ( tmp_compare_left_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 421;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_3 = Py_None;
    tmp_is_3 = ( tmp_compare_left_3 == tmp_compare_right_3 );
    Py_DECREF( tmp_compare_left_3 );
    if ( tmp_is_3 )
    {
        goto branch_yes_7;
    }
    else
    {
        goto branch_no_7;
    }
    branch_yes_7:;
    tmp_subscribed_name_25 = par_spec;

    if ( tmp_subscribed_name_25 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 422;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_23 = const_str_plain_type;
    tmp_subscribed_name_24 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_25, tmp_subscript_name_23 );
    if ( tmp_subscribed_name_24 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 422;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_24 = const_int_neg_1;
    tmp_source_name_15 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_24, tmp_subscript_name_24 );
    Py_DECREF( tmp_subscribed_name_24 );
    if ( tmp_source_name_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 422;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_23 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain_names );
    Py_DECREF( tmp_source_name_15 );
    if ( tmp_subscribed_name_23 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 422;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_25 = const_int_0;
    tmp_assattr_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_23, tmp_subscript_name_25 );
    Py_DECREF( tmp_subscribed_name_23 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 422;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = var_decls_0_tail;

    if ( tmp_assattr_target_1 == NULL )
    {
        Py_DECREF( tmp_assattr_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decls_0_tail" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 422;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_declname, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 422;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );
    tmp_subscribed_name_26 = par_spec;

    if ( tmp_subscribed_name_26 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 423;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_26 = const_str_plain_type;
    tmp_delsubscr_target_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_26, tmp_subscript_name_26 );
    if ( tmp_delsubscr_target_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 423;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_delsubscr_subscript_2 = const_int_neg_1;
    tmp_result = DEL_SUBSCRIPT( tmp_delsubscr_target_2, tmp_delsubscr_subscript_2 );
    Py_DECREF( tmp_delsubscr_target_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 423;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    branch_no_7:;
    branch_no_5:;
    branch_end_2:;
    branch_no_1:;
    tmp_iter_arg_2 = par_decls;

    if ( tmp_iter_arg_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decls" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 425;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_assign_source_10 = MAKE_ITERATOR( tmp_iter_arg_2 );
    if ( tmp_assign_source_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 425;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_2__for_iterator == NULL );
    tmp_for_loop_2__for_iterator = tmp_assign_source_10;

    // Tried code:
    loop_start_3:;
    tmp_next_source_2 = tmp_for_loop_2__for_iterator;

    CHECK_OBJECT( tmp_next_source_2 );
    tmp_assign_source_11 = ITERATOR_NEXT( tmp_next_source_2 );
    if ( tmp_assign_source_11 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_3;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            type_description = "oooooooooooo";
            exception_lineno = 425;
            goto try_except_handler_3;
        }
    }

    {
        PyObject *old = tmp_for_loop_2__iter_value;
        tmp_for_loop_2__iter_value = tmp_assign_source_11;
        Py_XDECREF( old );
    }

    tmp_assign_source_12 = tmp_for_loop_2__iter_value;

    CHECK_OBJECT( tmp_assign_source_12 );
    {
        PyObject *old = var_decl;
        var_decl = tmp_assign_source_12;
        Py_INCREF( var_decl );
        Py_XDECREF( old );
    }

    tmp_subscribed_name_27 = var_decl;

    CHECK_OBJECT( tmp_subscribed_name_27 );
    tmp_subscript_name_27 = const_str_plain_decl;
    tmp_compare_left_4 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_27, tmp_subscript_name_27 );
    if ( tmp_compare_left_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 426;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    tmp_compare_right_4 = Py_None;
    tmp_is_4 = ( tmp_compare_left_4 == tmp_compare_right_4 );
    Py_DECREF( tmp_compare_left_4 );
    if ( tmp_is_4 )
    {
        goto branch_yes_8;
    }
    else
    {
        goto branch_no_8;
    }
    branch_yes_8:;
    tmp_raise_type_1 = PyExc_AssertionError;
    exception_type = tmp_raise_type_1;
    Py_INCREF( tmp_raise_type_1 );
    exception_lineno = 426;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "oooooooooooo";
    goto try_except_handler_3;
    branch_no_8:;
    tmp_cond_value_2 = var_is_typedef;

    if ( tmp_cond_value_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "is_typedef" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 427;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }

    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 427;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_yes_9;
    }
    else
    {
        goto branch_no_9;
    }
    branch_yes_9:;
    tmp_source_name_16 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_16 == NULL ))
    {
        tmp_source_name_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_16 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 428;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain_Typedef );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 428;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    tmp_kw_name_2 = _PyDict_NewPresized( 5 );
    tmp_dict_key_5 = const_str_plain_name;
    tmp_dict_value_5 = Py_None;
    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_5, tmp_dict_value_5 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_6 = const_str_plain_quals;
    tmp_subscribed_name_28 = par_spec;

    if ( tmp_subscribed_name_28 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 430;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }

    tmp_subscript_name_28 = const_str_plain_qual;
    tmp_dict_value_6 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_28, tmp_subscript_name_28 );
    if ( tmp_dict_value_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_kw_name_2 );

        exception_lineno = 430;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_6, tmp_dict_value_6 );
    Py_DECREF( tmp_dict_value_6 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_7 = const_str_plain_storage;
    tmp_subscribed_name_29 = par_spec;

    if ( tmp_subscribed_name_29 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 431;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }

    tmp_subscript_name_29 = const_str_plain_storage;
    tmp_dict_value_7 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_29, tmp_subscript_name_29 );
    if ( tmp_dict_value_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_kw_name_2 );

        exception_lineno = 431;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_7, tmp_dict_value_7 );
    Py_DECREF( tmp_dict_value_7 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_8 = const_str_plain_type;
    tmp_subscribed_name_30 = var_decl;

    if ( tmp_subscribed_name_30 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decl" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 432;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }

    tmp_subscript_name_30 = const_str_plain_decl;
    tmp_dict_value_8 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_30, tmp_subscript_name_30 );
    if ( tmp_dict_value_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_kw_name_2 );

        exception_lineno = 432;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_8, tmp_dict_value_8 );
    Py_DECREF( tmp_dict_value_8 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_9 = const_str_plain_coord;
    tmp_subscribed_name_31 = var_decl;

    if ( tmp_subscribed_name_31 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decl" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 433;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }

    tmp_subscript_name_31 = const_str_plain_decl;
    tmp_source_name_17 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_31, tmp_subscript_name_31 );
    if ( tmp_source_name_17 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_kw_name_2 );

        exception_lineno = 433;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    tmp_dict_value_9 = LOOKUP_ATTRIBUTE( tmp_source_name_17, const_str_plain_coord );
    Py_DECREF( tmp_source_name_17 );
    if ( tmp_dict_value_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_kw_name_2 );

        exception_lineno = 433;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_9, tmp_dict_value_9 );
    Py_DECREF( tmp_dict_value_9 );
    assert( !(tmp_res != 0) );
    frame_bef5532727a45f5b235d041b44d2998c->m_frame.f_lineno = 428;
    tmp_assign_source_13 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_4, tmp_kw_name_2 );
    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_kw_name_2 );
    if ( tmp_assign_source_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 428;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    {
        PyObject *old = var_declaration;
        var_declaration = tmp_assign_source_13;
        Py_XDECREF( old );
    }

    goto branch_end_9;
    branch_no_9:;
    tmp_source_name_18 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_18 == NULL ))
    {
        tmp_source_name_18 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_18 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 435;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_18, const_str_plain_Decl );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 435;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    tmp_kw_name_3 = _PyDict_NewPresized( 8 );
    tmp_dict_key_10 = const_str_plain_name;
    tmp_dict_value_10 = Py_None;
    tmp_res = PyDict_SetItem( tmp_kw_name_3, tmp_dict_key_10, tmp_dict_value_10 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_11 = const_str_plain_quals;
    tmp_subscribed_name_32 = par_spec;

    if ( tmp_subscribed_name_32 == NULL )
    {
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_kw_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 437;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }

    tmp_subscript_name_32 = const_str_plain_qual;
    tmp_dict_value_11 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_32, tmp_subscript_name_32 );
    if ( tmp_dict_value_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_kw_name_3 );

        exception_lineno = 437;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_3, tmp_dict_key_11, tmp_dict_value_11 );
    Py_DECREF( tmp_dict_value_11 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_12 = const_str_plain_storage;
    tmp_subscribed_name_33 = par_spec;

    if ( tmp_subscribed_name_33 == NULL )
    {
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_kw_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 438;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }

    tmp_subscript_name_33 = const_str_plain_storage;
    tmp_dict_value_12 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_33, tmp_subscript_name_33 );
    if ( tmp_dict_value_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_kw_name_3 );

        exception_lineno = 438;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_3, tmp_dict_key_12, tmp_dict_value_12 );
    Py_DECREF( tmp_dict_value_12 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_13 = const_str_plain_funcspec;
    tmp_subscribed_name_34 = par_spec;

    if ( tmp_subscribed_name_34 == NULL )
    {
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_kw_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 439;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }

    tmp_subscript_name_34 = const_str_plain_function;
    tmp_dict_value_13 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_34, tmp_subscript_name_34 );
    if ( tmp_dict_value_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_kw_name_3 );

        exception_lineno = 439;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_3, tmp_dict_key_13, tmp_dict_value_13 );
    Py_DECREF( tmp_dict_value_13 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_14 = const_str_plain_type;
    tmp_subscribed_name_35 = var_decl;

    if ( tmp_subscribed_name_35 == NULL )
    {
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_kw_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decl" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 440;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }

    tmp_subscript_name_35 = const_str_plain_decl;
    tmp_dict_value_14 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_35, tmp_subscript_name_35 );
    if ( tmp_dict_value_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_kw_name_3 );

        exception_lineno = 440;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_3, tmp_dict_key_14, tmp_dict_value_14 );
    Py_DECREF( tmp_dict_value_14 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_15 = const_str_plain_init;
    tmp_called_instance_2 = var_decl;

    if ( tmp_called_instance_2 == NULL )
    {
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_kw_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decl" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 441;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }

    frame_bef5532727a45f5b235d041b44d2998c->m_frame.f_lineno = 441;
    tmp_dict_value_15 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_get, &PyTuple_GET_ITEM( const_tuple_str_plain_init_tuple, 0 ) );

    if ( tmp_dict_value_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_kw_name_3 );

        exception_lineno = 441;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_3, tmp_dict_key_15, tmp_dict_value_15 );
    Py_DECREF( tmp_dict_value_15 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_16 = const_str_plain_bitsize;
    tmp_called_instance_3 = var_decl;

    if ( tmp_called_instance_3 == NULL )
    {
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_kw_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decl" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 442;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }

    frame_bef5532727a45f5b235d041b44d2998c->m_frame.f_lineno = 442;
    tmp_dict_value_16 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_get, &PyTuple_GET_ITEM( const_tuple_str_plain_bitsize_tuple, 0 ) );

    if ( tmp_dict_value_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_kw_name_3 );

        exception_lineno = 442;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_3, tmp_dict_key_16, tmp_dict_value_16 );
    Py_DECREF( tmp_dict_value_16 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_17 = const_str_plain_coord;
    tmp_subscribed_name_36 = var_decl;

    if ( tmp_subscribed_name_36 == NULL )
    {
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_kw_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decl" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 443;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }

    tmp_subscript_name_36 = const_str_plain_decl;
    tmp_source_name_19 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_36, tmp_subscript_name_36 );
    if ( tmp_source_name_19 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_kw_name_3 );

        exception_lineno = 443;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    tmp_dict_value_17 = LOOKUP_ATTRIBUTE( tmp_source_name_19, const_str_plain_coord );
    Py_DECREF( tmp_source_name_19 );
    if ( tmp_dict_value_17 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_kw_name_3 );

        exception_lineno = 443;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_3, tmp_dict_key_17, tmp_dict_value_17 );
    Py_DECREF( tmp_dict_value_17 );
    assert( !(tmp_res != 0) );
    frame_bef5532727a45f5b235d041b44d2998c->m_frame.f_lineno = 435;
    tmp_assign_source_14 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_5, tmp_kw_name_3 );
    Py_DECREF( tmp_called_name_5 );
    Py_DECREF( tmp_kw_name_3 );
    if ( tmp_assign_source_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 435;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    {
        PyObject *old = var_declaration;
        var_declaration = tmp_assign_source_14;
        Py_XDECREF( old );
    }

    branch_end_9:;
    tmp_source_name_20 = var_declaration;

    CHECK_OBJECT( tmp_source_name_20 );
    tmp_isinstance_inst_3 = LOOKUP_ATTRIBUTE( tmp_source_name_20, const_str_plain_type );
    if ( tmp_isinstance_inst_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 445;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    tmp_isinstance_cls_3 = PyTuple_New( 3 );
    tmp_source_name_21 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_21 == NULL ))
    {
        tmp_source_name_21 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_21 == NULL )
    {
        Py_DECREF( tmp_isinstance_inst_3 );
        Py_DECREF( tmp_isinstance_cls_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 446;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }

    tmp_tuple_element_2 = LOOKUP_ATTRIBUTE( tmp_source_name_21, const_str_plain_Struct );
    if ( tmp_tuple_element_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_isinstance_inst_3 );
        Py_DECREF( tmp_isinstance_cls_3 );

        exception_lineno = 446;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_isinstance_cls_3, 0, tmp_tuple_element_2 );
    tmp_source_name_22 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_22 == NULL ))
    {
        tmp_source_name_22 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_22 == NULL )
    {
        Py_DECREF( tmp_isinstance_inst_3 );
        Py_DECREF( tmp_isinstance_cls_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 446;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }

    tmp_tuple_element_2 = LOOKUP_ATTRIBUTE( tmp_source_name_22, const_str_plain_Union );
    if ( tmp_tuple_element_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_isinstance_inst_3 );
        Py_DECREF( tmp_isinstance_cls_3 );

        exception_lineno = 446;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_isinstance_cls_3, 1, tmp_tuple_element_2 );
    tmp_source_name_23 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_23 == NULL ))
    {
        tmp_source_name_23 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_23 == NULL )
    {
        Py_DECREF( tmp_isinstance_inst_3 );
        Py_DECREF( tmp_isinstance_cls_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 446;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }

    tmp_tuple_element_2 = LOOKUP_ATTRIBUTE( tmp_source_name_23, const_str_plain_IdentifierType );
    if ( tmp_tuple_element_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_isinstance_inst_3 );
        Py_DECREF( tmp_isinstance_cls_3 );

        exception_lineno = 446;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    PyTuple_SET_ITEM( tmp_isinstance_cls_3, 2, tmp_tuple_element_2 );
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_3, tmp_isinstance_cls_3 );
    Py_DECREF( tmp_isinstance_inst_3 );
    Py_DECREF( tmp_isinstance_cls_3 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 445;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_10;
    }
    else
    {
        goto branch_no_10;
    }
    branch_yes_10:;
    tmp_assign_source_15 = var_declaration;

    if ( tmp_assign_source_15 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "declaration" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 447;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }

    {
        PyObject *old = var_fixed_decl;
        var_fixed_decl = tmp_assign_source_15;
        Py_INCREF( var_fixed_decl );
        Py_XDECREF( old );
    }

    goto branch_end_10;
    branch_no_10:;
    tmp_source_name_24 = par_self;

    if ( tmp_source_name_24 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 449;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }

    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_24, const_str_plain__fix_decl_name_type );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 449;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    tmp_args_element_name_4 = var_declaration;

    if ( tmp_args_element_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_6 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "declaration" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 449;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }

    tmp_subscribed_name_37 = par_spec;

    if ( tmp_subscribed_name_37 == NULL )
    {
        Py_DECREF( tmp_called_name_6 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 449;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }

    tmp_subscript_name_37 = const_str_plain_type;
    tmp_args_element_name_5 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_37, tmp_subscript_name_37 );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_6 );

        exception_lineno = 449;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    frame_bef5532727a45f5b235d041b44d2998c->m_frame.f_lineno = 449;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_assign_source_16 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_called_name_6 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_assign_source_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 449;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    {
        PyObject *old = var_fixed_decl;
        var_fixed_decl = tmp_assign_source_16;
        Py_XDECREF( old );
    }

    branch_end_10:;
    tmp_cond_value_3 = par_typedef_namespace;

    if ( tmp_cond_value_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "typedef_namespace" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 454;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }

    tmp_cond_truth_3 = CHECK_IF_TRUE( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 454;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    if ( tmp_cond_truth_3 == 1 )
    {
        goto branch_yes_11;
    }
    else
    {
        goto branch_no_11;
    }
    branch_yes_11:;
    tmp_cond_value_4 = var_is_typedef;

    if ( tmp_cond_value_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "is_typedef" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 455;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }

    tmp_cond_truth_4 = CHECK_IF_TRUE( tmp_cond_value_4 );
    if ( tmp_cond_truth_4 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 455;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    if ( tmp_cond_truth_4 == 1 )
    {
        goto branch_yes_12;
    }
    else
    {
        goto branch_no_12;
    }
    branch_yes_12:;
    tmp_source_name_25 = par_self;

    if ( tmp_source_name_25 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 456;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }

    tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_25, const_str_plain__add_typedef_name );
    if ( tmp_called_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 456;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    tmp_source_name_26 = var_fixed_decl;

    if ( tmp_source_name_26 == NULL )
    {
        Py_DECREF( tmp_called_name_7 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "fixed_decl" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 456;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }

    tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_26, const_str_plain_name );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_7 );

        exception_lineno = 456;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    tmp_source_name_27 = var_fixed_decl;

    if ( tmp_source_name_27 == NULL )
    {
        Py_DECREF( tmp_called_name_7 );
        Py_DECREF( tmp_args_element_name_6 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "fixed_decl" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 456;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }

    tmp_args_element_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_27, const_str_plain_coord );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_7 );
        Py_DECREF( tmp_args_element_name_6 );

        exception_lineno = 456;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    frame_bef5532727a45f5b235d041b44d2998c->m_frame.f_lineno = 456;
    {
        PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_7, call_args );
    }

    Py_DECREF( tmp_called_name_7 );
    Py_DECREF( tmp_args_element_name_6 );
    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 456;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_12;
    branch_no_12:;
    tmp_source_name_28 = par_self;

    if ( tmp_source_name_28 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 458;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }

    tmp_called_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_28, const_str_plain__add_identifier );
    if ( tmp_called_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 458;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    tmp_source_name_29 = var_fixed_decl;

    if ( tmp_source_name_29 == NULL )
    {
        Py_DECREF( tmp_called_name_8 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "fixed_decl" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 458;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }

    tmp_args_element_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_29, const_str_plain_name );
    if ( tmp_args_element_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_8 );

        exception_lineno = 458;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    tmp_source_name_30 = var_fixed_decl;

    if ( tmp_source_name_30 == NULL )
    {
        Py_DECREF( tmp_called_name_8 );
        Py_DECREF( tmp_args_element_name_8 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "fixed_decl" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 458;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }

    tmp_args_element_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_30, const_str_plain_coord );
    if ( tmp_args_element_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_8 );
        Py_DECREF( tmp_args_element_name_8 );

        exception_lineno = 458;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    frame_bef5532727a45f5b235d041b44d2998c->m_frame.f_lineno = 458;
    {
        PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_9 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_8, call_args );
    }

    Py_DECREF( tmp_called_name_8 );
    Py_DECREF( tmp_args_element_name_8 );
    Py_DECREF( tmp_args_element_name_9 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 458;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_unused );
    branch_end_12:;
    branch_no_11:;
    tmp_source_name_31 = var_declarations;

    if ( tmp_source_name_31 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "declarations" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 460;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }

    tmp_called_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_31, const_str_plain_append );
    if ( tmp_called_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 460;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    tmp_args_element_name_10 = var_fixed_decl;

    if ( tmp_args_element_name_10 == NULL )
    {
        Py_DECREF( tmp_called_name_9 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "fixed_decl" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 460;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }

    frame_bef5532727a45f5b235d041b44d2998c->m_frame.f_lineno = 460;
    {
        PyObject *call_args[] = { tmp_args_element_name_10 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_9, call_args );
    }

    Py_DECREF( tmp_called_name_9 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 460;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_unused );
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 425;
        type_description = "oooooooooooo";
        goto try_except_handler_3;
    }
    goto loop_start_3;
    loop_end_3:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_2__iter_value );
    tmp_for_loop_2__iter_value = NULL;

    Py_XDECREF( tmp_for_loop_2__for_iterator );
    tmp_for_loop_2__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    Py_XDECREF( tmp_for_loop_2__iter_value );
    tmp_for_loop_2__iter_value = NULL;

    Py_XDECREF( tmp_for_loop_2__for_iterator );
    tmp_for_loop_2__for_iterator = NULL;

    tmp_return_value = var_declarations;

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "declarations" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 462;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bef5532727a45f5b235d041b44d2998c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_bef5532727a45f5b235d041b44d2998c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bef5532727a45f5b235d041b44d2998c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_bef5532727a45f5b235d041b44d2998c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_bef5532727a45f5b235d041b44d2998c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_bef5532727a45f5b235d041b44d2998c, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_bef5532727a45f5b235d041b44d2998c, type_description ,par_self, par_spec, par_decls, par_typedef_namespace, var_is_typedef, var_declarations, var_coord, var_t, var_decls_0_tail, var_decl, var_declaration, var_fixed_decl );

    // Release cached frame.
    if ( frame_bef5532727a45f5b235d041b44d2998c == cache_frame_bef5532727a45f5b235d041b44d2998c )
    {
        Py_DECREF( frame_bef5532727a45f5b235d041b44d2998c );
    }
    cache_frame_bef5532727a45f5b235d041b44d2998c = NULL;

    assertFrameObject( frame_bef5532727a45f5b235d041b44d2998c );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_16__build_declarations );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_spec );
    par_spec = NULL;

    Py_XDECREF( par_decls );
    par_decls = NULL;

    Py_XDECREF( par_typedef_namespace );
    par_typedef_namespace = NULL;

    Py_XDECREF( var_is_typedef );
    var_is_typedef = NULL;

    Py_XDECREF( var_declarations );
    var_declarations = NULL;

    Py_XDECREF( var_coord );
    var_coord = NULL;

    Py_XDECREF( var_t );
    var_t = NULL;

    Py_XDECREF( var_decls_0_tail );
    var_decls_0_tail = NULL;

    Py_XDECREF( var_decl );
    var_decl = NULL;

    Py_XDECREF( var_declaration );
    var_declaration = NULL;

    Py_XDECREF( var_fixed_decl );
    var_fixed_decl = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_spec );
    par_spec = NULL;

    Py_XDECREF( par_decls );
    par_decls = NULL;

    Py_XDECREF( par_typedef_namespace );
    par_typedef_namespace = NULL;

    Py_XDECREF( var_is_typedef );
    var_is_typedef = NULL;

    Py_XDECREF( var_declarations );
    var_declarations = NULL;

    Py_XDECREF( var_coord );
    var_coord = NULL;

    Py_XDECREF( var_t );
    var_t = NULL;

    Py_XDECREF( var_decls_0_tail );
    var_decls_0_tail = NULL;

    Py_XDECREF( var_decl );
    var_decl = NULL;

    Py_XDECREF( var_declaration );
    var_declaration = NULL;

    Py_XDECREF( var_fixed_decl );
    var_fixed_decl = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_16__build_declarations );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_17__build_function_definition( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_spec = python_pars[ 1 ];
    PyObject *par_decl = python_pars[ 2 ];
    PyObject *par_param_decls = python_pars[ 3 ];
    PyObject *par_body = python_pars[ 4 ];
    PyObject *var_declaration = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cmp_In_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_key_4;
    PyObject *tmp_dict_key_5;
    PyObject *tmp_dict_key_6;
    PyObject *tmp_dict_key_7;
    PyObject *tmp_dict_key_8;
    PyObject *tmp_dict_key_9;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_dict_value_4;
    PyObject *tmp_dict_value_5;
    PyObject *tmp_dict_value_6;
    PyObject *tmp_dict_value_7;
    PyObject *tmp_dict_value_8;
    PyObject *tmp_dict_value_9;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_kw_name_2;
    PyObject *tmp_list_element_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    static struct Nuitka_FrameObject *cache_frame_47d1681d5614a83e5df14808f4fa8d7b = NULL;

    struct Nuitka_FrameObject *frame_47d1681d5614a83e5df14808f4fa8d7b;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_47d1681d5614a83e5df14808f4fa8d7b, codeobj_47d1681d5614a83e5df14808f4fa8d7b, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_47d1681d5614a83e5df14808f4fa8d7b = cache_frame_47d1681d5614a83e5df14808f4fa8d7b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_47d1681d5614a83e5df14808f4fa8d7b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_47d1681d5614a83e5df14808f4fa8d7b ) == 2 ); // Frame stack

    // Framed code:
    tmp_compare_left_1 = const_str_plain_typedef;
    tmp_subscribed_name_1 = par_spec;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_str_plain_storage;
    tmp_compare_right_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 467;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_In_1 = PySequence_Contains( tmp_compare_right_1, tmp_compare_left_1 );
    assert( !(tmp_cmp_In_1 == -1) );
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_In_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_raise_type_1 = PyExc_AssertionError;
    exception_type = tmp_raise_type_1;
    Py_INCREF( tmp_raise_type_1 );
    exception_lineno = 467;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "oooooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_1 = par_self;

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 469;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__build_declarations );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 469;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_1 = _PyDict_NewPresized( 3 );
    tmp_dict_key_1 = const_str_plain_spec;
    tmp_dict_value_1 = par_spec;

    if ( tmp_dict_value_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 470;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_decls;
    tmp_dict_value_2 = PyList_New( 1 );
    tmp_list_element_1 = _PyDict_NewPresized( 2 );
    tmp_dict_key_3 = const_str_plain_decl;
    tmp_dict_value_3 = par_decl;

    if ( tmp_dict_value_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_dict_value_2 );
        Py_DECREF( tmp_list_element_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decl" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 471;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_list_element_1, tmp_dict_key_3, tmp_dict_value_3 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_4 = const_str_plain_init;
    tmp_dict_value_4 = Py_None;
    tmp_res = PyDict_SetItem( tmp_list_element_1, tmp_dict_key_4, tmp_dict_value_4 );
    assert( !(tmp_res != 0) );
    PyList_SET_ITEM( tmp_dict_value_2, 0, tmp_list_element_1 );
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    Py_DECREF( tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_5 = const_str_plain_typedef_namespace;
    tmp_dict_value_5 = Py_True;
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_5, tmp_dict_value_5 );
    assert( !(tmp_res != 0) );
    frame_47d1681d5614a83e5df14808f4fa8d7b->m_frame.f_lineno = 469;
    tmp_subscribed_name_2 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_subscribed_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 469;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_2 = const_int_0;
    tmp_assign_source_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    Py_DECREF( tmp_subscribed_name_2 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 469;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_declaration == NULL );
    var_declaration = tmp_assign_source_1;

    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 474;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_FuncDef );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 474;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_2 = _PyDict_NewPresized( 4 );
    tmp_dict_key_6 = const_str_plain_decl;
    tmp_dict_value_6 = var_declaration;

    if ( tmp_dict_value_6 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "declaration" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 475;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_6, tmp_dict_value_6 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_7 = const_str_plain_param_decls;
    tmp_dict_value_7 = par_param_decls;

    if ( tmp_dict_value_7 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "param_decls" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 476;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_7, tmp_dict_value_7 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_8 = const_str_plain_body;
    tmp_dict_value_8 = par_body;

    if ( tmp_dict_value_8 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "body" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 477;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_8, tmp_dict_value_8 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_9 = const_str_plain_coord;
    tmp_source_name_3 = par_decl;

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decl" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 478;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_dict_value_9 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_coord );
    if ( tmp_dict_value_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_2 );

        exception_lineno = 478;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_9, tmp_dict_value_9 );
    Py_DECREF( tmp_dict_value_9 );
    assert( !(tmp_res != 0) );
    frame_47d1681d5614a83e5df14808f4fa8d7b->m_frame.f_lineno = 474;
    tmp_return_value = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_2, tmp_kw_name_2 );
    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_kw_name_2 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 474;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_47d1681d5614a83e5df14808f4fa8d7b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_47d1681d5614a83e5df14808f4fa8d7b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_47d1681d5614a83e5df14808f4fa8d7b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_47d1681d5614a83e5df14808f4fa8d7b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_47d1681d5614a83e5df14808f4fa8d7b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_47d1681d5614a83e5df14808f4fa8d7b, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_47d1681d5614a83e5df14808f4fa8d7b, type_description ,par_self, par_spec, par_decl, par_param_decls, par_body, var_declaration );

    // Release cached frame.
    if ( frame_47d1681d5614a83e5df14808f4fa8d7b == cache_frame_47d1681d5614a83e5df14808f4fa8d7b )
    {
        Py_DECREF( frame_47d1681d5614a83e5df14808f4fa8d7b );
    }
    cache_frame_47d1681d5614a83e5df14808f4fa8d7b = NULL;

    assertFrameObject( frame_47d1681d5614a83e5df14808f4fa8d7b );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_17__build_function_definition );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_spec );
    par_spec = NULL;

    Py_XDECREF( par_decl );
    par_decl = NULL;

    Py_XDECREF( par_param_decls );
    par_param_decls = NULL;

    Py_XDECREF( par_body );
    par_body = NULL;

    Py_XDECREF( var_declaration );
    var_declaration = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_spec );
    par_spec = NULL;

    Py_XDECREF( par_decl );
    par_decl = NULL;

    Py_XDECREF( par_param_decls );
    par_param_decls = NULL;

    Py_XDECREF( par_body );
    par_body = NULL;

    Py_XDECREF( var_declaration );
    var_declaration = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_17__build_function_definition );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_18__select_struct_union_class( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_token = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_09001c135c5d1963f9dd6f01da960cd0 = NULL;

    struct Nuitka_FrameObject *frame_09001c135c5d1963f9dd6f01da960cd0;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_09001c135c5d1963f9dd6f01da960cd0, codeobj_09001c135c5d1963f9dd6f01da960cd0, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_09001c135c5d1963f9dd6f01da960cd0 = cache_frame_09001c135c5d1963f9dd6f01da960cd0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_09001c135c5d1963f9dd6f01da960cd0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_09001c135c5d1963f9dd6f01da960cd0 ) == 2 ); // Frame stack

    // Framed code:
    tmp_compare_left_1 = par_token;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = const_str_plain_struct;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 484;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 485;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_Struct );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 485;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    goto branch_end_1;
    branch_no_1:;
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 487;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_Union );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 487;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_09001c135c5d1963f9dd6f01da960cd0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_09001c135c5d1963f9dd6f01da960cd0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_09001c135c5d1963f9dd6f01da960cd0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_09001c135c5d1963f9dd6f01da960cd0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_09001c135c5d1963f9dd6f01da960cd0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_09001c135c5d1963f9dd6f01da960cd0, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_09001c135c5d1963f9dd6f01da960cd0, type_description ,par_self, par_token );

    // Release cached frame.
    if ( frame_09001c135c5d1963f9dd6f01da960cd0 == cache_frame_09001c135c5d1963f9dd6f01da960cd0 )
    {
        Py_DECREF( frame_09001c135c5d1963f9dd6f01da960cd0 );
    }
    cache_frame_09001c135c5d1963f9dd6f01da960cd0 = NULL;

    assertFrameObject( frame_09001c135c5d1963f9dd6f01da960cd0 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_18__select_struct_union_class );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_token );
    par_token = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_token );
    par_token = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_18__select_struct_union_class );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_19_p_translation_unit_or_empty( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscribed_2;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subscript_2;
    int tmp_ass_subscript_res_1;
    int tmp_ass_subscript_res_2;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_ass_subvalue_2;
    PyObject *tmp_call_arg_element_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    bool tmp_is_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    static struct Nuitka_FrameObject *cache_frame_25d6673a41ce2601022f3bec8cf9b9f2 = NULL;

    struct Nuitka_FrameObject *frame_25d6673a41ce2601022f3bec8cf9b9f2;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_25d6673a41ce2601022f3bec8cf9b9f2, codeobj_25d6673a41ce2601022f3bec8cf9b9f2, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_25d6673a41ce2601022f3bec8cf9b9f2 = cache_frame_25d6673a41ce2601022f3bec8cf9b9f2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_25d6673a41ce2601022f3bec8cf9b9f2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_25d6673a41ce2601022f3bec8cf9b9f2 ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_compare_left_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 517;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 518;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_call_arg_element_1 = PyList_New( 0 );
    frame_25d6673a41ce2601022f3bec8cf9b9f2->m_frame.f_lineno = 518;
    {
        PyObject *call_args[] = { tmp_call_arg_element_1 };
        tmp_ass_subvalue_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_FileAST, call_args );
    }

    Py_DECREF( tmp_call_arg_element_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 518;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 518;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 518;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto branch_end_1;
    branch_no_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 520;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_FileAST );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 520;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 520;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_1;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 520;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_25d6673a41ce2601022f3bec8cf9b9f2->m_frame.f_lineno = 520;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_ass_subvalue_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_ass_subvalue_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 520;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_2 = par_p;

    if ( tmp_ass_subscribed_2 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 520;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_2 = const_int_0;
    tmp_ass_subscript_res_2 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_2, tmp_ass_subscript_2, 0, tmp_ass_subvalue_2 );
    Py_DECREF( tmp_ass_subvalue_2 );
    if ( tmp_ass_subscript_res_2 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 520;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_25d6673a41ce2601022f3bec8cf9b9f2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_25d6673a41ce2601022f3bec8cf9b9f2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_25d6673a41ce2601022f3bec8cf9b9f2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_25d6673a41ce2601022f3bec8cf9b9f2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_25d6673a41ce2601022f3bec8cf9b9f2, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_25d6673a41ce2601022f3bec8cf9b9f2, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_25d6673a41ce2601022f3bec8cf9b9f2 == cache_frame_25d6673a41ce2601022f3bec8cf9b9f2 )
    {
        Py_DECREF( frame_25d6673a41ce2601022f3bec8cf9b9f2 );
    }
    cache_frame_25d6673a41ce2601022f3bec8cf9b9f2 = NULL;

    assertFrameObject( frame_25d6673a41ce2601022f3bec8cf9b9f2 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_19_p_translation_unit_or_empty );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_19_p_translation_unit_or_empty );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_20_p_translation_unit_1( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_return_value;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_a186227811a44983d6a7e67189d06650 = NULL;

    struct Nuitka_FrameObject *frame_a186227811a44983d6a7e67189d06650;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a186227811a44983d6a7e67189d06650, codeobj_a186227811a44983d6a7e67189d06650, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_a186227811a44983d6a7e67189d06650 = cache_frame_a186227811a44983d6a7e67189d06650;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a186227811a44983d6a7e67189d06650 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a186227811a44983d6a7e67189d06650 ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 527;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 527;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 527;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a186227811a44983d6a7e67189d06650 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a186227811a44983d6a7e67189d06650 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a186227811a44983d6a7e67189d06650, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a186227811a44983d6a7e67189d06650->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a186227811a44983d6a7e67189d06650, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_a186227811a44983d6a7e67189d06650, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_a186227811a44983d6a7e67189d06650 == cache_frame_a186227811a44983d6a7e67189d06650 )
    {
        Py_DECREF( frame_a186227811a44983d6a7e67189d06650 );
    }
    cache_frame_a186227811a44983d6a7e67189d06650 = NULL;

    assertFrameObject( frame_a186227811a44983d6a7e67189d06650 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_20_p_translation_unit_1 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_20_p_translation_unit_1 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_21_p_translation_unit_2( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    bool tmp_isnot_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_aee718468f446ee6274702a5598cc964 = NULL;

    struct Nuitka_FrameObject *frame_aee718468f446ee6274702a5598cc964;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_aee718468f446ee6274702a5598cc964, codeobj_aee718468f446ee6274702a5598cc964, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_aee718468f446ee6274702a5598cc964 = cache_frame_aee718468f446ee6274702a5598cc964;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_aee718468f446ee6274702a5598cc964 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_aee718468f446ee6274702a5598cc964 ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_2;
    tmp_compare_left_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 532;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = Py_None;
    tmp_isnot_1 = ( tmp_compare_left_1 != tmp_compare_right_1 );
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_isnot_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 533;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_1;
    tmp_source_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 533;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_extend );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 533;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 533;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_2;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 533;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_aee718468f446ee6274702a5598cc964->m_frame.f_lineno = 533;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 533;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_1:;
    tmp_subscribed_name_4 = par_p;

    if ( tmp_subscribed_name_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 534;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_4 = const_int_pos_1;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_4 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 534;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 534;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 534;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_aee718468f446ee6274702a5598cc964 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_aee718468f446ee6274702a5598cc964 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_aee718468f446ee6274702a5598cc964, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_aee718468f446ee6274702a5598cc964->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_aee718468f446ee6274702a5598cc964, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_aee718468f446ee6274702a5598cc964, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_aee718468f446ee6274702a5598cc964 == cache_frame_aee718468f446ee6274702a5598cc964 )
    {
        Py_DECREF( frame_aee718468f446ee6274702a5598cc964 );
    }
    cache_frame_aee718468f446ee6274702a5598cc964 = NULL;

    assertFrameObject( frame_aee718468f446ee6274702a5598cc964 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_21_p_translation_unit_2 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_21_p_translation_unit_2 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_22_p_external_declaration_1( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_list_element_1;
    PyObject *tmp_return_value;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_24adae7ae88f8e4355b4ba1428992bc6 = NULL;

    struct Nuitka_FrameObject *frame_24adae7ae88f8e4355b4ba1428992bc6;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_24adae7ae88f8e4355b4ba1428992bc6, codeobj_24adae7ae88f8e4355b4ba1428992bc6, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_24adae7ae88f8e4355b4ba1428992bc6 = cache_frame_24adae7ae88f8e4355b4ba1428992bc6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_24adae7ae88f8e4355b4ba1428992bc6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_24adae7ae88f8e4355b4ba1428992bc6 ) == 2 ); // Frame stack

    // Framed code:
    tmp_ass_subvalue_1 = PyList_New( 1 );
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_list_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_list_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_1 );

        exception_lineno = 544;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyList_SET_ITEM( tmp_ass_subvalue_1, 0, tmp_list_element_1 );
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 544;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 544;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_24adae7ae88f8e4355b4ba1428992bc6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_24adae7ae88f8e4355b4ba1428992bc6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_24adae7ae88f8e4355b4ba1428992bc6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_24adae7ae88f8e4355b4ba1428992bc6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_24adae7ae88f8e4355b4ba1428992bc6, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_24adae7ae88f8e4355b4ba1428992bc6, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_24adae7ae88f8e4355b4ba1428992bc6 == cache_frame_24adae7ae88f8e4355b4ba1428992bc6 )
    {
        Py_DECREF( frame_24adae7ae88f8e4355b4ba1428992bc6 );
    }
    cache_frame_24adae7ae88f8e4355b4ba1428992bc6 = NULL;

    assertFrameObject( frame_24adae7ae88f8e4355b4ba1428992bc6 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_22_p_external_declaration_1 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_22_p_external_declaration_1 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_23_p_external_declaration_2( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_return_value;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_6879c1e9865b0e5e45bb62efdd824393 = NULL;

    struct Nuitka_FrameObject *frame_6879c1e9865b0e5e45bb62efdd824393;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6879c1e9865b0e5e45bb62efdd824393, codeobj_6879c1e9865b0e5e45bb62efdd824393, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_6879c1e9865b0e5e45bb62efdd824393 = cache_frame_6879c1e9865b0e5e45bb62efdd824393;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6879c1e9865b0e5e45bb62efdd824393 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6879c1e9865b0e5e45bb62efdd824393 ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 549;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 549;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 549;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6879c1e9865b0e5e45bb62efdd824393 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6879c1e9865b0e5e45bb62efdd824393 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6879c1e9865b0e5e45bb62efdd824393, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6879c1e9865b0e5e45bb62efdd824393->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6879c1e9865b0e5e45bb62efdd824393, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_6879c1e9865b0e5e45bb62efdd824393, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_6879c1e9865b0e5e45bb62efdd824393 == cache_frame_6879c1e9865b0e5e45bb62efdd824393 )
    {
        Py_DECREF( frame_6879c1e9865b0e5e45bb62efdd824393 );
    }
    cache_frame_6879c1e9865b0e5e45bb62efdd824393 = NULL;

    assertFrameObject( frame_6879c1e9865b0e5e45bb62efdd824393 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_23_p_external_declaration_2 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_23_p_external_declaration_2 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_24_p_external_declaration_3( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_list_element_1;
    PyObject *tmp_return_value;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_208c1d0a5c48fb2f1b2e5a0a8e19fff7 = NULL;

    struct Nuitka_FrameObject *frame_208c1d0a5c48fb2f1b2e5a0a8e19fff7;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_208c1d0a5c48fb2f1b2e5a0a8e19fff7, codeobj_208c1d0a5c48fb2f1b2e5a0a8e19fff7, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_208c1d0a5c48fb2f1b2e5a0a8e19fff7 = cache_frame_208c1d0a5c48fb2f1b2e5a0a8e19fff7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_208c1d0a5c48fb2f1b2e5a0a8e19fff7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_208c1d0a5c48fb2f1b2e5a0a8e19fff7 ) == 2 ); // Frame stack

    // Framed code:
    tmp_ass_subvalue_1 = PyList_New( 1 );
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_list_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_list_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_1 );

        exception_lineno = 555;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyList_SET_ITEM( tmp_ass_subvalue_1, 0, tmp_list_element_1 );
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 555;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 555;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_208c1d0a5c48fb2f1b2e5a0a8e19fff7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_208c1d0a5c48fb2f1b2e5a0a8e19fff7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_208c1d0a5c48fb2f1b2e5a0a8e19fff7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_208c1d0a5c48fb2f1b2e5a0a8e19fff7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_208c1d0a5c48fb2f1b2e5a0a8e19fff7, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_208c1d0a5c48fb2f1b2e5a0a8e19fff7, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_208c1d0a5c48fb2f1b2e5a0a8e19fff7 == cache_frame_208c1d0a5c48fb2f1b2e5a0a8e19fff7 )
    {
        Py_DECREF( frame_208c1d0a5c48fb2f1b2e5a0a8e19fff7 );
    }
    cache_frame_208c1d0a5c48fb2f1b2e5a0a8e19fff7 = NULL;

    assertFrameObject( frame_208c1d0a5c48fb2f1b2e5a0a8e19fff7 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_24_p_external_declaration_3 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_24_p_external_declaration_3 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_25_p_external_declaration_4( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_229da5f0e9fa3c82a38b125a410979e1 = NULL;

    struct Nuitka_FrameObject *frame_229da5f0e9fa3c82a38b125a410979e1;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_229da5f0e9fa3c82a38b125a410979e1, codeobj_229da5f0e9fa3c82a38b125a410979e1, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_229da5f0e9fa3c82a38b125a410979e1 = cache_frame_229da5f0e9fa3c82a38b125a410979e1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_229da5f0e9fa3c82a38b125a410979e1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_229da5f0e9fa3c82a38b125a410979e1 ) == 2 ); // Frame stack

    // Framed code:
    tmp_ass_subvalue_1 = Py_None;
    tmp_ass_subscribed_1 = par_p;

    CHECK_OBJECT( tmp_ass_subscribed_1 );
    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 560;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_229da5f0e9fa3c82a38b125a410979e1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_229da5f0e9fa3c82a38b125a410979e1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_229da5f0e9fa3c82a38b125a410979e1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_229da5f0e9fa3c82a38b125a410979e1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_229da5f0e9fa3c82a38b125a410979e1, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_229da5f0e9fa3c82a38b125a410979e1, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_229da5f0e9fa3c82a38b125a410979e1 == cache_frame_229da5f0e9fa3c82a38b125a410979e1 )
    {
        Py_DECREF( frame_229da5f0e9fa3c82a38b125a410979e1 );
    }
    cache_frame_229da5f0e9fa3c82a38b125a410979e1 = NULL;

    assertFrameObject( frame_229da5f0e9fa3c82a38b125a410979e1 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_25_p_external_declaration_4 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_25_p_external_declaration_4 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_26_p_pp_directive( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_e6bd3ffd6382f6051682737b197f564d = NULL;

    struct Nuitka_FrameObject *frame_e6bd3ffd6382f6051682737b197f564d;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e6bd3ffd6382f6051682737b197f564d, codeobj_e6bd3ffd6382f6051682737b197f564d, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_e6bd3ffd6382f6051682737b197f564d = cache_frame_e6bd3ffd6382f6051682737b197f564d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e6bd3ffd6382f6051682737b197f564d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e6bd3ffd6382f6051682737b197f564d ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__parse_error );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 565;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = const_str_digest_87931e228ae4f4b725f2af333756cf40;
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 566;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 566;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = par_p;

    if ( tmp_args_element_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 566;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = const_int_pos_1;
    frame_e6bd3ffd6382f6051682737b197f564d->m_frame.f_lineno = 566;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_args_element_name_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 566;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_e6bd3ffd6382f6051682737b197f564d->m_frame.f_lineno = 565;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 565;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e6bd3ffd6382f6051682737b197f564d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e6bd3ffd6382f6051682737b197f564d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e6bd3ffd6382f6051682737b197f564d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e6bd3ffd6382f6051682737b197f564d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e6bd3ffd6382f6051682737b197f564d, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_e6bd3ffd6382f6051682737b197f564d, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_e6bd3ffd6382f6051682737b197f564d == cache_frame_e6bd3ffd6382f6051682737b197f564d )
    {
        Py_DECREF( frame_e6bd3ffd6382f6051682737b197f564d );
    }
    cache_frame_e6bd3ffd6382f6051682737b197f564d = NULL;

    assertFrameObject( frame_e6bd3ffd6382f6051682737b197f564d );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_26_p_pp_directive );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_26_p_pp_directive );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_27_p_pppragma_directive( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscribed_2;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subscript_2;
    int tmp_ass_subscript_res_1;
    int tmp_ass_subscript_res_2;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_ass_subvalue_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_593cfeb60507e7593ca2134a702e323c = NULL;

    struct Nuitka_FrameObject *frame_593cfeb60507e7593ca2134a702e323c;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_593cfeb60507e7593ca2134a702e323c, codeobj_593cfeb60507e7593ca2134a702e323c, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_593cfeb60507e7593ca2134a702e323c = cache_frame_593cfeb60507e7593ca2134a702e323c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_593cfeb60507e7593ca2134a702e323c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_593cfeb60507e7593ca2134a702e323c ) == 2 ); // Frame stack

    // Framed code:
    tmp_len_arg_1 = par_p;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 572;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_pos_3;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 572;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 573;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_Pragma );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 573;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 573;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_2;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 573;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 573;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 573;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = par_p;

    if ( tmp_args_element_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 573;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = const_int_pos_2;
    frame_593cfeb60507e7593ca2134a702e323c->m_frame.f_lineno = 573;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_args_element_name_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 573;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_593cfeb60507e7593ca2134a702e323c->m_frame.f_lineno = 573;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 573;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 573;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 573;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto branch_end_1;
    branch_no_1:;
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 575;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_Pragma );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 575;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_5 = const_str_empty;
    tmp_source_name_4 = par_self;

    if ( tmp_source_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 575;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__token_coord );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 575;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_7 = par_p;

    if ( tmp_args_element_name_7 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_called_name_4 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 575;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_8 = const_int_pos_1;
    frame_593cfeb60507e7593ca2134a702e323c->m_frame.f_lineno = 575;
    {
        PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8 };
        tmp_args_element_name_6 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 575;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_593cfeb60507e7593ca2134a702e323c->m_frame.f_lineno = 575;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_ass_subvalue_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_ass_subvalue_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 575;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_2 = par_p;

    if ( tmp_ass_subscribed_2 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 575;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_2 = const_int_0;
    tmp_ass_subscript_res_2 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_2, tmp_ass_subscript_2, 0, tmp_ass_subvalue_2 );
    Py_DECREF( tmp_ass_subvalue_2 );
    if ( tmp_ass_subscript_res_2 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 575;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_593cfeb60507e7593ca2134a702e323c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_593cfeb60507e7593ca2134a702e323c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_593cfeb60507e7593ca2134a702e323c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_593cfeb60507e7593ca2134a702e323c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_593cfeb60507e7593ca2134a702e323c, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_593cfeb60507e7593ca2134a702e323c, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_593cfeb60507e7593ca2134a702e323c == cache_frame_593cfeb60507e7593ca2134a702e323c )
    {
        Py_DECREF( frame_593cfeb60507e7593ca2134a702e323c );
    }
    cache_frame_593cfeb60507e7593ca2134a702e323c = NULL;

    assertFrameObject( frame_593cfeb60507e7593ca2134a702e323c );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_27_p_pppragma_directive );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_27_p_pppragma_directive );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_28_p_function_definition_1( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *var_spec = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_name_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_key_4;
    PyObject *tmp_dict_key_5;
    PyObject *tmp_dict_key_6;
    PyObject *tmp_dict_key_7;
    PyObject *tmp_dict_key_8;
    PyObject *tmp_dict_key_9;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_dict_value_4;
    PyObject *tmp_dict_value_5;
    PyObject *tmp_dict_value_6;
    PyObject *tmp_dict_value_7;
    PyObject *tmp_dict_value_8;
    PyObject *tmp_dict_value_9;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_kw_name_2;
    PyObject *tmp_list_element_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    static struct Nuitka_FrameObject *cache_frame_a679bfacf9dd7eea1a788fa45bb0ce95 = NULL;

    struct Nuitka_FrameObject *frame_a679bfacf9dd7eea1a788fa45bb0ce95;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a679bfacf9dd7eea1a788fa45bb0ce95, codeobj_a679bfacf9dd7eea1a788fa45bb0ce95, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_a679bfacf9dd7eea1a788fa45bb0ce95 = cache_frame_a679bfacf9dd7eea1a788fa45bb0ce95;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a679bfacf9dd7eea1a788fa45bb0ce95 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a679bfacf9dd7eea1a788fa45bb0ce95 ) == 2 ); // Frame stack

    // Framed code:
    tmp_assign_source_1 = _PyDict_NewPresized( 4 );
    tmp_dict_key_1 = const_str_plain_qual;
    tmp_dict_value_1 = PyList_New( 0 );
    tmp_res = PyDict_SetItem( tmp_assign_source_1, tmp_dict_key_1, tmp_dict_value_1 );
    Py_DECREF( tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_storage;
    tmp_dict_value_2 = PyList_New( 0 );
    tmp_res = PyDict_SetItem( tmp_assign_source_1, tmp_dict_key_2, tmp_dict_value_2 );
    Py_DECREF( tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_3 = const_str_plain_type;
    tmp_dict_value_3 = PyList_New( 1 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {
        Py_DECREF( tmp_assign_source_1 );
        Py_DECREF( tmp_dict_value_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 587;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_IdentifierType );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_1 );
        Py_DECREF( tmp_dict_value_3 );

        exception_lineno = 587;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_name_1 = DEEP_COPY( const_tuple_list_str_plain_int_list_tuple );
    tmp_kw_name_1 = _PyDict_NewPresized( 1 );
    tmp_dict_key_4 = const_str_plain_coord;
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_assign_source_1 );
        Py_DECREF( tmp_dict_value_3 );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 588;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_1 );
        Py_DECREF( tmp_dict_value_3 );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 588;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_p;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_assign_source_1 );
        Py_DECREF( tmp_dict_value_3 );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 588;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = const_int_pos_1;
    frame_a679bfacf9dd7eea1a788fa45bb0ce95->m_frame.f_lineno = 588;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_dict_value_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_dict_value_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_1 );
        Py_DECREF( tmp_dict_value_3 );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 588;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_4, tmp_dict_value_4 );
    Py_DECREF( tmp_dict_value_4 );
    assert( !(tmp_res != 0) );
    frame_a679bfacf9dd7eea1a788fa45bb0ce95->m_frame.f_lineno = 587;
    tmp_list_element_1 = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_list_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_1 );
        Py_DECREF( tmp_dict_value_3 );

        exception_lineno = 587;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    PyList_SET_ITEM( tmp_dict_value_3, 0, tmp_list_element_1 );
    tmp_res = PyDict_SetItem( tmp_assign_source_1, tmp_dict_key_3, tmp_dict_value_3 );
    Py_DECREF( tmp_dict_value_3 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_5 = const_str_plain_function;
    tmp_dict_value_5 = PyList_New( 0 );
    tmp_res = PyDict_SetItem( tmp_assign_source_1, tmp_dict_key_5, tmp_dict_value_5 );
    Py_DECREF( tmp_dict_value_5 );
    assert( !(tmp_res != 0) );
    assert( var_spec == NULL );
    var_spec = tmp_assign_source_1;

    tmp_source_name_3 = par_self;

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 591;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__build_function_definition );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 591;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_2 = _PyDict_NewPresized( 4 );
    tmp_dict_key_6 = const_str_plain_spec;
    tmp_dict_value_6 = var_spec;

    if ( tmp_dict_value_6 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 592;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_6, tmp_dict_value_6 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_7 = const_str_plain_decl;
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 593;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_dict_value_7 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_dict_value_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_kw_name_2 );

        exception_lineno = 593;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_7, tmp_dict_value_7 );
    Py_DECREF( tmp_dict_value_7 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_8 = const_str_plain_param_decls;
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 594;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_2;
    tmp_dict_value_8 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_dict_value_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_kw_name_2 );

        exception_lineno = 594;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_8, tmp_dict_value_8 );
    Py_DECREF( tmp_dict_value_8 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_9 = const_str_plain_body;
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 595;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_3;
    tmp_dict_value_9 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_dict_value_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_kw_name_2 );

        exception_lineno = 595;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_9, tmp_dict_value_9 );
    Py_DECREF( tmp_dict_value_9 );
    assert( !(tmp_res != 0) );
    frame_a679bfacf9dd7eea1a788fa45bb0ce95->m_frame.f_lineno = 591;
    tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_3, tmp_kw_name_2 );
    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_kw_name_2 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 591;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 591;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 591;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a679bfacf9dd7eea1a788fa45bb0ce95 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a679bfacf9dd7eea1a788fa45bb0ce95 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a679bfacf9dd7eea1a788fa45bb0ce95, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a679bfacf9dd7eea1a788fa45bb0ce95->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a679bfacf9dd7eea1a788fa45bb0ce95, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_a679bfacf9dd7eea1a788fa45bb0ce95, type_description ,par_self, par_p, var_spec );

    // Release cached frame.
    if ( frame_a679bfacf9dd7eea1a788fa45bb0ce95 == cache_frame_a679bfacf9dd7eea1a788fa45bb0ce95 )
    {
        Py_DECREF( frame_a679bfacf9dd7eea1a788fa45bb0ce95 );
    }
    cache_frame_a679bfacf9dd7eea1a788fa45bb0ce95 = NULL;

    assertFrameObject( frame_a679bfacf9dd7eea1a788fa45bb0ce95 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_28_p_function_definition_1 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_spec );
    var_spec = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_spec );
    var_spec = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_28_p_function_definition_1 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_29_p_function_definition_2( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *var_spec = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_key_4;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_dict_value_4;
    PyObject *tmp_kw_name_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    static struct Nuitka_FrameObject *cache_frame_48b53f7793e20849ff5aff6a6726fe71 = NULL;

    struct Nuitka_FrameObject *frame_48b53f7793e20849ff5aff6a6726fe71;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_48b53f7793e20849ff5aff6a6726fe71, codeobj_48b53f7793e20849ff5aff6a6726fe71, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_48b53f7793e20849ff5aff6a6726fe71 = cache_frame_48b53f7793e20849ff5aff6a6726fe71;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_48b53f7793e20849ff5aff6a6726fe71 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_48b53f7793e20849ff5aff6a6726fe71 ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_assign_source_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 600;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_spec == NULL );
    var_spec = tmp_assign_source_1;

    tmp_source_name_1 = par_self;

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 602;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__build_function_definition );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 602;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_1 = _PyDict_NewPresized( 4 );
    tmp_dict_key_1 = const_str_plain_spec;
    tmp_dict_value_1 = var_spec;

    if ( tmp_dict_value_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 603;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_decl;
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 604;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_2;
    tmp_dict_value_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_dict_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 604;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    Py_DECREF( tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_3 = const_str_plain_param_decls;
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 605;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_3;
    tmp_dict_value_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_dict_value_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 605;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3 );
    Py_DECREF( tmp_dict_value_3 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_4 = const_str_plain_body;
    tmp_subscribed_name_4 = par_p;

    if ( tmp_subscribed_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 606;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_4 = const_int_pos_4;
    tmp_dict_value_4 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_4 );
    if ( tmp_dict_value_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 606;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_4, tmp_dict_value_4 );
    Py_DECREF( tmp_dict_value_4 );
    assert( !(tmp_res != 0) );
    frame_48b53f7793e20849ff5aff6a6726fe71->m_frame.f_lineno = 602;
    tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 602;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 602;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 602;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_48b53f7793e20849ff5aff6a6726fe71 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_48b53f7793e20849ff5aff6a6726fe71 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_48b53f7793e20849ff5aff6a6726fe71, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_48b53f7793e20849ff5aff6a6726fe71->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_48b53f7793e20849ff5aff6a6726fe71, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_48b53f7793e20849ff5aff6a6726fe71, type_description ,par_self, par_p, var_spec );

    // Release cached frame.
    if ( frame_48b53f7793e20849ff5aff6a6726fe71 == cache_frame_48b53f7793e20849ff5aff6a6726fe71 )
    {
        Py_DECREF( frame_48b53f7793e20849ff5aff6a6726fe71 );
    }
    cache_frame_48b53f7793e20849ff5aff6a6726fe71 = NULL;

    assertFrameObject( frame_48b53f7793e20849ff5aff6a6726fe71 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_29_p_function_definition_2 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_spec );
    var_spec = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_spec );
    var_spec = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_29_p_function_definition_2 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_30_p_statement( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_return_value;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_7eb54679c49b7375444fb88c8b84b1c2 = NULL;

    struct Nuitka_FrameObject *frame_7eb54679c49b7375444fb88c8b84b1c2;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7eb54679c49b7375444fb88c8b84b1c2, codeobj_7eb54679c49b7375444fb88c8b84b1c2, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_7eb54679c49b7375444fb88c8b84b1c2 = cache_frame_7eb54679c49b7375444fb88c8b84b1c2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7eb54679c49b7375444fb88c8b84b1c2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7eb54679c49b7375444fb88c8b84b1c2 ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 617;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 617;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 617;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7eb54679c49b7375444fb88c8b84b1c2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7eb54679c49b7375444fb88c8b84b1c2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7eb54679c49b7375444fb88c8b84b1c2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7eb54679c49b7375444fb88c8b84b1c2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7eb54679c49b7375444fb88c8b84b1c2, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_7eb54679c49b7375444fb88c8b84b1c2, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_7eb54679c49b7375444fb88c8b84b1c2 == cache_frame_7eb54679c49b7375444fb88c8b84b1c2 )
    {
        Py_DECREF( frame_7eb54679c49b7375444fb88c8b84b1c2 );
    }
    cache_frame_7eb54679c49b7375444fb88c8b84b1c2 = NULL;

    assertFrameObject( frame_7eb54679c49b7375444fb88c8b84b1c2 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_30_p_statement );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_30_p_statement );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_31_p_decl_body( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *var_spec = NULL;
    PyObject *var_ty = NULL;
    PyObject *var_s_u_or_e = NULL;
    PyObject *var_decls = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_key_4;
    PyObject *tmp_dict_key_5;
    PyObject *tmp_dict_key_6;
    PyObject *tmp_dict_key_7;
    PyObject *tmp_dict_key_8;
    PyObject *tmp_dict_key_9;
    PyObject *tmp_dict_key_10;
    PyObject *tmp_dict_key_11;
    PyObject *tmp_dict_key_12;
    PyObject *tmp_dict_key_13;
    PyObject *tmp_dict_key_14;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_dict_value_4;
    PyObject *tmp_dict_value_5;
    PyObject *tmp_dict_value_6;
    PyObject *tmp_dict_value_7;
    PyObject *tmp_dict_value_8;
    PyObject *tmp_dict_value_9;
    PyObject *tmp_dict_value_10;
    PyObject *tmp_dict_value_11;
    PyObject *tmp_dict_value_12;
    PyObject *tmp_dict_value_13;
    PyObject *tmp_dict_value_14;
    bool tmp_is_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_kw_name_2;
    PyObject *tmp_kw_name_3;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_list_element_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscribed_name_5;
    PyObject *tmp_subscribed_name_6;
    PyObject *tmp_subscribed_name_7;
    PyObject *tmp_subscribed_name_8;
    PyObject *tmp_subscribed_name_9;
    PyObject *tmp_subscribed_name_10;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    PyObject *tmp_subscript_name_5;
    PyObject *tmp_subscript_name_6;
    PyObject *tmp_subscript_name_7;
    PyObject *tmp_subscript_name_8;
    PyObject *tmp_subscript_name_9;
    PyObject *tmp_subscript_name_10;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_9ebb7e26c81a6e62f517f5a1634c7145 = NULL;

    struct Nuitka_FrameObject *frame_9ebb7e26c81a6e62f517f5a1634c7145;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9ebb7e26c81a6e62f517f5a1634c7145, codeobj_9ebb7e26c81a6e62f517f5a1634c7145, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_9ebb7e26c81a6e62f517f5a1634c7145 = cache_frame_9ebb7e26c81a6e62f517f5a1634c7145;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9ebb7e26c81a6e62f517f5a1634c7145 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9ebb7e26c81a6e62f517f5a1634c7145 ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_assign_source_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 632;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_spec == NULL );
    var_spec = tmp_assign_source_1;

    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 636;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_2;
    tmp_compare_left_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 636;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_subscribed_name_3 = var_spec;

    if ( tmp_subscribed_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 641;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_str_plain_type;
    tmp_assign_source_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 641;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_ty == NULL );
    var_ty = tmp_assign_source_2;

    tmp_assign_source_3 = PyTuple_New( 3 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {
        Py_DECREF( tmp_assign_source_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 642;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_Struct );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_3 );

        exception_lineno = 642;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_assign_source_3, 0, tmp_tuple_element_1 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_assign_source_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 642;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_Union );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_3 );

        exception_lineno = 642;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_assign_source_3, 1, tmp_tuple_element_1 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_assign_source_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 642;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_Enum );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_3 );

        exception_lineno = 642;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_assign_source_3, 2, tmp_tuple_element_1 );
    assert( var_s_u_or_e == NULL );
    var_s_u_or_e = tmp_assign_source_3;

    tmp_len_arg_1 = var_ty;

    if ( tmp_len_arg_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "ty" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 643;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_compexpr_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 643;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_1 = const_int_pos_1;
    tmp_and_left_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    if ( tmp_and_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 643;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_1 );

        exception_lineno = 643;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    Py_DECREF( tmp_and_left_value_1 );
    tmp_subscribed_name_4 = var_ty;

    if ( tmp_subscribed_name_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "ty" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 643;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_4 = const_int_0;
    tmp_isinstance_inst_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_4 );
    if ( tmp_isinstance_inst_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 643;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_isinstance_cls_1 = var_s_u_or_e;

    if ( tmp_isinstance_cls_1 == NULL )
    {
        Py_DECREF( tmp_isinstance_inst_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "s_u_or_e" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 643;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_and_right_value_1 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    Py_DECREF( tmp_isinstance_inst_1 );
    if ( tmp_and_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 643;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_and_right_value_1 );
    tmp_cond_value_1 = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_cond_value_1 = tmp_and_left_value_1;
    and_end_1:;
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 643;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_assign_source_4 = PyList_New( 1 );
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_4 == NULL )
    {
        Py_DECREF( tmp_assign_source_4 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 644;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_Decl );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_4 );

        exception_lineno = 644;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_1 = _PyDict_NewPresized( 8 );
    tmp_dict_key_1 = const_str_plain_name;
    tmp_dict_value_1 = Py_None;
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_quals;
    tmp_subscribed_name_5 = var_spec;

    if ( tmp_subscribed_name_5 == NULL )
    {
        Py_DECREF( tmp_assign_source_4 );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 646;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_5 = const_str_plain_qual;
    tmp_dict_value_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_5, tmp_subscript_name_5 );
    if ( tmp_dict_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_4 );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 646;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    Py_DECREF( tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_3 = const_str_plain_storage;
    tmp_subscribed_name_6 = var_spec;

    if ( tmp_subscribed_name_6 == NULL )
    {
        Py_DECREF( tmp_assign_source_4 );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 647;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_6 = const_str_plain_storage;
    tmp_dict_value_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_6, tmp_subscript_name_6 );
    if ( tmp_dict_value_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_4 );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 647;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3 );
    Py_DECREF( tmp_dict_value_3 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_4 = const_str_plain_funcspec;
    tmp_subscribed_name_7 = var_spec;

    if ( tmp_subscribed_name_7 == NULL )
    {
        Py_DECREF( tmp_assign_source_4 );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 648;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_7 = const_str_plain_function;
    tmp_dict_value_4 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_7, tmp_subscript_name_7 );
    if ( tmp_dict_value_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_4 );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 648;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_4, tmp_dict_value_4 );
    Py_DECREF( tmp_dict_value_4 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_5 = const_str_plain_type;
    tmp_subscribed_name_8 = var_ty;

    if ( tmp_subscribed_name_8 == NULL )
    {
        Py_DECREF( tmp_assign_source_4 );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "ty" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 649;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_8 = const_int_0;
    tmp_dict_value_5 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_8, tmp_subscript_name_8 );
    if ( tmp_dict_value_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_4 );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 649;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_5, tmp_dict_value_5 );
    Py_DECREF( tmp_dict_value_5 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_6 = const_str_plain_init;
    tmp_dict_value_6 = Py_None;
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_6, tmp_dict_value_6 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_7 = const_str_plain_bitsize;
    tmp_dict_value_7 = Py_None;
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_7, tmp_dict_value_7 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_8 = const_str_plain_coord;
    tmp_subscribed_name_9 = var_ty;

    if ( tmp_subscribed_name_9 == NULL )
    {
        Py_DECREF( tmp_assign_source_4 );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "ty" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 652;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_9 = const_int_0;
    tmp_source_name_5 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_9, tmp_subscript_name_9 );
    if ( tmp_source_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_4 );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 652;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_dict_value_8 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_coord );
    Py_DECREF( tmp_source_name_5 );
    if ( tmp_dict_value_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_4 );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 652;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_8, tmp_dict_value_8 );
    Py_DECREF( tmp_dict_value_8 );
    assert( !(tmp_res != 0) );
    frame_9ebb7e26c81a6e62f517f5a1634c7145->m_frame.f_lineno = 644;
    tmp_list_element_1 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_list_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_4 );

        exception_lineno = 644;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    PyList_SET_ITEM( tmp_assign_source_4, 0, tmp_list_element_1 );
    assert( var_decls == NULL );
    var_decls = tmp_assign_source_4;

    goto branch_end_2;
    branch_no_2:;
    tmp_source_name_6 = par_self;

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 660;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__build_declarations );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 660;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_2 = _PyDict_NewPresized( 3 );
    tmp_dict_key_9 = const_str_plain_spec;
    tmp_dict_value_9 = var_spec;

    if ( tmp_dict_value_9 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 661;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_9, tmp_dict_value_9 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_10 = const_str_plain_decls;
    tmp_dict_value_10 = DEEP_COPY( const_list_dict_2c030ba937b9e185526e262591ee7db7_list );
    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_10, tmp_dict_value_10 );
    Py_DECREF( tmp_dict_value_10 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_11 = const_str_plain_typedef_namespace;
    tmp_dict_value_11 = Py_True;
    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_11, tmp_dict_value_11 );
    assert( !(tmp_res != 0) );
    frame_9ebb7e26c81a6e62f517f5a1634c7145->m_frame.f_lineno = 660;
    tmp_assign_source_5 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_2, tmp_kw_name_2 );
    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_kw_name_2 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 660;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_decls;
        var_decls = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    branch_end_2:;
    goto branch_end_1;
    branch_no_1:;
    tmp_source_name_7 = par_self;

    if ( tmp_source_name_7 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 666;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__build_declarations );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 666;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_3 = _PyDict_NewPresized( 3 );
    tmp_dict_key_12 = const_str_plain_spec;
    tmp_dict_value_12 = var_spec;

    if ( tmp_dict_value_12 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_kw_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 667;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_3, tmp_dict_key_12, tmp_dict_value_12 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_13 = const_str_plain_decls;
    tmp_subscribed_name_10 = par_p;

    if ( tmp_subscribed_name_10 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_kw_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 668;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_10 = const_int_pos_2;
    tmp_dict_value_13 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_10, tmp_subscript_name_10 );
    if ( tmp_dict_value_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_kw_name_3 );

        exception_lineno = 668;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_3, tmp_dict_key_13, tmp_dict_value_13 );
    Py_DECREF( tmp_dict_value_13 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_14 = const_str_plain_typedef_namespace;
    tmp_dict_value_14 = Py_True;
    tmp_res = PyDict_SetItem( tmp_kw_name_3, tmp_dict_key_14, tmp_dict_value_14 );
    assert( !(tmp_res != 0) );
    frame_9ebb7e26c81a6e62f517f5a1634c7145->m_frame.f_lineno = 666;
    tmp_assign_source_6 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_3, tmp_kw_name_3 );
    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_kw_name_3 );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 666;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_decls == NULL );
    var_decls = tmp_assign_source_6;

    branch_end_1:;
    tmp_ass_subvalue_1 = var_decls;

    if ( tmp_ass_subvalue_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decls" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 671;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 671;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 671;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9ebb7e26c81a6e62f517f5a1634c7145 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9ebb7e26c81a6e62f517f5a1634c7145 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9ebb7e26c81a6e62f517f5a1634c7145, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9ebb7e26c81a6e62f517f5a1634c7145->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9ebb7e26c81a6e62f517f5a1634c7145, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_9ebb7e26c81a6e62f517f5a1634c7145, type_description ,par_self, par_p, var_spec, var_ty, var_s_u_or_e, var_decls );

    // Release cached frame.
    if ( frame_9ebb7e26c81a6e62f517f5a1634c7145 == cache_frame_9ebb7e26c81a6e62f517f5a1634c7145 )
    {
        Py_DECREF( frame_9ebb7e26c81a6e62f517f5a1634c7145 );
    }
    cache_frame_9ebb7e26c81a6e62f517f5a1634c7145 = NULL;

    assertFrameObject( frame_9ebb7e26c81a6e62f517f5a1634c7145 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_31_p_decl_body );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_spec );
    var_spec = NULL;

    Py_XDECREF( var_ty );
    var_ty = NULL;

    Py_XDECREF( var_s_u_or_e );
    var_s_u_or_e = NULL;

    Py_XDECREF( var_decls );
    var_decls = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_spec );
    var_spec = NULL;

    Py_XDECREF( var_ty );
    var_ty = NULL;

    Py_XDECREF( var_s_u_or_e );
    var_s_u_or_e = NULL;

    Py_XDECREF( var_decls );
    var_decls = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_31_p_decl_body );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_32_p_declaration( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_return_value;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_daf91fd058413412def7e9cba646ba87 = NULL;

    struct Nuitka_FrameObject *frame_daf91fd058413412def7e9cba646ba87;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_daf91fd058413412def7e9cba646ba87, codeobj_daf91fd058413412def7e9cba646ba87, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_daf91fd058413412def7e9cba646ba87 = cache_frame_daf91fd058413412def7e9cba646ba87;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_daf91fd058413412def7e9cba646ba87 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_daf91fd058413412def7e9cba646ba87 ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 691;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 691;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 691;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_daf91fd058413412def7e9cba646ba87 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_daf91fd058413412def7e9cba646ba87 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_daf91fd058413412def7e9cba646ba87, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_daf91fd058413412def7e9cba646ba87->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_daf91fd058413412def7e9cba646ba87, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_daf91fd058413412def7e9cba646ba87, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_daf91fd058413412def7e9cba646ba87 == cache_frame_daf91fd058413412def7e9cba646ba87 )
    {
        Py_DECREF( frame_daf91fd058413412def7e9cba646ba87 );
    }
    cache_frame_daf91fd058413412def7e9cba646ba87 = NULL;

    assertFrameObject( frame_daf91fd058413412def7e9cba646ba87 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_32_p_declaration );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_32_p_declaration );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_33_p_declaration_list( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    static struct Nuitka_FrameObject *cache_frame_a550651500717a2145499cdc22099572 = NULL;

    struct Nuitka_FrameObject *frame_a550651500717a2145499cdc22099572;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a550651500717a2145499cdc22099572, codeobj_a550651500717a2145499cdc22099572, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_a550651500717a2145499cdc22099572 = cache_frame_a550651500717a2145499cdc22099572;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a550651500717a2145499cdc22099572 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a550651500717a2145499cdc22099572 ) == 2 ); // Frame stack

    // Framed code:
    tmp_len_arg_1 = par_p;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 701;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_pos_2;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 701;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto condexpr_true_1;
    }
    else
    {
        goto condexpr_false_1;
    }
    condexpr_true_1:;
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 701;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 701;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto condexpr_end_1;
    condexpr_false_1:;
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 701;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_1;
    tmp_left_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_left_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 701;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_left_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 701;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_2;
    tmp_right_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_1 );

        exception_lineno = 701;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subvalue_1 = BINARY_OPERATION_ADD( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_left_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 701;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    condexpr_end_1:;
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 701;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 701;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a550651500717a2145499cdc22099572 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a550651500717a2145499cdc22099572 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a550651500717a2145499cdc22099572, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a550651500717a2145499cdc22099572->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a550651500717a2145499cdc22099572, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_a550651500717a2145499cdc22099572, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_a550651500717a2145499cdc22099572 == cache_frame_a550651500717a2145499cdc22099572 )
    {
        Py_DECREF( frame_a550651500717a2145499cdc22099572 );
    }
    cache_frame_a550651500717a2145499cdc22099572 = NULL;

    assertFrameObject( frame_a550651500717a2145499cdc22099572 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_33_p_declaration_list );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_33_p_declaration_list );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_34_p_declaration_specifiers_no_type_1( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    static struct Nuitka_FrameObject *cache_frame_36fc1a9c2412033462d3fd044b8c43d8 = NULL;

    struct Nuitka_FrameObject *frame_36fc1a9c2412033462d3fd044b8c43d8;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_36fc1a9c2412033462d3fd044b8c43d8, codeobj_36fc1a9c2412033462d3fd044b8c43d8, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_36fc1a9c2412033462d3fd044b8c43d8 = cache_frame_36fc1a9c2412033462d3fd044b8c43d8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_36fc1a9c2412033462d3fd044b8c43d8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_36fc1a9c2412033462d3fd044b8c43d8 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__add_declaration_specifier );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 711;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 711;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_2;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 711;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 711;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_1;
    tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 711;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = const_str_plain_qual;
    frame_36fc1a9c2412033462d3fd044b8c43d8->m_frame.f_lineno = 711;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 711;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 711;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 711;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_36fc1a9c2412033462d3fd044b8c43d8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_36fc1a9c2412033462d3fd044b8c43d8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_36fc1a9c2412033462d3fd044b8c43d8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_36fc1a9c2412033462d3fd044b8c43d8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_36fc1a9c2412033462d3fd044b8c43d8, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_36fc1a9c2412033462d3fd044b8c43d8, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_36fc1a9c2412033462d3fd044b8c43d8 == cache_frame_36fc1a9c2412033462d3fd044b8c43d8 )
    {
        Py_DECREF( frame_36fc1a9c2412033462d3fd044b8c43d8 );
    }
    cache_frame_36fc1a9c2412033462d3fd044b8c43d8 = NULL;

    assertFrameObject( frame_36fc1a9c2412033462d3fd044b8c43d8 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_34_p_declaration_specifiers_no_type_1 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_34_p_declaration_specifiers_no_type_1 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_35_p_declaration_specifiers_no_type_2( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    static struct Nuitka_FrameObject *cache_frame_a2b727d56381a053396d12a662497a0c = NULL;

    struct Nuitka_FrameObject *frame_a2b727d56381a053396d12a662497a0c;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a2b727d56381a053396d12a662497a0c, codeobj_a2b727d56381a053396d12a662497a0c, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_a2b727d56381a053396d12a662497a0c = cache_frame_a2b727d56381a053396d12a662497a0c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a2b727d56381a053396d12a662497a0c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a2b727d56381a053396d12a662497a0c ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__add_declaration_specifier );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 716;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 716;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_2;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 716;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 716;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_1;
    tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 716;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = const_str_plain_storage;
    frame_a2b727d56381a053396d12a662497a0c->m_frame.f_lineno = 716;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 716;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 716;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 716;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a2b727d56381a053396d12a662497a0c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a2b727d56381a053396d12a662497a0c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a2b727d56381a053396d12a662497a0c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a2b727d56381a053396d12a662497a0c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a2b727d56381a053396d12a662497a0c, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_a2b727d56381a053396d12a662497a0c, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_a2b727d56381a053396d12a662497a0c == cache_frame_a2b727d56381a053396d12a662497a0c )
    {
        Py_DECREF( frame_a2b727d56381a053396d12a662497a0c );
    }
    cache_frame_a2b727d56381a053396d12a662497a0c = NULL;

    assertFrameObject( frame_a2b727d56381a053396d12a662497a0c );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_35_p_declaration_specifiers_no_type_2 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_35_p_declaration_specifiers_no_type_2 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_36_p_declaration_specifiers_no_type_3( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    static struct Nuitka_FrameObject *cache_frame_3ec228d3af3ab7e0d8598e8ae146fa09 = NULL;

    struct Nuitka_FrameObject *frame_3ec228d3af3ab7e0d8598e8ae146fa09;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3ec228d3af3ab7e0d8598e8ae146fa09, codeobj_3ec228d3af3ab7e0d8598e8ae146fa09, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_3ec228d3af3ab7e0d8598e8ae146fa09 = cache_frame_3ec228d3af3ab7e0d8598e8ae146fa09;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3ec228d3af3ab7e0d8598e8ae146fa09 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3ec228d3af3ab7e0d8598e8ae146fa09 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__add_declaration_specifier );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 721;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 721;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_2;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 721;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 721;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_1;
    tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 721;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = const_str_plain_function;
    frame_3ec228d3af3ab7e0d8598e8ae146fa09->m_frame.f_lineno = 721;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 721;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 721;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 721;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3ec228d3af3ab7e0d8598e8ae146fa09 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3ec228d3af3ab7e0d8598e8ae146fa09 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3ec228d3af3ab7e0d8598e8ae146fa09, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3ec228d3af3ab7e0d8598e8ae146fa09->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3ec228d3af3ab7e0d8598e8ae146fa09, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_3ec228d3af3ab7e0d8598e8ae146fa09, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_3ec228d3af3ab7e0d8598e8ae146fa09 == cache_frame_3ec228d3af3ab7e0d8598e8ae146fa09 )
    {
        Py_DECREF( frame_3ec228d3af3ab7e0d8598e8ae146fa09 );
    }
    cache_frame_3ec228d3af3ab7e0d8598e8ae146fa09 = NULL;

    assertFrameObject( frame_3ec228d3af3ab7e0d8598e8ae146fa09 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_36_p_declaration_specifiers_no_type_3 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_36_p_declaration_specifiers_no_type_3 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_37_p_declaration_specifiers_1( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_name_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_dc55435f67e174458f33671217fef464 = NULL;

    struct Nuitka_FrameObject *frame_dc55435f67e174458f33671217fef464;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_dc55435f67e174458f33671217fef464, codeobj_dc55435f67e174458f33671217fef464, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_dc55435f67e174458f33671217fef464 = cache_frame_dc55435f67e174458f33671217fef464;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_dc55435f67e174458f33671217fef464 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_dc55435f67e174458f33671217fef464 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__add_declaration_specifier );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 727;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_name_1 = PyTuple_New( 3 );
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 727;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_tuple_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );

        exception_lineno = 727;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 727;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_2;
    tmp_tuple_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );

        exception_lineno = 727;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_args_name_1, 1, tmp_tuple_element_1 );
    tmp_tuple_element_1 = const_str_plain_qual;
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 2, tmp_tuple_element_1 );
    tmp_kw_name_1 = PyDict_Copy( const_dict_9d1be102e274ebd5d21e13e40f132db0 );
    frame_dc55435f67e174458f33671217fef464->m_frame.f_lineno = 727;
    tmp_ass_subvalue_1 = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 727;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 727;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 727;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dc55435f67e174458f33671217fef464 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dc55435f67e174458f33671217fef464 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_dc55435f67e174458f33671217fef464, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_dc55435f67e174458f33671217fef464->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_dc55435f67e174458f33671217fef464, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_dc55435f67e174458f33671217fef464, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_dc55435f67e174458f33671217fef464 == cache_frame_dc55435f67e174458f33671217fef464 )
    {
        Py_DECREF( frame_dc55435f67e174458f33671217fef464 );
    }
    cache_frame_dc55435f67e174458f33671217fef464 = NULL;

    assertFrameObject( frame_dc55435f67e174458f33671217fef464 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_37_p_declaration_specifiers_1 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_37_p_declaration_specifiers_1 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_38_p_declaration_specifiers_2( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_name_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_955db861391b760644188637061a0be7 = NULL;

    struct Nuitka_FrameObject *frame_955db861391b760644188637061a0be7;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_955db861391b760644188637061a0be7, codeobj_955db861391b760644188637061a0be7, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_955db861391b760644188637061a0be7 = cache_frame_955db861391b760644188637061a0be7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_955db861391b760644188637061a0be7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_955db861391b760644188637061a0be7 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__add_declaration_specifier );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 732;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_name_1 = PyTuple_New( 3 );
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 732;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_tuple_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );

        exception_lineno = 732;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 732;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_2;
    tmp_tuple_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );

        exception_lineno = 732;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_args_name_1, 1, tmp_tuple_element_1 );
    tmp_tuple_element_1 = const_str_plain_storage;
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 2, tmp_tuple_element_1 );
    tmp_kw_name_1 = PyDict_Copy( const_dict_9d1be102e274ebd5d21e13e40f132db0 );
    frame_955db861391b760644188637061a0be7->m_frame.f_lineno = 732;
    tmp_ass_subvalue_1 = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 732;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 732;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 732;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_955db861391b760644188637061a0be7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_955db861391b760644188637061a0be7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_955db861391b760644188637061a0be7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_955db861391b760644188637061a0be7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_955db861391b760644188637061a0be7, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_955db861391b760644188637061a0be7, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_955db861391b760644188637061a0be7 == cache_frame_955db861391b760644188637061a0be7 )
    {
        Py_DECREF( frame_955db861391b760644188637061a0be7 );
    }
    cache_frame_955db861391b760644188637061a0be7 = NULL;

    assertFrameObject( frame_955db861391b760644188637061a0be7 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_38_p_declaration_specifiers_2 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_38_p_declaration_specifiers_2 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_39_p_declaration_specifiers_3( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_name_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_ba284b447b2324f31e4033bc80c04da8 = NULL;

    struct Nuitka_FrameObject *frame_ba284b447b2324f31e4033bc80c04da8;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ba284b447b2324f31e4033bc80c04da8, codeobj_ba284b447b2324f31e4033bc80c04da8, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_ba284b447b2324f31e4033bc80c04da8 = cache_frame_ba284b447b2324f31e4033bc80c04da8;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ba284b447b2324f31e4033bc80c04da8 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ba284b447b2324f31e4033bc80c04da8 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__add_declaration_specifier );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 737;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_name_1 = PyTuple_New( 3 );
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 737;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_tuple_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );

        exception_lineno = 737;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 737;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_2;
    tmp_tuple_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );

        exception_lineno = 737;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_args_name_1, 1, tmp_tuple_element_1 );
    tmp_tuple_element_1 = const_str_plain_function;
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 2, tmp_tuple_element_1 );
    tmp_kw_name_1 = PyDict_Copy( const_dict_9d1be102e274ebd5d21e13e40f132db0 );
    frame_ba284b447b2324f31e4033bc80c04da8->m_frame.f_lineno = 737;
    tmp_ass_subvalue_1 = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 737;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 737;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 737;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ba284b447b2324f31e4033bc80c04da8 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ba284b447b2324f31e4033bc80c04da8 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ba284b447b2324f31e4033bc80c04da8, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ba284b447b2324f31e4033bc80c04da8->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ba284b447b2324f31e4033bc80c04da8, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_ba284b447b2324f31e4033bc80c04da8, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_ba284b447b2324f31e4033bc80c04da8 == cache_frame_ba284b447b2324f31e4033bc80c04da8 )
    {
        Py_DECREF( frame_ba284b447b2324f31e4033bc80c04da8 );
    }
    cache_frame_ba284b447b2324f31e4033bc80c04da8 = NULL;

    assertFrameObject( frame_ba284b447b2324f31e4033bc80c04da8 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_39_p_declaration_specifiers_3 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_39_p_declaration_specifiers_3 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_40_p_declaration_specifiers_4( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_name_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_1148723a196d3f7376492b433bec02f1 = NULL;

    struct Nuitka_FrameObject *frame_1148723a196d3f7376492b433bec02f1;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1148723a196d3f7376492b433bec02f1, codeobj_1148723a196d3f7376492b433bec02f1, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_1148723a196d3f7376492b433bec02f1 = cache_frame_1148723a196d3f7376492b433bec02f1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1148723a196d3f7376492b433bec02f1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1148723a196d3f7376492b433bec02f1 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__add_declaration_specifier );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 742;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_name_1 = PyTuple_New( 3 );
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 742;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_tuple_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );

        exception_lineno = 742;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 742;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_2;
    tmp_tuple_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );

        exception_lineno = 742;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_args_name_1, 1, tmp_tuple_element_1 );
    tmp_tuple_element_1 = const_str_plain_type;
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 2, tmp_tuple_element_1 );
    tmp_kw_name_1 = PyDict_Copy( const_dict_9d1be102e274ebd5d21e13e40f132db0 );
    frame_1148723a196d3f7376492b433bec02f1->m_frame.f_lineno = 742;
    tmp_ass_subvalue_1 = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 742;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 742;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 742;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1148723a196d3f7376492b433bec02f1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1148723a196d3f7376492b433bec02f1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1148723a196d3f7376492b433bec02f1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1148723a196d3f7376492b433bec02f1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1148723a196d3f7376492b433bec02f1, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_1148723a196d3f7376492b433bec02f1, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_1148723a196d3f7376492b433bec02f1 == cache_frame_1148723a196d3f7376492b433bec02f1 )
    {
        Py_DECREF( frame_1148723a196d3f7376492b433bec02f1 );
    }
    cache_frame_1148723a196d3f7376492b433bec02f1 = NULL;

    assertFrameObject( frame_1148723a196d3f7376492b433bec02f1 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_40_p_declaration_specifiers_4 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_40_p_declaration_specifiers_4 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_41_p_declaration_specifiers_5( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_ad0cabf99ebe872bef794caff00c20ff = NULL;

    struct Nuitka_FrameObject *frame_ad0cabf99ebe872bef794caff00c20ff;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ad0cabf99ebe872bef794caff00c20ff, codeobj_ad0cabf99ebe872bef794caff00c20ff, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_ad0cabf99ebe872bef794caff00c20ff = cache_frame_ad0cabf99ebe872bef794caff00c20ff;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ad0cabf99ebe872bef794caff00c20ff );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ad0cabf99ebe872bef794caff00c20ff ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__add_declaration_specifier );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 747;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = Py_None;
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 747;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 747;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = const_str_plain_type;
    frame_ad0cabf99ebe872bef794caff00c20ff->m_frame.f_lineno = 747;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 747;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 747;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 747;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ad0cabf99ebe872bef794caff00c20ff );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ad0cabf99ebe872bef794caff00c20ff );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ad0cabf99ebe872bef794caff00c20ff, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ad0cabf99ebe872bef794caff00c20ff->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ad0cabf99ebe872bef794caff00c20ff, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_ad0cabf99ebe872bef794caff00c20ff, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_ad0cabf99ebe872bef794caff00c20ff == cache_frame_ad0cabf99ebe872bef794caff00c20ff )
    {
        Py_DECREF( frame_ad0cabf99ebe872bef794caff00c20ff );
    }
    cache_frame_ad0cabf99ebe872bef794caff00c20ff = NULL;

    assertFrameObject( frame_ad0cabf99ebe872bef794caff00c20ff );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_41_p_declaration_specifiers_5 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_41_p_declaration_specifiers_5 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_42_p_declaration_specifiers_6( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_name_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_81f6b03a9095979e8e4c2741dd044885 = NULL;

    struct Nuitka_FrameObject *frame_81f6b03a9095979e8e4c2741dd044885;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_81f6b03a9095979e8e4c2741dd044885, codeobj_81f6b03a9095979e8e4c2741dd044885, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_81f6b03a9095979e8e4c2741dd044885 = cache_frame_81f6b03a9095979e8e4c2741dd044885;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_81f6b03a9095979e8e4c2741dd044885 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_81f6b03a9095979e8e4c2741dd044885 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__add_declaration_specifier );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 752;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_name_1 = PyTuple_New( 3 );
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 752;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_tuple_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );

        exception_lineno = 752;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 752;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_2;
    tmp_tuple_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );

        exception_lineno = 752;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_args_name_1, 1, tmp_tuple_element_1 );
    tmp_tuple_element_1 = const_str_plain_type;
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 2, tmp_tuple_element_1 );
    tmp_kw_name_1 = PyDict_Copy( const_dict_9d1be102e274ebd5d21e13e40f132db0 );
    frame_81f6b03a9095979e8e4c2741dd044885->m_frame.f_lineno = 752;
    tmp_ass_subvalue_1 = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 752;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 752;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 752;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_81f6b03a9095979e8e4c2741dd044885 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_81f6b03a9095979e8e4c2741dd044885 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_81f6b03a9095979e8e4c2741dd044885, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_81f6b03a9095979e8e4c2741dd044885->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_81f6b03a9095979e8e4c2741dd044885, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_81f6b03a9095979e8e4c2741dd044885, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_81f6b03a9095979e8e4c2741dd044885 == cache_frame_81f6b03a9095979e8e4c2741dd044885 )
    {
        Py_DECREF( frame_81f6b03a9095979e8e4c2741dd044885 );
    }
    cache_frame_81f6b03a9095979e8e4c2741dd044885 = NULL;

    assertFrameObject( frame_81f6b03a9095979e8e4c2741dd044885 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_42_p_declaration_specifiers_6 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_42_p_declaration_specifiers_6 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_43_p_storage_class_specifier( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_return_value;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_80b01d1e78e2951d30442bff34e5a4cb = NULL;

    struct Nuitka_FrameObject *frame_80b01d1e78e2951d30442bff34e5a4cb;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_80b01d1e78e2951d30442bff34e5a4cb, codeobj_80b01d1e78e2951d30442bff34e5a4cb, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_80b01d1e78e2951d30442bff34e5a4cb = cache_frame_80b01d1e78e2951d30442bff34e5a4cb;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_80b01d1e78e2951d30442bff34e5a4cb );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_80b01d1e78e2951d30442bff34e5a4cb ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 762;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 762;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 762;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_80b01d1e78e2951d30442bff34e5a4cb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_80b01d1e78e2951d30442bff34e5a4cb );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_80b01d1e78e2951d30442bff34e5a4cb, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_80b01d1e78e2951d30442bff34e5a4cb->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_80b01d1e78e2951d30442bff34e5a4cb, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_80b01d1e78e2951d30442bff34e5a4cb, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_80b01d1e78e2951d30442bff34e5a4cb == cache_frame_80b01d1e78e2951d30442bff34e5a4cb )
    {
        Py_DECREF( frame_80b01d1e78e2951d30442bff34e5a4cb );
    }
    cache_frame_80b01d1e78e2951d30442bff34e5a4cb = NULL;

    assertFrameObject( frame_80b01d1e78e2951d30442bff34e5a4cb );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_43_p_storage_class_specifier );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_43_p_storage_class_specifier );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_44_p_function_specifier( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_return_value;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_5cfdbbfac2e5693583b5c3bce0a5b55f = NULL;

    struct Nuitka_FrameObject *frame_5cfdbbfac2e5693583b5c3bce0a5b55f;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5cfdbbfac2e5693583b5c3bce0a5b55f, codeobj_5cfdbbfac2e5693583b5c3bce0a5b55f, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_5cfdbbfac2e5693583b5c3bce0a5b55f = cache_frame_5cfdbbfac2e5693583b5c3bce0a5b55f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5cfdbbfac2e5693583b5c3bce0a5b55f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5cfdbbfac2e5693583b5c3bce0a5b55f ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 767;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 767;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 767;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5cfdbbfac2e5693583b5c3bce0a5b55f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5cfdbbfac2e5693583b5c3bce0a5b55f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5cfdbbfac2e5693583b5c3bce0a5b55f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5cfdbbfac2e5693583b5c3bce0a5b55f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5cfdbbfac2e5693583b5c3bce0a5b55f, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_5cfdbbfac2e5693583b5c3bce0a5b55f, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_5cfdbbfac2e5693583b5c3bce0a5b55f == cache_frame_5cfdbbfac2e5693583b5c3bce0a5b55f )
    {
        Py_DECREF( frame_5cfdbbfac2e5693583b5c3bce0a5b55f );
    }
    cache_frame_5cfdbbfac2e5693583b5c3bce0a5b55f = NULL;

    assertFrameObject( frame_5cfdbbfac2e5693583b5c3bce0a5b55f );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_44_p_function_specifier );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_44_p_function_specifier );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_45_p_type_specifier_no_typeid( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_name_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_list_element_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_463376239af8505f839bcaa0249bfc10 = NULL;

    struct Nuitka_FrameObject *frame_463376239af8505f839bcaa0249bfc10;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_463376239af8505f839bcaa0249bfc10, codeobj_463376239af8505f839bcaa0249bfc10, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_463376239af8505f839bcaa0249bfc10 = cache_frame_463376239af8505f839bcaa0249bfc10;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_463376239af8505f839bcaa0249bfc10 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_463376239af8505f839bcaa0249bfc10 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 783;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_IdentifierType );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 783;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_name_1 = PyTuple_New( 1 );
    tmp_tuple_element_1 = PyList_New( 1 );
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 783;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_list_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_list_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_1 );

        exception_lineno = 783;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyList_SET_ITEM( tmp_tuple_element_1, 0, tmp_list_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
    tmp_kw_name_1 = _PyDict_NewPresized( 1 );
    tmp_dict_key_1 = const_str_plain_coord;
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 783;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 783;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_p;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 783;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = const_int_pos_1;
    frame_463376239af8505f839bcaa0249bfc10->m_frame.f_lineno = 783;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_dict_value_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_dict_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 783;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    Py_DECREF( tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    frame_463376239af8505f839bcaa0249bfc10->m_frame.f_lineno = 783;
    tmp_ass_subvalue_1 = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 783;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 783;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 783;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_463376239af8505f839bcaa0249bfc10 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_463376239af8505f839bcaa0249bfc10 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_463376239af8505f839bcaa0249bfc10, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_463376239af8505f839bcaa0249bfc10->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_463376239af8505f839bcaa0249bfc10, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_463376239af8505f839bcaa0249bfc10, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_463376239af8505f839bcaa0249bfc10 == cache_frame_463376239af8505f839bcaa0249bfc10 )
    {
        Py_DECREF( frame_463376239af8505f839bcaa0249bfc10 );
    }
    cache_frame_463376239af8505f839bcaa0249bfc10 = NULL;

    assertFrameObject( frame_463376239af8505f839bcaa0249bfc10 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_45_p_type_specifier_no_typeid );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_45_p_type_specifier_no_typeid );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_46_p_type_specifier( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_return_value;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_f569cd0da9b9127eb406763c7c607567 = NULL;

    struct Nuitka_FrameObject *frame_f569cd0da9b9127eb406763c7c607567;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f569cd0da9b9127eb406763c7c607567, codeobj_f569cd0da9b9127eb406763c7c607567, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_f569cd0da9b9127eb406763c7c607567 = cache_frame_f569cd0da9b9127eb406763c7c607567;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f569cd0da9b9127eb406763c7c607567 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f569cd0da9b9127eb406763c7c607567 ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 791;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 791;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 791;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f569cd0da9b9127eb406763c7c607567 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f569cd0da9b9127eb406763c7c607567 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f569cd0da9b9127eb406763c7c607567, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f569cd0da9b9127eb406763c7c607567->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f569cd0da9b9127eb406763c7c607567, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_f569cd0da9b9127eb406763c7c607567, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_f569cd0da9b9127eb406763c7c607567 == cache_frame_f569cd0da9b9127eb406763c7c607567 )
    {
        Py_DECREF( frame_f569cd0da9b9127eb406763c7c607567 );
    }
    cache_frame_f569cd0da9b9127eb406763c7c607567 = NULL;

    assertFrameObject( frame_f569cd0da9b9127eb406763c7c607567 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_46_p_type_specifier );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_46_p_type_specifier );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_47_p_type_qualifier( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_return_value;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_39de1eccef65c50e3c79de1d987275c6 = NULL;

    struct Nuitka_FrameObject *frame_39de1eccef65c50e3c79de1d987275c6;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_39de1eccef65c50e3c79de1d987275c6, codeobj_39de1eccef65c50e3c79de1d987275c6, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_39de1eccef65c50e3c79de1d987275c6 = cache_frame_39de1eccef65c50e3c79de1d987275c6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_39de1eccef65c50e3c79de1d987275c6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_39de1eccef65c50e3c79de1d987275c6 ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 798;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 798;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 798;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_39de1eccef65c50e3c79de1d987275c6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_39de1eccef65c50e3c79de1d987275c6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_39de1eccef65c50e3c79de1d987275c6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_39de1eccef65c50e3c79de1d987275c6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_39de1eccef65c50e3c79de1d987275c6, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_39de1eccef65c50e3c79de1d987275c6, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_39de1eccef65c50e3c79de1d987275c6 == cache_frame_39de1eccef65c50e3c79de1d987275c6 )
    {
        Py_DECREF( frame_39de1eccef65c50e3c79de1d987275c6 );
    }
    cache_frame_39de1eccef65c50e3c79de1d987275c6 = NULL;

    assertFrameObject( frame_39de1eccef65c50e3c79de1d987275c6 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_47_p_type_qualifier );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_47_p_type_qualifier );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_48_p_init_declarator_list( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_list_element_1;
    PyObject *tmp_list_element_2;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    static struct Nuitka_FrameObject *cache_frame_c4664c50857c8a99411c8f15a81eca07 = NULL;

    struct Nuitka_FrameObject *frame_c4664c50857c8a99411c8f15a81eca07;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c4664c50857c8a99411c8f15a81eca07, codeobj_c4664c50857c8a99411c8f15a81eca07, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_c4664c50857c8a99411c8f15a81eca07 = cache_frame_c4664c50857c8a99411c8f15a81eca07;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c4664c50857c8a99411c8f15a81eca07 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c4664c50857c8a99411c8f15a81eca07 ) == 2 ); // Frame stack

    // Framed code:
    tmp_len_arg_1 = par_p;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 804;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_pos_4;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 804;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto condexpr_true_1;
    }
    else
    {
        goto condexpr_false_1;
    }
    condexpr_true_1:;
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 804;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_left_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_left_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 804;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_1 = PyList_New( 1 );
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_left_name_1 );
        Py_DECREF( tmp_right_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 804;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_3;
    tmp_list_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_list_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_1 );
        Py_DECREF( tmp_right_name_1 );

        exception_lineno = 804;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyList_SET_ITEM( tmp_right_name_1, 0, tmp_list_element_1 );
    tmp_ass_subvalue_1 = BINARY_OPERATION_ADD( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_left_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 804;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto condexpr_end_1;
    condexpr_false_1:;
    tmp_ass_subvalue_1 = PyList_New( 1 );
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 804;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_1;
    tmp_list_element_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_list_element_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_1 );

        exception_lineno = 804;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyList_SET_ITEM( tmp_ass_subvalue_1, 0, tmp_list_element_2 );
    condexpr_end_1:;
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 804;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 804;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c4664c50857c8a99411c8f15a81eca07 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c4664c50857c8a99411c8f15a81eca07 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c4664c50857c8a99411c8f15a81eca07, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c4664c50857c8a99411c8f15a81eca07->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c4664c50857c8a99411c8f15a81eca07, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_c4664c50857c8a99411c8f15a81eca07, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_c4664c50857c8a99411c8f15a81eca07 == cache_frame_c4664c50857c8a99411c8f15a81eca07 )
    {
        Py_DECREF( frame_c4664c50857c8a99411c8f15a81eca07 );
    }
    cache_frame_c4664c50857c8a99411c8f15a81eca07 = NULL;

    assertFrameObject( frame_c4664c50857c8a99411c8f15a81eca07 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_48_p_init_declarator_list );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_48_p_init_declarator_list );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_49_p_init_declarator( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    int tmp_cmp_Gt_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_len_arg_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    static struct Nuitka_FrameObject *cache_frame_97a3152e541b6ec6c995297d53d9b782 = NULL;

    struct Nuitka_FrameObject *frame_97a3152e541b6ec6c995297d53d9b782;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_97a3152e541b6ec6c995297d53d9b782, codeobj_97a3152e541b6ec6c995297d53d9b782, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_97a3152e541b6ec6c995297d53d9b782 = cache_frame_97a3152e541b6ec6c995297d53d9b782;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_97a3152e541b6ec6c995297d53d9b782 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_97a3152e541b6ec6c995297d53d9b782 ) == 2 ); // Frame stack

    // Framed code:
    tmp_ass_subvalue_1 = _PyDict_NewPresized( 2 );
    tmp_dict_key_1 = const_str_plain_decl;
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_dict_value_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_dict_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_1 );

        exception_lineno = 813;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_ass_subvalue_1, tmp_dict_key_1, tmp_dict_value_1 );
    Py_DECREF( tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_init;
    tmp_len_arg_1 = par_p;

    if ( tmp_len_arg_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 813;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_1 );

        exception_lineno = 813;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_pos_2;
    tmp_cmp_Gt_1 = RICH_COMPARE_BOOL_GT( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Gt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_1 );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 813;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Gt_1 == 1 )
    {
        goto condexpr_true_1;
    }
    else
    {
        goto condexpr_false_1;
    }
    condexpr_true_1:;
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 813;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_3;
    tmp_dict_value_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_dict_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_1 );

        exception_lineno = 813;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto condexpr_end_1;
    condexpr_false_1:;
    tmp_dict_value_2 = Py_None;
    Py_INCREF( tmp_dict_value_2 );
    condexpr_end_1:;
    tmp_res = PyDict_SetItem( tmp_ass_subvalue_1, tmp_dict_key_2, tmp_dict_value_2 );
    Py_DECREF( tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 813;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 813;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_97a3152e541b6ec6c995297d53d9b782 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_97a3152e541b6ec6c995297d53d9b782 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_97a3152e541b6ec6c995297d53d9b782, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_97a3152e541b6ec6c995297d53d9b782->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_97a3152e541b6ec6c995297d53d9b782, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_97a3152e541b6ec6c995297d53d9b782, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_97a3152e541b6ec6c995297d53d9b782 == cache_frame_97a3152e541b6ec6c995297d53d9b782 )
    {
        Py_DECREF( frame_97a3152e541b6ec6c995297d53d9b782 );
    }
    cache_frame_97a3152e541b6ec6c995297d53d9b782 = NULL;

    assertFrameObject( frame_97a3152e541b6ec6c995297d53d9b782 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_49_p_init_declarator );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_49_p_init_declarator );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_50_p_id_init_declarator_list( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_list_element_1;
    PyObject *tmp_list_element_2;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    static struct Nuitka_FrameObject *cache_frame_46874747c73603425f19b82b48f68a48 = NULL;

    struct Nuitka_FrameObject *frame_46874747c73603425f19b82b48f68a48;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_46874747c73603425f19b82b48f68a48, codeobj_46874747c73603425f19b82b48f68a48, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_46874747c73603425f19b82b48f68a48 = cache_frame_46874747c73603425f19b82b48f68a48;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_46874747c73603425f19b82b48f68a48 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_46874747c73603425f19b82b48f68a48 ) == 2 ); // Frame stack

    // Framed code:
    tmp_len_arg_1 = par_p;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 819;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_pos_4;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 819;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto condexpr_true_1;
    }
    else
    {
        goto condexpr_false_1;
    }
    condexpr_true_1:;
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 819;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_left_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_left_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 819;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_1 = PyList_New( 1 );
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_left_name_1 );
        Py_DECREF( tmp_right_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 819;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_3;
    tmp_list_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_list_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_1 );
        Py_DECREF( tmp_right_name_1 );

        exception_lineno = 819;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyList_SET_ITEM( tmp_right_name_1, 0, tmp_list_element_1 );
    tmp_ass_subvalue_1 = BINARY_OPERATION_ADD( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_left_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 819;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto condexpr_end_1;
    condexpr_false_1:;
    tmp_ass_subvalue_1 = PyList_New( 1 );
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 819;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_1;
    tmp_list_element_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_list_element_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_1 );

        exception_lineno = 819;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyList_SET_ITEM( tmp_ass_subvalue_1, 0, tmp_list_element_2 );
    condexpr_end_1:;
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 819;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 819;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_46874747c73603425f19b82b48f68a48 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_46874747c73603425f19b82b48f68a48 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_46874747c73603425f19b82b48f68a48, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_46874747c73603425f19b82b48f68a48->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_46874747c73603425f19b82b48f68a48, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_46874747c73603425f19b82b48f68a48, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_46874747c73603425f19b82b48f68a48 == cache_frame_46874747c73603425f19b82b48f68a48 )
    {
        Py_DECREF( frame_46874747c73603425f19b82b48f68a48 );
    }
    cache_frame_46874747c73603425f19b82b48f68a48 = NULL;

    assertFrameObject( frame_46874747c73603425f19b82b48f68a48 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_50_p_id_init_declarator_list );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_50_p_id_init_declarator_list );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_51_p_id_init_declarator( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    int tmp_cmp_Gt_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_len_arg_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    static struct Nuitka_FrameObject *cache_frame_aa0f5872a2f8e0828a2d10c20a4ef844 = NULL;

    struct Nuitka_FrameObject *frame_aa0f5872a2f8e0828a2d10c20a4ef844;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_aa0f5872a2f8e0828a2d10c20a4ef844, codeobj_aa0f5872a2f8e0828a2d10c20a4ef844, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_aa0f5872a2f8e0828a2d10c20a4ef844 = cache_frame_aa0f5872a2f8e0828a2d10c20a4ef844;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_aa0f5872a2f8e0828a2d10c20a4ef844 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_aa0f5872a2f8e0828a2d10c20a4ef844 ) == 2 ); // Frame stack

    // Framed code:
    tmp_ass_subvalue_1 = _PyDict_NewPresized( 2 );
    tmp_dict_key_1 = const_str_plain_decl;
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_dict_value_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_dict_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_1 );

        exception_lineno = 825;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_ass_subvalue_1, tmp_dict_key_1, tmp_dict_value_1 );
    Py_DECREF( tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_init;
    tmp_len_arg_1 = par_p;

    if ( tmp_len_arg_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 825;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_1 );

        exception_lineno = 825;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_pos_2;
    tmp_cmp_Gt_1 = RICH_COMPARE_BOOL_GT( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Gt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_1 );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 825;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Gt_1 == 1 )
    {
        goto condexpr_true_1;
    }
    else
    {
        goto condexpr_false_1;
    }
    condexpr_true_1:;
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 825;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_3;
    tmp_dict_value_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_dict_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_1 );

        exception_lineno = 825;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto condexpr_end_1;
    condexpr_false_1:;
    tmp_dict_value_2 = Py_None;
    Py_INCREF( tmp_dict_value_2 );
    condexpr_end_1:;
    tmp_res = PyDict_SetItem( tmp_ass_subvalue_1, tmp_dict_key_2, tmp_dict_value_2 );
    Py_DECREF( tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 825;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 825;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_aa0f5872a2f8e0828a2d10c20a4ef844 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_aa0f5872a2f8e0828a2d10c20a4ef844 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_aa0f5872a2f8e0828a2d10c20a4ef844, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_aa0f5872a2f8e0828a2d10c20a4ef844->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_aa0f5872a2f8e0828a2d10c20a4ef844, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_aa0f5872a2f8e0828a2d10c20a4ef844, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_aa0f5872a2f8e0828a2d10c20a4ef844 == cache_frame_aa0f5872a2f8e0828a2d10c20a4ef844 )
    {
        Py_DECREF( frame_aa0f5872a2f8e0828a2d10c20a4ef844 );
    }
    cache_frame_aa0f5872a2f8e0828a2d10c20a4ef844 = NULL;

    assertFrameObject( frame_aa0f5872a2f8e0828a2d10c20a4ef844 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_51_p_id_init_declarator );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_51_p_id_init_declarator );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_52_p_specifier_qualifier_list_1( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_name_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_418db9cacfcd09e3118e18f6d0a2849f = NULL;

    struct Nuitka_FrameObject *frame_418db9cacfcd09e3118e18f6d0a2849f;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_418db9cacfcd09e3118e18f6d0a2849f, codeobj_418db9cacfcd09e3118e18f6d0a2849f, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_418db9cacfcd09e3118e18f6d0a2849f = cache_frame_418db9cacfcd09e3118e18f6d0a2849f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_418db9cacfcd09e3118e18f6d0a2849f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_418db9cacfcd09e3118e18f6d0a2849f ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__add_declaration_specifier );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 832;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_name_1 = PyTuple_New( 3 );
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 832;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_tuple_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );

        exception_lineno = 832;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 832;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_2;
    tmp_tuple_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );

        exception_lineno = 832;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_args_name_1, 1, tmp_tuple_element_1 );
    tmp_tuple_element_1 = const_str_plain_type;
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 2, tmp_tuple_element_1 );
    tmp_kw_name_1 = PyDict_Copy( const_dict_9d1be102e274ebd5d21e13e40f132db0 );
    frame_418db9cacfcd09e3118e18f6d0a2849f->m_frame.f_lineno = 832;
    tmp_ass_subvalue_1 = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 832;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 832;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 832;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_418db9cacfcd09e3118e18f6d0a2849f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_418db9cacfcd09e3118e18f6d0a2849f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_418db9cacfcd09e3118e18f6d0a2849f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_418db9cacfcd09e3118e18f6d0a2849f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_418db9cacfcd09e3118e18f6d0a2849f, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_418db9cacfcd09e3118e18f6d0a2849f, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_418db9cacfcd09e3118e18f6d0a2849f == cache_frame_418db9cacfcd09e3118e18f6d0a2849f )
    {
        Py_DECREF( frame_418db9cacfcd09e3118e18f6d0a2849f );
    }
    cache_frame_418db9cacfcd09e3118e18f6d0a2849f = NULL;

    assertFrameObject( frame_418db9cacfcd09e3118e18f6d0a2849f );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_52_p_specifier_qualifier_list_1 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_52_p_specifier_qualifier_list_1 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_53_p_specifier_qualifier_list_2( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_name_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_6ecdf682fba70e48f758afad9ba925c9 = NULL;

    struct Nuitka_FrameObject *frame_6ecdf682fba70e48f758afad9ba925c9;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6ecdf682fba70e48f758afad9ba925c9, codeobj_6ecdf682fba70e48f758afad9ba925c9, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_6ecdf682fba70e48f758afad9ba925c9 = cache_frame_6ecdf682fba70e48f758afad9ba925c9;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6ecdf682fba70e48f758afad9ba925c9 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6ecdf682fba70e48f758afad9ba925c9 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__add_declaration_specifier );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 837;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_name_1 = PyTuple_New( 3 );
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 837;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_tuple_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );

        exception_lineno = 837;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 837;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_2;
    tmp_tuple_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );

        exception_lineno = 837;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_args_name_1, 1, tmp_tuple_element_1 );
    tmp_tuple_element_1 = const_str_plain_qual;
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 2, tmp_tuple_element_1 );
    tmp_kw_name_1 = PyDict_Copy( const_dict_9d1be102e274ebd5d21e13e40f132db0 );
    frame_6ecdf682fba70e48f758afad9ba925c9->m_frame.f_lineno = 837;
    tmp_ass_subvalue_1 = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 837;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 837;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 837;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6ecdf682fba70e48f758afad9ba925c9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6ecdf682fba70e48f758afad9ba925c9 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6ecdf682fba70e48f758afad9ba925c9, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6ecdf682fba70e48f758afad9ba925c9->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6ecdf682fba70e48f758afad9ba925c9, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_6ecdf682fba70e48f758afad9ba925c9, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_6ecdf682fba70e48f758afad9ba925c9 == cache_frame_6ecdf682fba70e48f758afad9ba925c9 )
    {
        Py_DECREF( frame_6ecdf682fba70e48f758afad9ba925c9 );
    }
    cache_frame_6ecdf682fba70e48f758afad9ba925c9 = NULL;

    assertFrameObject( frame_6ecdf682fba70e48f758afad9ba925c9 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_53_p_specifier_qualifier_list_2 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_53_p_specifier_qualifier_list_2 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_54_p_specifier_qualifier_list_3( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_1da590064ef77831c71eb320c8e29b4f = NULL;

    struct Nuitka_FrameObject *frame_1da590064ef77831c71eb320c8e29b4f;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1da590064ef77831c71eb320c8e29b4f, codeobj_1da590064ef77831c71eb320c8e29b4f, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_1da590064ef77831c71eb320c8e29b4f = cache_frame_1da590064ef77831c71eb320c8e29b4f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1da590064ef77831c71eb320c8e29b4f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1da590064ef77831c71eb320c8e29b4f ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__add_declaration_specifier );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 842;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = Py_None;
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 842;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 842;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = const_str_plain_type;
    frame_1da590064ef77831c71eb320c8e29b4f->m_frame.f_lineno = 842;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 842;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 842;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 842;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1da590064ef77831c71eb320c8e29b4f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1da590064ef77831c71eb320c8e29b4f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1da590064ef77831c71eb320c8e29b4f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1da590064ef77831c71eb320c8e29b4f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1da590064ef77831c71eb320c8e29b4f, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_1da590064ef77831c71eb320c8e29b4f, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_1da590064ef77831c71eb320c8e29b4f == cache_frame_1da590064ef77831c71eb320c8e29b4f )
    {
        Py_DECREF( frame_1da590064ef77831c71eb320c8e29b4f );
    }
    cache_frame_1da590064ef77831c71eb320c8e29b4f = NULL;

    assertFrameObject( frame_1da590064ef77831c71eb320c8e29b4f );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_54_p_specifier_qualifier_list_3 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_54_p_specifier_qualifier_list_3 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_55_p_specifier_qualifier_list_4( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *var_spec = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_name_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_key_4;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_dict_value_4;
    PyObject *tmp_kw_name_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_3c330c3797f362655fc43b272c3eb042 = NULL;

    struct Nuitka_FrameObject *frame_3c330c3797f362655fc43b272c3eb042;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3c330c3797f362655fc43b272c3eb042, codeobj_3c330c3797f362655fc43b272c3eb042, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_3c330c3797f362655fc43b272c3eb042 = cache_frame_3c330c3797f362655fc43b272c3eb042;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3c330c3797f362655fc43b272c3eb042 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3c330c3797f362655fc43b272c3eb042 ) == 2 ); // Frame stack

    // Framed code:
    tmp_assign_source_1 = _PyDict_NewPresized( 4 );
    tmp_dict_key_1 = const_str_plain_qual;
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_dict_value_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_dict_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assign_source_1 );

        exception_lineno = 847;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_assign_source_1, tmp_dict_key_1, tmp_dict_value_1 );
    Py_DECREF( tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_storage;
    tmp_dict_value_2 = PyList_New( 0 );
    tmp_res = PyDict_SetItem( tmp_assign_source_1, tmp_dict_key_2, tmp_dict_value_2 );
    Py_DECREF( tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_3 = const_str_plain_type;
    tmp_dict_value_3 = PyList_New( 0 );
    tmp_res = PyDict_SetItem( tmp_assign_source_1, tmp_dict_key_3, tmp_dict_value_3 );
    Py_DECREF( tmp_dict_value_3 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_4 = const_str_plain_function;
    tmp_dict_value_4 = PyList_New( 0 );
    tmp_res = PyDict_SetItem( tmp_assign_source_1, tmp_dict_key_4, tmp_dict_value_4 );
    Py_DECREF( tmp_dict_value_4 );
    assert( !(tmp_res != 0) );
    assert( var_spec == NULL );
    var_spec = tmp_assign_source_1;

    tmp_source_name_1 = par_self;

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 848;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__add_declaration_specifier );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 848;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_name_1 = PyTuple_New( 3 );
    tmp_tuple_element_1 = var_spec;

    if ( tmp_tuple_element_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 848;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 848;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_2;
    tmp_tuple_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );

        exception_lineno = 848;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_args_name_1, 1, tmp_tuple_element_1 );
    tmp_tuple_element_1 = const_str_plain_type;
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 2, tmp_tuple_element_1 );
    tmp_kw_name_1 = PyDict_Copy( const_dict_9d1be102e274ebd5d21e13e40f132db0 );
    frame_3c330c3797f362655fc43b272c3eb042->m_frame.f_lineno = 848;
    tmp_ass_subvalue_1 = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 848;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 848;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 848;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3c330c3797f362655fc43b272c3eb042 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3c330c3797f362655fc43b272c3eb042 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3c330c3797f362655fc43b272c3eb042, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3c330c3797f362655fc43b272c3eb042->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3c330c3797f362655fc43b272c3eb042, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_3c330c3797f362655fc43b272c3eb042, type_description ,par_self, par_p, var_spec );

    // Release cached frame.
    if ( frame_3c330c3797f362655fc43b272c3eb042 == cache_frame_3c330c3797f362655fc43b272c3eb042 )
    {
        Py_DECREF( frame_3c330c3797f362655fc43b272c3eb042 );
    }
    cache_frame_3c330c3797f362655fc43b272c3eb042 = NULL;

    assertFrameObject( frame_3c330c3797f362655fc43b272c3eb042 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_55_p_specifier_qualifier_list_4 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_spec );
    var_spec = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_spec );
    var_spec = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_55_p_specifier_qualifier_list_4 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_56_p_struct_or_union_specifier_1( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *var_klass = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_kw_name_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    static struct Nuitka_FrameObject *cache_frame_0ea1d0686563ee73ce9af74116275c5f = NULL;

    struct Nuitka_FrameObject *frame_0ea1d0686563ee73ce9af74116275c5f;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0ea1d0686563ee73ce9af74116275c5f, codeobj_0ea1d0686563ee73ce9af74116275c5f, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_0ea1d0686563ee73ce9af74116275c5f = cache_frame_0ea1d0686563ee73ce9af74116275c5f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0ea1d0686563ee73ce9af74116275c5f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0ea1d0686563ee73ce9af74116275c5f ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__select_struct_union_class );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 857;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 857;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 857;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    frame_0ea1d0686563ee73ce9af74116275c5f->m_frame.f_lineno = 857;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 857;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_klass == NULL );
    var_klass = tmp_assign_source_1;

    tmp_called_name_2 = var_klass;

    CHECK_OBJECT( tmp_called_name_2 );
    tmp_kw_name_1 = _PyDict_NewPresized( 3 );
    tmp_dict_key_1 = const_str_plain_name;
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 859;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_2;
    tmp_dict_value_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_dict_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 859;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    Py_DECREF( tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_decls;
    tmp_dict_value_2 = Py_None;
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_3 = const_str_plain_coord;
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 861;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 861;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_p;

    if ( tmp_args_element_name_2 == NULL )
    {
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 861;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = const_int_pos_2;
    frame_0ea1d0686563ee73ce9af74116275c5f->m_frame.f_lineno = 861;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_dict_value_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    if ( tmp_dict_value_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 861;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3 );
    Py_DECREF( tmp_dict_value_3 );
    assert( !(tmp_res != 0) );
    frame_0ea1d0686563ee73ce9af74116275c5f->m_frame.f_lineno = 858;
    tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_2, tmp_kw_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 858;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 858;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 858;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0ea1d0686563ee73ce9af74116275c5f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0ea1d0686563ee73ce9af74116275c5f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0ea1d0686563ee73ce9af74116275c5f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0ea1d0686563ee73ce9af74116275c5f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0ea1d0686563ee73ce9af74116275c5f, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_0ea1d0686563ee73ce9af74116275c5f, type_description ,par_self, par_p, var_klass );

    // Release cached frame.
    if ( frame_0ea1d0686563ee73ce9af74116275c5f == cache_frame_0ea1d0686563ee73ce9af74116275c5f )
    {
        Py_DECREF( frame_0ea1d0686563ee73ce9af74116275c5f );
    }
    cache_frame_0ea1d0686563ee73ce9af74116275c5f = NULL;

    assertFrameObject( frame_0ea1d0686563ee73ce9af74116275c5f );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_56_p_struct_or_union_specifier_1 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_klass );
    var_klass = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_klass );
    var_klass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_56_p_struct_or_union_specifier_1 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_57_p_struct_or_union_specifier_2( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *var_klass = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_kw_name_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    static struct Nuitka_FrameObject *cache_frame_129c1473716b75fca59a3bb1a8c29dc1 = NULL;

    struct Nuitka_FrameObject *frame_129c1473716b75fca59a3bb1a8c29dc1;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_129c1473716b75fca59a3bb1a8c29dc1, codeobj_129c1473716b75fca59a3bb1a8c29dc1, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_129c1473716b75fca59a3bb1a8c29dc1 = cache_frame_129c1473716b75fca59a3bb1a8c29dc1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_129c1473716b75fca59a3bb1a8c29dc1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_129c1473716b75fca59a3bb1a8c29dc1 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__select_struct_union_class );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 866;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 866;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 866;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    frame_129c1473716b75fca59a3bb1a8c29dc1->m_frame.f_lineno = 866;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 866;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_klass == NULL );
    var_klass = tmp_assign_source_1;

    tmp_called_name_2 = var_klass;

    CHECK_OBJECT( tmp_called_name_2 );
    tmp_kw_name_1 = _PyDict_NewPresized( 3 );
    tmp_dict_key_1 = const_str_plain_name;
    tmp_dict_value_1 = Py_None;
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_decls;
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 869;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_3;
    tmp_dict_value_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_dict_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 869;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    Py_DECREF( tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_3 = const_str_plain_coord;
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 870;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 870;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_p;

    if ( tmp_args_element_name_2 == NULL )
    {
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 870;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = const_int_pos_2;
    frame_129c1473716b75fca59a3bb1a8c29dc1->m_frame.f_lineno = 870;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_dict_value_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    if ( tmp_dict_value_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 870;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3 );
    Py_DECREF( tmp_dict_value_3 );
    assert( !(tmp_res != 0) );
    frame_129c1473716b75fca59a3bb1a8c29dc1->m_frame.f_lineno = 867;
    tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_2, tmp_kw_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 867;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 867;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 867;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_129c1473716b75fca59a3bb1a8c29dc1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_129c1473716b75fca59a3bb1a8c29dc1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_129c1473716b75fca59a3bb1a8c29dc1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_129c1473716b75fca59a3bb1a8c29dc1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_129c1473716b75fca59a3bb1a8c29dc1, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_129c1473716b75fca59a3bb1a8c29dc1, type_description ,par_self, par_p, var_klass );

    // Release cached frame.
    if ( frame_129c1473716b75fca59a3bb1a8c29dc1 == cache_frame_129c1473716b75fca59a3bb1a8c29dc1 )
    {
        Py_DECREF( frame_129c1473716b75fca59a3bb1a8c29dc1 );
    }
    cache_frame_129c1473716b75fca59a3bb1a8c29dc1 = NULL;

    assertFrameObject( frame_129c1473716b75fca59a3bb1a8c29dc1 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_57_p_struct_or_union_specifier_2 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_klass );
    var_klass = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_klass );
    var_klass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_57_p_struct_or_union_specifier_2 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_58_p_struct_or_union_specifier_3( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *var_klass = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_kw_name_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    static struct Nuitka_FrameObject *cache_frame_0fd5d9823eacda464fa5a1ee5cd90b6e = NULL;

    struct Nuitka_FrameObject *frame_0fd5d9823eacda464fa5a1ee5cd90b6e;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0fd5d9823eacda464fa5a1ee5cd90b6e, codeobj_0fd5d9823eacda464fa5a1ee5cd90b6e, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_0fd5d9823eacda464fa5a1ee5cd90b6e = cache_frame_0fd5d9823eacda464fa5a1ee5cd90b6e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0fd5d9823eacda464fa5a1ee5cd90b6e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0fd5d9823eacda464fa5a1ee5cd90b6e ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__select_struct_union_class );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 876;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 876;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 876;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    frame_0fd5d9823eacda464fa5a1ee5cd90b6e->m_frame.f_lineno = 876;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 876;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_klass == NULL );
    var_klass = tmp_assign_source_1;

    tmp_called_name_2 = var_klass;

    CHECK_OBJECT( tmp_called_name_2 );
    tmp_kw_name_1 = _PyDict_NewPresized( 3 );
    tmp_dict_key_1 = const_str_plain_name;
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 878;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_2;
    tmp_dict_value_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_dict_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 878;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    Py_DECREF( tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_decls;
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 879;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_4;
    tmp_dict_value_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_dict_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 879;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    Py_DECREF( tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_3 = const_str_plain_coord;
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 880;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 880;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_p;

    if ( tmp_args_element_name_2 == NULL )
    {
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 880;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = const_int_pos_2;
    frame_0fd5d9823eacda464fa5a1ee5cd90b6e->m_frame.f_lineno = 880;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_dict_value_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    if ( tmp_dict_value_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 880;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3 );
    Py_DECREF( tmp_dict_value_3 );
    assert( !(tmp_res != 0) );
    frame_0fd5d9823eacda464fa5a1ee5cd90b6e->m_frame.f_lineno = 877;
    tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_2, tmp_kw_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 877;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 877;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 877;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0fd5d9823eacda464fa5a1ee5cd90b6e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0fd5d9823eacda464fa5a1ee5cd90b6e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0fd5d9823eacda464fa5a1ee5cd90b6e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0fd5d9823eacda464fa5a1ee5cd90b6e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0fd5d9823eacda464fa5a1ee5cd90b6e, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_0fd5d9823eacda464fa5a1ee5cd90b6e, type_description ,par_self, par_p, var_klass );

    // Release cached frame.
    if ( frame_0fd5d9823eacda464fa5a1ee5cd90b6e == cache_frame_0fd5d9823eacda464fa5a1ee5cd90b6e )
    {
        Py_DECREF( frame_0fd5d9823eacda464fa5a1ee5cd90b6e );
    }
    cache_frame_0fd5d9823eacda464fa5a1ee5cd90b6e = NULL;

    assertFrameObject( frame_0fd5d9823eacda464fa5a1ee5cd90b6e );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_58_p_struct_or_union_specifier_3 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_klass );
    var_klass = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_klass );
    var_klass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_58_p_struct_or_union_specifier_3 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_59_p_struct_or_union( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_return_value;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_eaf2fded8c31a9dea63e42cdeb65689e = NULL;

    struct Nuitka_FrameObject *frame_eaf2fded8c31a9dea63e42cdeb65689e;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_eaf2fded8c31a9dea63e42cdeb65689e, codeobj_eaf2fded8c31a9dea63e42cdeb65689e, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_eaf2fded8c31a9dea63e42cdeb65689e = cache_frame_eaf2fded8c31a9dea63e42cdeb65689e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_eaf2fded8c31a9dea63e42cdeb65689e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_eaf2fded8c31a9dea63e42cdeb65689e ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 886;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 886;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 886;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_eaf2fded8c31a9dea63e42cdeb65689e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_eaf2fded8c31a9dea63e42cdeb65689e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_eaf2fded8c31a9dea63e42cdeb65689e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_eaf2fded8c31a9dea63e42cdeb65689e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_eaf2fded8c31a9dea63e42cdeb65689e, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_eaf2fded8c31a9dea63e42cdeb65689e, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_eaf2fded8c31a9dea63e42cdeb65689e == cache_frame_eaf2fded8c31a9dea63e42cdeb65689e )
    {
        Py_DECREF( frame_eaf2fded8c31a9dea63e42cdeb65689e );
    }
    cache_frame_eaf2fded8c31a9dea63e42cdeb65689e = NULL;

    assertFrameObject( frame_eaf2fded8c31a9dea63e42cdeb65689e );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_59_p_struct_or_union );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_59_p_struct_or_union );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_60_p_struct_declaration_list( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscribed_2;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subscript_2;
    int tmp_ass_subscript_res_1;
    int tmp_ass_subscript_res_2;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_ass_subvalue_2;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_len_arg_1;
    int tmp_or_left_truth_1;
    int tmp_or_left_truth_2;
    PyObject *tmp_or_left_value_1;
    PyObject *tmp_or_left_value_2;
    PyObject *tmp_or_right_value_1;
    PyObject *tmp_or_right_value_2;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    static struct Nuitka_FrameObject *cache_frame_d92a866aca5ee4bf46d4ac9e314cf35b = NULL;

    struct Nuitka_FrameObject *frame_d92a866aca5ee4bf46d4ac9e314cf35b;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d92a866aca5ee4bf46d4ac9e314cf35b, codeobj_d92a866aca5ee4bf46d4ac9e314cf35b, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_d92a866aca5ee4bf46d4ac9e314cf35b = cache_frame_d92a866aca5ee4bf46d4ac9e314cf35b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d92a866aca5ee4bf46d4ac9e314cf35b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d92a866aca5ee4bf46d4ac9e314cf35b ) == 2 ); // Frame stack

    // Framed code:
    tmp_len_arg_1 = par_p;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 894;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_pos_2;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 894;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 895;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_or_left_value_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_or_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 895;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
    if ( tmp_or_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_or_left_value_1 );

        exception_lineno = 895;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_or_left_truth_1 == 1 )
    {
        goto or_left_1;
    }
    else
    {
        goto or_right_1;
    }
    or_right_1:;
    Py_DECREF( tmp_or_left_value_1 );
    tmp_or_right_value_1 = PyList_New( 0 );
    tmp_ass_subvalue_1 = tmp_or_right_value_1;
    goto or_end_1;
    or_left_1:;
    tmp_ass_subvalue_1 = tmp_or_left_value_1;
    or_end_1:;
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 895;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 895;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto branch_end_1;
    branch_no_1:;
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 897;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_1;
    tmp_left_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_left_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 897;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_left_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 897;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_2;
    tmp_or_left_value_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_or_left_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_1 );

        exception_lineno = 897;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_or_left_truth_2 = CHECK_IF_TRUE( tmp_or_left_value_2 );
    if ( tmp_or_left_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_1 );
        Py_DECREF( tmp_or_left_value_2 );

        exception_lineno = 897;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_or_left_truth_2 == 1 )
    {
        goto or_left_2;
    }
    else
    {
        goto or_right_2;
    }
    or_right_2:;
    Py_DECREF( tmp_or_left_value_2 );
    tmp_or_right_value_2 = PyList_New( 0 );
    tmp_right_name_1 = tmp_or_right_value_2;
    goto or_end_2;
    or_left_2:;
    tmp_right_name_1 = tmp_or_left_value_2;
    or_end_2:;
    tmp_ass_subvalue_2 = BINARY_OPERATION_ADD( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_left_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_ass_subvalue_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 897;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_2 = par_p;

    if ( tmp_ass_subscribed_2 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 897;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_2 = const_int_0;
    tmp_ass_subscript_res_2 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_2, tmp_ass_subscript_2, 0, tmp_ass_subvalue_2 );
    Py_DECREF( tmp_ass_subvalue_2 );
    if ( tmp_ass_subscript_res_2 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 897;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d92a866aca5ee4bf46d4ac9e314cf35b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d92a866aca5ee4bf46d4ac9e314cf35b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d92a866aca5ee4bf46d4ac9e314cf35b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d92a866aca5ee4bf46d4ac9e314cf35b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d92a866aca5ee4bf46d4ac9e314cf35b, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_d92a866aca5ee4bf46d4ac9e314cf35b, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_d92a866aca5ee4bf46d4ac9e314cf35b == cache_frame_d92a866aca5ee4bf46d4ac9e314cf35b )
    {
        Py_DECREF( frame_d92a866aca5ee4bf46d4ac9e314cf35b );
    }
    cache_frame_d92a866aca5ee4bf46d4ac9e314cf35b = NULL;

    assertFrameObject( frame_d92a866aca5ee4bf46d4ac9e314cf35b );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_60_p_struct_declaration_list );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_60_p_struct_declaration_list );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_61_p_struct_declaration_1( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *var_spec = NULL;
    PyObject *var_decls = NULL;
    PyObject *var_node = NULL;
    PyObject *var_decl_type = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    int tmp_cmp_Eq_1;
    int tmp_cmp_In_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_key_4;
    PyObject *tmp_dict_key_5;
    PyObject *tmp_dict_key_6;
    PyObject *tmp_dict_key_7;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_dict_value_4;
    PyObject *tmp_dict_value_5;
    PyObject *tmp_dict_value_6;
    PyObject *tmp_dict_value_7;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    bool tmp_isnot_1;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_kw_name_2;
    PyObject *tmp_kw_name_3;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_list_element_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscribed_name_5;
    PyObject *tmp_subscribed_name_6;
    PyObject *tmp_subscribed_name_7;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    PyObject *tmp_subscript_name_5;
    PyObject *tmp_subscript_name_6;
    PyObject *tmp_subscript_name_7;
    static struct Nuitka_FrameObject *cache_frame_7f70ce3e02d3f2f4e1e4321d7d064669 = NULL;

    struct Nuitka_FrameObject *frame_7f70ce3e02d3f2f4e1e4321d7d064669;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7f70ce3e02d3f2f4e1e4321d7d064669, codeobj_7f70ce3e02d3f2f4e1e4321d7d064669, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_7f70ce3e02d3f2f4e1e4321d7d064669 = cache_frame_7f70ce3e02d3f2f4e1e4321d7d064669;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7f70ce3e02d3f2f4e1e4321d7d064669 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7f70ce3e02d3f2f4e1e4321d7d064669 ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_assign_source_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 902;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_spec == NULL );
    var_spec = tmp_assign_source_1;

    tmp_compare_left_1 = const_str_plain_typedef;
    tmp_subscribed_name_2 = var_spec;

    CHECK_OBJECT( tmp_subscribed_name_2 );
    tmp_subscript_name_2 = const_str_plain_storage;
    tmp_compare_right_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 903;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_In_1 = PySequence_Contains( tmp_compare_right_1, tmp_compare_left_1 );
    assert( !(tmp_cmp_In_1 == -1) );
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_In_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_raise_type_1 = PyExc_AssertionError;
    exception_type = tmp_raise_type_1;
    Py_INCREF( tmp_raise_type_1 );
    exception_lineno = 903;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "oooooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 905;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_2;
    tmp_compare_left_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_compare_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 905;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_2 = Py_None;
    tmp_isnot_1 = ( tmp_compare_left_2 != tmp_compare_right_2 );
    Py_DECREF( tmp_compare_left_2 );
    if ( tmp_isnot_1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_source_name_1 = par_self;

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 906;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__build_declarations );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 906;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_1 = _PyDict_NewPresized( 2 );
    tmp_dict_key_1 = const_str_plain_spec;
    tmp_dict_value_1 = var_spec;

    if ( tmp_dict_value_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 907;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_decls;
    tmp_subscribed_name_4 = par_p;

    if ( tmp_subscribed_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 908;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_4 = const_int_pos_2;
    tmp_dict_value_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_4 );
    if ( tmp_dict_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 908;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    Py_DECREF( tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    frame_7f70ce3e02d3f2f4e1e4321d7d064669->m_frame.f_lineno = 906;
    tmp_assign_source_2 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 906;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_decls == NULL );
    var_decls = tmp_assign_source_2;

    goto branch_end_2;
    branch_no_2:;
    tmp_subscribed_name_5 = var_spec;

    if ( tmp_subscribed_name_5 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 910;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_5 = const_str_plain_type;
    tmp_len_arg_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_5, tmp_subscript_name_5 );
    if ( tmp_len_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 910;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_3 = BUILTIN_LEN( tmp_len_arg_1 );
    Py_DECREF( tmp_len_arg_1 );
    if ( tmp_compare_left_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 910;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_3 = const_int_pos_1;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_3 );

        exception_lineno = 910;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_3 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_subscribed_name_7 = var_spec;

    if ( tmp_subscribed_name_7 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 916;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_6 = const_str_plain_type;
    tmp_subscribed_name_6 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_7, tmp_subscript_name_6 );
    if ( tmp_subscribed_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 916;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_7 = const_int_0;
    tmp_assign_source_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_6, tmp_subscript_name_7 );
    Py_DECREF( tmp_subscribed_name_6 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 916;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_node == NULL );
    var_node = tmp_assign_source_3;

    tmp_isinstance_inst_1 = var_node;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 917;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_isinstance_cls_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_Node );
    if ( tmp_isinstance_cls_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 917;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    Py_DECREF( tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 917;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_assign_source_4 = var_node;

    if ( tmp_assign_source_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "node" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 918;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    assert( var_decl_type == NULL );
    Py_INCREF( tmp_assign_source_4 );
    var_decl_type = tmp_assign_source_4;

    goto branch_end_4;
    branch_no_4:;
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 920;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_IdentifierType );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 920;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = var_node;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "node" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 920;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    frame_7f70ce3e02d3f2f4e1e4321d7d064669->m_frame.f_lineno = 920;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 920;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_decl_type;
        var_decl_type = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    branch_end_4:;
    tmp_source_name_4 = par_self;

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 922;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__build_declarations );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 922;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_2 = _PyDict_NewPresized( 2 );
    tmp_dict_key_3 = const_str_plain_spec;
    tmp_dict_value_3 = var_spec;

    if ( tmp_dict_value_3 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 923;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_3, tmp_dict_value_3 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_4 = const_str_plain_decls;
    tmp_dict_value_4 = PyList_New( 1 );
    tmp_list_element_1 = _PyDict_NewPresized( 1 );
    tmp_dict_key_5 = const_str_plain_decl;
    tmp_dict_value_5 = var_decl_type;

    if ( tmp_dict_value_5 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_kw_name_2 );
        Py_DECREF( tmp_dict_value_4 );
        Py_DECREF( tmp_list_element_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decl_type" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 924;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_list_element_1, tmp_dict_key_5, tmp_dict_value_5 );
    assert( !(tmp_res != 0) );
    PyList_SET_ITEM( tmp_dict_value_4, 0, tmp_list_element_1 );
    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_4, tmp_dict_value_4 );
    Py_DECREF( tmp_dict_value_4 );
    assert( !(tmp_res != 0) );
    frame_7f70ce3e02d3f2f4e1e4321d7d064669->m_frame.f_lineno = 922;
    tmp_assign_source_6 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_3, tmp_kw_name_2 );
    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_kw_name_2 );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 922;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_decls == NULL );
    var_decls = tmp_assign_source_6;

    goto branch_end_3;
    branch_no_3:;
    tmp_source_name_5 = par_self;

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 931;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__build_declarations );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 931;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_3 = _PyDict_NewPresized( 2 );
    tmp_dict_key_6 = const_str_plain_spec;
    tmp_dict_value_6 = var_spec;

    if ( tmp_dict_value_6 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_kw_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 932;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_3, tmp_dict_key_6, tmp_dict_value_6 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_7 = const_str_plain_decls;
    tmp_dict_value_7 = DEEP_COPY( const_list_dict_2c030ba937b9e185526e262591ee7db7_list );
    tmp_res = PyDict_SetItem( tmp_kw_name_3, tmp_dict_key_7, tmp_dict_value_7 );
    Py_DECREF( tmp_dict_value_7 );
    assert( !(tmp_res != 0) );
    frame_7f70ce3e02d3f2f4e1e4321d7d064669->m_frame.f_lineno = 931;
    tmp_assign_source_7 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_4, tmp_kw_name_3 );
    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_kw_name_3 );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 931;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_decls == NULL );
    var_decls = tmp_assign_source_7;

    branch_end_3:;
    branch_end_2:;
    tmp_ass_subvalue_1 = var_decls;

    if ( tmp_ass_subvalue_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decls" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 935;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 935;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 935;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7f70ce3e02d3f2f4e1e4321d7d064669 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7f70ce3e02d3f2f4e1e4321d7d064669 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7f70ce3e02d3f2f4e1e4321d7d064669, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7f70ce3e02d3f2f4e1e4321d7d064669->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7f70ce3e02d3f2f4e1e4321d7d064669, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_7f70ce3e02d3f2f4e1e4321d7d064669, type_description ,par_self, par_p, var_spec, var_decls, var_node, var_decl_type );

    // Release cached frame.
    if ( frame_7f70ce3e02d3f2f4e1e4321d7d064669 == cache_frame_7f70ce3e02d3f2f4e1e4321d7d064669 )
    {
        Py_DECREF( frame_7f70ce3e02d3f2f4e1e4321d7d064669 );
    }
    cache_frame_7f70ce3e02d3f2f4e1e4321d7d064669 = NULL;

    assertFrameObject( frame_7f70ce3e02d3f2f4e1e4321d7d064669 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_61_p_struct_declaration_1 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_spec );
    var_spec = NULL;

    Py_XDECREF( var_decls );
    var_decls = NULL;

    Py_XDECREF( var_node );
    var_node = NULL;

    Py_XDECREF( var_decl_type );
    var_decl_type = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_spec );
    var_spec = NULL;

    Py_XDECREF( var_decls );
    var_decls = NULL;

    Py_XDECREF( var_node );
    var_node = NULL;

    Py_XDECREF( var_decl_type );
    var_decl_type = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_61_p_struct_declaration_1 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_62_p_struct_declaration_2( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_753414c1c431ae4c5db9c6601df038b5 = NULL;

    struct Nuitka_FrameObject *frame_753414c1c431ae4c5db9c6601df038b5;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_753414c1c431ae4c5db9c6601df038b5, codeobj_753414c1c431ae4c5db9c6601df038b5, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_753414c1c431ae4c5db9c6601df038b5 = cache_frame_753414c1c431ae4c5db9c6601df038b5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_753414c1c431ae4c5db9c6601df038b5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_753414c1c431ae4c5db9c6601df038b5 ) == 2 ); // Frame stack

    // Framed code:
    tmp_ass_subvalue_1 = Py_None;
    tmp_ass_subscribed_1 = par_p;

    CHECK_OBJECT( tmp_ass_subscribed_1 );
    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 940;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_753414c1c431ae4c5db9c6601df038b5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_753414c1c431ae4c5db9c6601df038b5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_753414c1c431ae4c5db9c6601df038b5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_753414c1c431ae4c5db9c6601df038b5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_753414c1c431ae4c5db9c6601df038b5, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_753414c1c431ae4c5db9c6601df038b5, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_753414c1c431ae4c5db9c6601df038b5 == cache_frame_753414c1c431ae4c5db9c6601df038b5 )
    {
        Py_DECREF( frame_753414c1c431ae4c5db9c6601df038b5 );
    }
    cache_frame_753414c1c431ae4c5db9c6601df038b5 = NULL;

    assertFrameObject( frame_753414c1c431ae4c5db9c6601df038b5 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_62_p_struct_declaration_2 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_62_p_struct_declaration_2 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_63_p_struct_declarator_list( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_list_element_1;
    PyObject *tmp_list_element_2;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    static struct Nuitka_FrameObject *cache_frame_b0f344fd6a0c4d2abd6db14c8fef82ab = NULL;

    struct Nuitka_FrameObject *frame_b0f344fd6a0c4d2abd6db14c8fef82ab;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b0f344fd6a0c4d2abd6db14c8fef82ab, codeobj_b0f344fd6a0c4d2abd6db14c8fef82ab, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_b0f344fd6a0c4d2abd6db14c8fef82ab = cache_frame_b0f344fd6a0c4d2abd6db14c8fef82ab;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b0f344fd6a0c4d2abd6db14c8fef82ab );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b0f344fd6a0c4d2abd6db14c8fef82ab ) == 2 ); // Frame stack

    // Framed code:
    tmp_len_arg_1 = par_p;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 946;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_pos_4;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 946;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto condexpr_true_1;
    }
    else
    {
        goto condexpr_false_1;
    }
    condexpr_true_1:;
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 946;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_left_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_left_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 946;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_1 = PyList_New( 1 );
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_left_name_1 );
        Py_DECREF( tmp_right_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 946;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_3;
    tmp_list_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_list_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_1 );
        Py_DECREF( tmp_right_name_1 );

        exception_lineno = 946;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyList_SET_ITEM( tmp_right_name_1, 0, tmp_list_element_1 );
    tmp_ass_subvalue_1 = BINARY_OPERATION_ADD( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_left_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 946;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto condexpr_end_1;
    condexpr_false_1:;
    tmp_ass_subvalue_1 = PyList_New( 1 );
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 946;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_1;
    tmp_list_element_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_list_element_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_1 );

        exception_lineno = 946;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyList_SET_ITEM( tmp_ass_subvalue_1, 0, tmp_list_element_2 );
    condexpr_end_1:;
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 946;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 946;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b0f344fd6a0c4d2abd6db14c8fef82ab );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b0f344fd6a0c4d2abd6db14c8fef82ab );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b0f344fd6a0c4d2abd6db14c8fef82ab, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b0f344fd6a0c4d2abd6db14c8fef82ab->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b0f344fd6a0c4d2abd6db14c8fef82ab, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_b0f344fd6a0c4d2abd6db14c8fef82ab, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_b0f344fd6a0c4d2abd6db14c8fef82ab == cache_frame_b0f344fd6a0c4d2abd6db14c8fef82ab )
    {
        Py_DECREF( frame_b0f344fd6a0c4d2abd6db14c8fef82ab );
    }
    cache_frame_b0f344fd6a0c4d2abd6db14c8fef82ab = NULL;

    assertFrameObject( frame_b0f344fd6a0c4d2abd6db14c8fef82ab );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_63_p_struct_declarator_list );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_63_p_struct_declarator_list );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_64_p_struct_declarator_1( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_f6eb8c7ab6d5260fc9fa696b3c5597c9 = NULL;

    struct Nuitka_FrameObject *frame_f6eb8c7ab6d5260fc9fa696b3c5597c9;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f6eb8c7ab6d5260fc9fa696b3c5597c9, codeobj_f6eb8c7ab6d5260fc9fa696b3c5597c9, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_f6eb8c7ab6d5260fc9fa696b3c5597c9 = cache_frame_f6eb8c7ab6d5260fc9fa696b3c5597c9;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f6eb8c7ab6d5260fc9fa696b3c5597c9 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f6eb8c7ab6d5260fc9fa696b3c5597c9 ) == 2 ); // Frame stack

    // Framed code:
    tmp_ass_subvalue_1 = _PyDict_NewPresized( 2 );
    tmp_dict_key_1 = const_str_plain_decl;
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_dict_value_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_dict_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_1 );

        exception_lineno = 954;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_ass_subvalue_1, tmp_dict_key_1, tmp_dict_value_1 );
    Py_DECREF( tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_bitsize;
    tmp_dict_value_2 = Py_None;
    tmp_res = PyDict_SetItem( tmp_ass_subvalue_1, tmp_dict_key_2, tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 954;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 954;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f6eb8c7ab6d5260fc9fa696b3c5597c9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f6eb8c7ab6d5260fc9fa696b3c5597c9 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f6eb8c7ab6d5260fc9fa696b3c5597c9, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f6eb8c7ab6d5260fc9fa696b3c5597c9->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f6eb8c7ab6d5260fc9fa696b3c5597c9, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_f6eb8c7ab6d5260fc9fa696b3c5597c9, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_f6eb8c7ab6d5260fc9fa696b3c5597c9 == cache_frame_f6eb8c7ab6d5260fc9fa696b3c5597c9 )
    {
        Py_DECREF( frame_f6eb8c7ab6d5260fc9fa696b3c5597c9 );
    }
    cache_frame_f6eb8c7ab6d5260fc9fa696b3c5597c9 = NULL;

    assertFrameObject( frame_f6eb8c7ab6d5260fc9fa696b3c5597c9 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_64_p_struct_declarator_1 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_64_p_struct_declarator_1 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_65_p_struct_declarator_2( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscribed_2;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subscript_2;
    int tmp_ass_subscript_res_1;
    int tmp_ass_subscript_res_2;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_ass_subvalue_2;
    PyObject *tmp_called_instance_1;
    int tmp_cmp_Gt_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_key_4;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_dict_value_4;
    PyObject *tmp_len_arg_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    static struct Nuitka_FrameObject *cache_frame_3ce513362ae9f8a7a7ed0c2ec7b2acad = NULL;

    struct Nuitka_FrameObject *frame_3ce513362ae9f8a7a7ed0c2ec7b2acad;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3ce513362ae9f8a7a7ed0c2ec7b2acad, codeobj_3ce513362ae9f8a7a7ed0c2ec7b2acad, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_3ce513362ae9f8a7a7ed0c2ec7b2acad = cache_frame_3ce513362ae9f8a7a7ed0c2ec7b2acad;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3ce513362ae9f8a7a7ed0c2ec7b2acad );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3ce513362ae9f8a7a7ed0c2ec7b2acad ) == 2 ); // Frame stack

    // Framed code:
    tmp_len_arg_1 = par_p;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 960;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_pos_3;
    tmp_cmp_Gt_1 = RICH_COMPARE_BOOL_GT( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Gt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 960;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Gt_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_ass_subvalue_1 = _PyDict_NewPresized( 2 );
    tmp_dict_key_1 = const_str_plain_decl;
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 961;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_dict_value_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_dict_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_1 );

        exception_lineno = 961;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_ass_subvalue_1, tmp_dict_key_1, tmp_dict_value_1 );
    Py_DECREF( tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_bitsize;
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 961;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_3;
    tmp_dict_value_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_dict_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_1 );

        exception_lineno = 961;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_ass_subvalue_1, tmp_dict_key_2, tmp_dict_value_2 );
    Py_DECREF( tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 961;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 961;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto branch_end_1;
    branch_no_1:;
    tmp_ass_subvalue_2 = _PyDict_NewPresized( 2 );
    tmp_dict_key_3 = const_str_plain_decl;
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_called_instance_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 963;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    frame_3ce513362ae9f8a7a7ed0c2ec7b2acad->m_frame.f_lineno = 963;
    tmp_dict_value_3 = CALL_METHOD_WITH_ARGS3( tmp_called_instance_1, const_str_plain_TypeDecl, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

    if ( tmp_dict_value_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_2 );

        exception_lineno = 963;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_ass_subvalue_2, tmp_dict_key_3, tmp_dict_value_3 );
    Py_DECREF( tmp_dict_value_3 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_4 = const_str_plain_bitsize;
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 963;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_2;
    tmp_dict_value_4 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_dict_value_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_2 );

        exception_lineno = 963;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_ass_subvalue_2, tmp_dict_key_4, tmp_dict_value_4 );
    Py_DECREF( tmp_dict_value_4 );
    assert( !(tmp_res != 0) );
    tmp_ass_subscribed_2 = par_p;

    if ( tmp_ass_subscribed_2 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 963;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_2 = const_int_0;
    tmp_ass_subscript_res_2 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_2, tmp_ass_subscript_2, 0, tmp_ass_subvalue_2 );
    Py_DECREF( tmp_ass_subvalue_2 );
    if ( tmp_ass_subscript_res_2 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 963;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3ce513362ae9f8a7a7ed0c2ec7b2acad );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3ce513362ae9f8a7a7ed0c2ec7b2acad );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3ce513362ae9f8a7a7ed0c2ec7b2acad, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3ce513362ae9f8a7a7ed0c2ec7b2acad->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3ce513362ae9f8a7a7ed0c2ec7b2acad, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_3ce513362ae9f8a7a7ed0c2ec7b2acad, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_3ce513362ae9f8a7a7ed0c2ec7b2acad == cache_frame_3ce513362ae9f8a7a7ed0c2ec7b2acad )
    {
        Py_DECREF( frame_3ce513362ae9f8a7a7ed0c2ec7b2acad );
    }
    cache_frame_3ce513362ae9f8a7a7ed0c2ec7b2acad = NULL;

    assertFrameObject( frame_3ce513362ae9f8a7a7ed0c2ec7b2acad );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_65_p_struct_declarator_2 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_65_p_struct_declarator_2 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_66_p_enum_specifier_1( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_56043ddf00ef986baf64b5ab4532f55e = NULL;

    struct Nuitka_FrameObject *frame_56043ddf00ef986baf64b5ab4532f55e;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_56043ddf00ef986baf64b5ab4532f55e, codeobj_56043ddf00ef986baf64b5ab4532f55e, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_56043ddf00ef986baf64b5ab4532f55e = cache_frame_56043ddf00ef986baf64b5ab4532f55e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_56043ddf00ef986baf64b5ab4532f55e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_56043ddf00ef986baf64b5ab4532f55e ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 969;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_Enum );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 969;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 969;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_2;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 969;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = Py_None;
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 969;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 969;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = par_p;

    if ( tmp_args_element_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 969;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = const_int_pos_1;
    frame_56043ddf00ef986baf64b5ab4532f55e->m_frame.f_lineno = 969;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_args_element_name_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 969;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_56043ddf00ef986baf64b5ab4532f55e->m_frame.f_lineno = 969;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 969;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 969;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 969;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_56043ddf00ef986baf64b5ab4532f55e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_56043ddf00ef986baf64b5ab4532f55e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_56043ddf00ef986baf64b5ab4532f55e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_56043ddf00ef986baf64b5ab4532f55e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_56043ddf00ef986baf64b5ab4532f55e, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_56043ddf00ef986baf64b5ab4532f55e, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_56043ddf00ef986baf64b5ab4532f55e == cache_frame_56043ddf00ef986baf64b5ab4532f55e )
    {
        Py_DECREF( frame_56043ddf00ef986baf64b5ab4532f55e );
    }
    cache_frame_56043ddf00ef986baf64b5ab4532f55e = NULL;

    assertFrameObject( frame_56043ddf00ef986baf64b5ab4532f55e );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_66_p_enum_specifier_1 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_66_p_enum_specifier_1 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_67_p_enum_specifier_2( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_795eb7c6f2350e65bc50540431566e11 = NULL;

    struct Nuitka_FrameObject *frame_795eb7c6f2350e65bc50540431566e11;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_795eb7c6f2350e65bc50540431566e11, codeobj_795eb7c6f2350e65bc50540431566e11, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_795eb7c6f2350e65bc50540431566e11 = cache_frame_795eb7c6f2350e65bc50540431566e11;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_795eb7c6f2350e65bc50540431566e11 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_795eb7c6f2350e65bc50540431566e11 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 974;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_Enum );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 974;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = Py_None;
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 974;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_3;
    tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 974;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 974;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 974;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = par_p;

    if ( tmp_args_element_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 974;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = const_int_pos_1;
    frame_795eb7c6f2350e65bc50540431566e11->m_frame.f_lineno = 974;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_args_element_name_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 974;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_795eb7c6f2350e65bc50540431566e11->m_frame.f_lineno = 974;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 974;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 974;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 974;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_795eb7c6f2350e65bc50540431566e11 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_795eb7c6f2350e65bc50540431566e11 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_795eb7c6f2350e65bc50540431566e11, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_795eb7c6f2350e65bc50540431566e11->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_795eb7c6f2350e65bc50540431566e11, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_795eb7c6f2350e65bc50540431566e11, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_795eb7c6f2350e65bc50540431566e11 == cache_frame_795eb7c6f2350e65bc50540431566e11 )
    {
        Py_DECREF( frame_795eb7c6f2350e65bc50540431566e11 );
    }
    cache_frame_795eb7c6f2350e65bc50540431566e11 = NULL;

    assertFrameObject( frame_795eb7c6f2350e65bc50540431566e11 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_67_p_enum_specifier_2 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_67_p_enum_specifier_2 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_68_p_enum_specifier_3( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    static struct Nuitka_FrameObject *cache_frame_bdb3c9c7f520adbb0bb977e5f55bd902 = NULL;

    struct Nuitka_FrameObject *frame_bdb3c9c7f520adbb0bb977e5f55bd902;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_bdb3c9c7f520adbb0bb977e5f55bd902, codeobj_bdb3c9c7f520adbb0bb977e5f55bd902, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_bdb3c9c7f520adbb0bb977e5f55bd902 = cache_frame_bdb3c9c7f520adbb0bb977e5f55bd902;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_bdb3c9c7f520adbb0bb977e5f55bd902 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_bdb3c9c7f520adbb0bb977e5f55bd902 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 980;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_Enum );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 980;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 980;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_2;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 980;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 980;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_4;
    tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 980;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 980;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 980;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = par_p;

    if ( tmp_args_element_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 980;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = const_int_pos_1;
    frame_bdb3c9c7f520adbb0bb977e5f55bd902->m_frame.f_lineno = 980;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_args_element_name_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 980;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_bdb3c9c7f520adbb0bb977e5f55bd902->m_frame.f_lineno = 980;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 980;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 980;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 980;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bdb3c9c7f520adbb0bb977e5f55bd902 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_bdb3c9c7f520adbb0bb977e5f55bd902 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_bdb3c9c7f520adbb0bb977e5f55bd902, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_bdb3c9c7f520adbb0bb977e5f55bd902->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_bdb3c9c7f520adbb0bb977e5f55bd902, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_bdb3c9c7f520adbb0bb977e5f55bd902, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_bdb3c9c7f520adbb0bb977e5f55bd902 == cache_frame_bdb3c9c7f520adbb0bb977e5f55bd902 )
    {
        Py_DECREF( frame_bdb3c9c7f520adbb0bb977e5f55bd902 );
    }
    cache_frame_bdb3c9c7f520adbb0bb977e5f55bd902 = NULL;

    assertFrameObject( frame_bdb3c9c7f520adbb0bb977e5f55bd902 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_68_p_enum_specifier_3 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_68_p_enum_specifier_3 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_69_p_enumerator_list( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscribed_2;
    PyObject *tmp_ass_subscribed_3;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subscript_2;
    PyObject *tmp_ass_subscript_3;
    int tmp_ass_subscript_res_1;
    int tmp_ass_subscript_res_2;
    int tmp_ass_subscript_res_3;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_ass_subvalue_2;
    PyObject *tmp_ass_subvalue_3;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Eq_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_len_arg_2;
    PyObject *tmp_list_element_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscribed_name_5;
    PyObject *tmp_subscribed_name_6;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    PyObject *tmp_subscript_name_5;
    PyObject *tmp_subscript_name_6;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_f82d0149f91c7c324123f2efb235c3aa = NULL;

    struct Nuitka_FrameObject *frame_f82d0149f91c7c324123f2efb235c3aa;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f82d0149f91c7c324123f2efb235c3aa, codeobj_f82d0149f91c7c324123f2efb235c3aa, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_f82d0149f91c7c324123f2efb235c3aa = cache_frame_f82d0149f91c7c324123f2efb235c3aa;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f82d0149f91c7c324123f2efb235c3aa );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f82d0149f91c7c324123f2efb235c3aa ) == 2 ); // Frame stack

    // Framed code:
    tmp_len_arg_1 = par_p;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 987;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_pos_2;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 987;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 988;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_EnumeratorList );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 988;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = PyList_New( 1 );
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 988;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_list_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_list_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 988;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyList_SET_ITEM( tmp_args_element_name_1, 0, tmp_list_element_1 );
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 988;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_1;
    tmp_source_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_source_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 988;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_coord );
    Py_DECREF( tmp_source_name_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 988;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_f82d0149f91c7c324123f2efb235c3aa->m_frame.f_lineno = 988;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 988;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 988;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 988;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto branch_end_1;
    branch_no_1:;
    tmp_len_arg_2 = par_p;

    if ( tmp_len_arg_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 989;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_compare_left_2 = BUILTIN_LEN( tmp_len_arg_2 );
    if ( tmp_compare_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 989;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_2 = const_int_pos_3;
    tmp_cmp_Eq_2 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_2 );

        exception_lineno = 989;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_2 );
    if ( tmp_cmp_Eq_2 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 990;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_1;
    tmp_ass_subvalue_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_ass_subvalue_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 990;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_2 = par_p;

    if ( tmp_ass_subscribed_2 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 990;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_2 = const_int_0;
    tmp_ass_subscript_res_2 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_2, tmp_ass_subscript_2, 0, tmp_ass_subvalue_2 );
    Py_DECREF( tmp_ass_subvalue_2 );
    if ( tmp_ass_subscript_res_2 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 990;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto branch_end_2;
    branch_no_2:;
    tmp_subscribed_name_4 = par_p;

    if ( tmp_subscribed_name_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 992;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_4 = const_int_pos_1;
    tmp_source_name_4 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_4 );
    if ( tmp_source_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 992;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_enumerators );
    Py_DECREF( tmp_source_name_4 );
    if ( tmp_source_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 992;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_append );
    Py_DECREF( tmp_source_name_3 );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 992;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_5 = par_p;

    if ( tmp_subscribed_name_5 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 992;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_5 = const_int_pos_3;
    tmp_args_element_name_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_5, tmp_subscript_name_5 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 992;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_f82d0149f91c7c324123f2efb235c3aa->m_frame.f_lineno = 992;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 992;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_subscribed_name_6 = par_p;

    if ( tmp_subscribed_name_6 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 993;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_6 = const_int_pos_1;
    tmp_ass_subvalue_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_6, tmp_subscript_name_6 );
    if ( tmp_ass_subvalue_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 993;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_3 = par_p;

    if ( tmp_ass_subscribed_3 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 993;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_3 = const_int_0;
    tmp_ass_subscript_res_3 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_3, tmp_ass_subscript_3, 0, tmp_ass_subvalue_3 );
    Py_DECREF( tmp_ass_subvalue_3 );
    if ( tmp_ass_subscript_res_3 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 993;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    branch_end_2:;
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f82d0149f91c7c324123f2efb235c3aa );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f82d0149f91c7c324123f2efb235c3aa );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f82d0149f91c7c324123f2efb235c3aa, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f82d0149f91c7c324123f2efb235c3aa->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f82d0149f91c7c324123f2efb235c3aa, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_f82d0149f91c7c324123f2efb235c3aa, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_f82d0149f91c7c324123f2efb235c3aa == cache_frame_f82d0149f91c7c324123f2efb235c3aa )
    {
        Py_DECREF( frame_f82d0149f91c7c324123f2efb235c3aa );
    }
    cache_frame_f82d0149f91c7c324123f2efb235c3aa = NULL;

    assertFrameObject( frame_f82d0149f91c7c324123f2efb235c3aa );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_69_p_enumerator_list );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_69_p_enumerator_list );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_70_p_enumerator( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *var_enumerator = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_fc36fad08403ba995c218b757a509878 = NULL;

    struct Nuitka_FrameObject *frame_fc36fad08403ba995c218b757a509878;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_fc36fad08403ba995c218b757a509878, codeobj_fc36fad08403ba995c218b757a509878, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_fc36fad08403ba995c218b757a509878 = cache_frame_fc36fad08403ba995c218b757a509878;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_fc36fad08403ba995c218b757a509878 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_fc36fad08403ba995c218b757a509878 ) == 2 ); // Frame stack

    // Framed code:
    tmp_len_arg_1 = par_p;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 999;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_pos_2;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 999;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1000;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_Enumerator );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1000;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1001;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1001;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = Py_None;
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1002;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1002;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = par_p;

    if ( tmp_args_element_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1002;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = const_int_pos_1;
    frame_fc36fad08403ba995c218b757a509878->m_frame.f_lineno = 1002;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_args_element_name_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1002;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    frame_fc36fad08403ba995c218b757a509878->m_frame.f_lineno = 1000;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1000;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_enumerator == NULL );
    var_enumerator = tmp_assign_source_1;

    goto branch_end_1;
    branch_no_1:;
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1004;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_Enumerator );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1004;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1005;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_1;
    tmp_args_element_name_6 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1005;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_6 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1005;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_3;
    tmp_args_element_name_7 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_6 );

        exception_lineno = 1005;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = par_self;

    if ( tmp_source_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_6 );
        Py_DECREF( tmp_args_element_name_7 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1006;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__token_coord );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_6 );
        Py_DECREF( tmp_args_element_name_7 );

        exception_lineno = 1006;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_9 = par_p;

    if ( tmp_args_element_name_9 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_6 );
        Py_DECREF( tmp_args_element_name_7 );
        Py_DECREF( tmp_called_name_4 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1006;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_10 = const_int_pos_1;
    frame_fc36fad08403ba995c218b757a509878->m_frame.f_lineno = 1006;
    {
        PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10 };
        tmp_args_element_name_8 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    if ( tmp_args_element_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_6 );
        Py_DECREF( tmp_args_element_name_7 );

        exception_lineno = 1006;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    frame_fc36fad08403ba995c218b757a509878->m_frame.f_lineno = 1004;
    {
        PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_6 );
    Py_DECREF( tmp_args_element_name_7 );
    Py_DECREF( tmp_args_element_name_8 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1004;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_enumerator == NULL );
    var_enumerator = tmp_assign_source_2;

    branch_end_1:;
    tmp_source_name_5 = par_self;

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1007;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__add_identifier );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1007;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_6 = var_enumerator;

    if ( tmp_source_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_5 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "enumerator" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1007;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_name );
    if ( tmp_args_element_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 1007;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_7 = var_enumerator;

    if ( tmp_source_name_7 == NULL )
    {
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_args_element_name_11 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "enumerator" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1007;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_12 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_coord );
    if ( tmp_args_element_name_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_args_element_name_11 );

        exception_lineno = 1007;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    frame_fc36fad08403ba995c218b757a509878->m_frame.f_lineno = 1007;
    {
        PyObject *call_args[] = { tmp_args_element_name_11, tmp_args_element_name_12 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    Py_DECREF( tmp_args_element_name_11 );
    Py_DECREF( tmp_args_element_name_12 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1007;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_ass_subvalue_1 = var_enumerator;

    if ( tmp_ass_subvalue_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "enumerator" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1009;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1009;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1009;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fc36fad08403ba995c218b757a509878 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_fc36fad08403ba995c218b757a509878 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_fc36fad08403ba995c218b757a509878, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_fc36fad08403ba995c218b757a509878->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_fc36fad08403ba995c218b757a509878, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_fc36fad08403ba995c218b757a509878, type_description ,par_self, par_p, var_enumerator );

    // Release cached frame.
    if ( frame_fc36fad08403ba995c218b757a509878 == cache_frame_fc36fad08403ba995c218b757a509878 )
    {
        Py_DECREF( frame_fc36fad08403ba995c218b757a509878 );
    }
    cache_frame_fc36fad08403ba995c218b757a509878 = NULL;

    assertFrameObject( frame_fc36fad08403ba995c218b757a509878 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_70_p_enumerator );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_enumerator );
    var_enumerator = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_enumerator );
    var_enumerator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_70_p_enumerator );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_71_p_declarator( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_return_value;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_337331efd9e8b98ec904248b5729d4b7 = NULL;

    struct Nuitka_FrameObject *frame_337331efd9e8b98ec904248b5729d4b7;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_337331efd9e8b98ec904248b5729d4b7, codeobj_337331efd9e8b98ec904248b5729d4b7, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_337331efd9e8b98ec904248b5729d4b7 = cache_frame_337331efd9e8b98ec904248b5729d4b7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_337331efd9e8b98ec904248b5729d4b7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_337331efd9e8b98ec904248b5729d4b7 ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1015;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1015;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1015;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_337331efd9e8b98ec904248b5729d4b7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_337331efd9e8b98ec904248b5729d4b7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_337331efd9e8b98ec904248b5729d4b7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_337331efd9e8b98ec904248b5729d4b7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_337331efd9e8b98ec904248b5729d4b7, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_337331efd9e8b98ec904248b5729d4b7, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_337331efd9e8b98ec904248b5729d4b7 == cache_frame_337331efd9e8b98ec904248b5729d4b7 )
    {
        Py_DECREF( frame_337331efd9e8b98ec904248b5729d4b7 );
    }
    cache_frame_337331efd9e8b98ec904248b5729d4b7 = NULL;

    assertFrameObject( frame_337331efd9e8b98ec904248b5729d4b7 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_71_p_declarator );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_71_p_declarator );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_72_p_xxx_declarator_1( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_return_value;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_8b41c2cd19aa34d145a09e06a36a06d1 = NULL;

    struct Nuitka_FrameObject *frame_8b41c2cd19aa34d145a09e06a36a06d1;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8b41c2cd19aa34d145a09e06a36a06d1, codeobj_8b41c2cd19aa34d145a09e06a36a06d1, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_8b41c2cd19aa34d145a09e06a36a06d1 = cache_frame_8b41c2cd19aa34d145a09e06a36a06d1;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8b41c2cd19aa34d145a09e06a36a06d1 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8b41c2cd19aa34d145a09e06a36a06d1 ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1021;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1021;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1021;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8b41c2cd19aa34d145a09e06a36a06d1 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8b41c2cd19aa34d145a09e06a36a06d1 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8b41c2cd19aa34d145a09e06a36a06d1, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8b41c2cd19aa34d145a09e06a36a06d1->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8b41c2cd19aa34d145a09e06a36a06d1, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_8b41c2cd19aa34d145a09e06a36a06d1, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_8b41c2cd19aa34d145a09e06a36a06d1 == cache_frame_8b41c2cd19aa34d145a09e06a36a06d1 )
    {
        Py_DECREF( frame_8b41c2cd19aa34d145a09e06a36a06d1 );
    }
    cache_frame_8b41c2cd19aa34d145a09e06a36a06d1 = NULL;

    assertFrameObject( frame_8b41c2cd19aa34d145a09e06a36a06d1 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_72_p_xxx_declarator_1 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_72_p_xxx_declarator_1 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_73_p_xxx_declarator_2( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    static struct Nuitka_FrameObject *cache_frame_98e40246e2cc3f8becdbf3e10cd918f2 = NULL;

    struct Nuitka_FrameObject *frame_98e40246e2cc3f8becdbf3e10cd918f2;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_98e40246e2cc3f8becdbf3e10cd918f2, codeobj_98e40246e2cc3f8becdbf3e10cd918f2, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_98e40246e2cc3f8becdbf3e10cd918f2 = cache_frame_98e40246e2cc3f8becdbf3e10cd918f2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_98e40246e2cc3f8becdbf3e10cd918f2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_98e40246e2cc3f8becdbf3e10cd918f2 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__type_modify_decl );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1027;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1027;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_2;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1027;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1027;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_1;
    tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1027;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_98e40246e2cc3f8becdbf3e10cd918f2->m_frame.f_lineno = 1027;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1027;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1027;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1027;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_98e40246e2cc3f8becdbf3e10cd918f2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_98e40246e2cc3f8becdbf3e10cd918f2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_98e40246e2cc3f8becdbf3e10cd918f2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_98e40246e2cc3f8becdbf3e10cd918f2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_98e40246e2cc3f8becdbf3e10cd918f2, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_98e40246e2cc3f8becdbf3e10cd918f2, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_98e40246e2cc3f8becdbf3e10cd918f2 == cache_frame_98e40246e2cc3f8becdbf3e10cd918f2 )
    {
        Py_DECREF( frame_98e40246e2cc3f8becdbf3e10cd918f2 );
    }
    cache_frame_98e40246e2cc3f8becdbf3e10cd918f2 = NULL;

    assertFrameObject( frame_98e40246e2cc3f8becdbf3e10cd918f2 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_73_p_xxx_declarator_2 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_73_p_xxx_declarator_2 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_74_p_direct_xxx_declarator_1( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_key_4;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_dict_value_4;
    PyObject *tmp_kw_name_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_10aeb59019f195c42eae9c75e055c5a0 = NULL;

    struct Nuitka_FrameObject *frame_10aeb59019f195c42eae9c75e055c5a0;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_10aeb59019f195c42eae9c75e055c5a0, codeobj_10aeb59019f195c42eae9c75e055c5a0, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_10aeb59019f195c42eae9c75e055c5a0 = cache_frame_10aeb59019f195c42eae9c75e055c5a0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_10aeb59019f195c42eae9c75e055c5a0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_10aeb59019f195c42eae9c75e055c5a0 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1033;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_TypeDecl );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1033;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_1 = _PyDict_NewPresized( 4 );
    tmp_dict_key_1 = const_str_plain_declname;
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1034;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_dict_value_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_dict_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1034;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    Py_DECREF( tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_type;
    tmp_dict_value_2 = Py_None;
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_3 = const_str_plain_quals;
    tmp_dict_value_3 = Py_None;
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_4 = const_str_plain_coord;
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1037;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1037;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_p;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1037;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = const_int_pos_1;
    frame_10aeb59019f195c42eae9c75e055c5a0->m_frame.f_lineno = 1037;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_dict_value_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_dict_value_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1037;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_4, tmp_dict_value_4 );
    Py_DECREF( tmp_dict_value_4 );
    assert( !(tmp_res != 0) );
    frame_10aeb59019f195c42eae9c75e055c5a0->m_frame.f_lineno = 1033;
    tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1033;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1033;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1033;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_10aeb59019f195c42eae9c75e055c5a0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_10aeb59019f195c42eae9c75e055c5a0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_10aeb59019f195c42eae9c75e055c5a0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_10aeb59019f195c42eae9c75e055c5a0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_10aeb59019f195c42eae9c75e055c5a0, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_10aeb59019f195c42eae9c75e055c5a0, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_10aeb59019f195c42eae9c75e055c5a0 == cache_frame_10aeb59019f195c42eae9c75e055c5a0 )
    {
        Py_DECREF( frame_10aeb59019f195c42eae9c75e055c5a0 );
    }
    cache_frame_10aeb59019f195c42eae9c75e055c5a0 = NULL;

    assertFrameObject( frame_10aeb59019f195c42eae9c75e055c5a0 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_74_p_direct_xxx_declarator_1 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_74_p_direct_xxx_declarator_1 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_75_p_direct_xxx_declarator_2( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_return_value;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_b6926e29a605bdf62681337c32c04bf6 = NULL;

    struct Nuitka_FrameObject *frame_b6926e29a605bdf62681337c32c04bf6;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b6926e29a605bdf62681337c32c04bf6, codeobj_b6926e29a605bdf62681337c32c04bf6, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_b6926e29a605bdf62681337c32c04bf6 = cache_frame_b6926e29a605bdf62681337c32c04bf6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b6926e29a605bdf62681337c32c04bf6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b6926e29a605bdf62681337c32c04bf6 ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_2;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1043;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1043;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1043;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b6926e29a605bdf62681337c32c04bf6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b6926e29a605bdf62681337c32c04bf6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b6926e29a605bdf62681337c32c04bf6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b6926e29a605bdf62681337c32c04bf6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b6926e29a605bdf62681337c32c04bf6, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_b6926e29a605bdf62681337c32c04bf6, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_b6926e29a605bdf62681337c32c04bf6 == cache_frame_b6926e29a605bdf62681337c32c04bf6 )
    {
        Py_DECREF( frame_b6926e29a605bdf62681337c32c04bf6 );
    }
    cache_frame_b6926e29a605bdf62681337c32c04bf6 = NULL;

    assertFrameObject( frame_b6926e29a605bdf62681337c32c04bf6 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_75_p_direct_xxx_declarator_2 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_75_p_direct_xxx_declarator_2 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_76_p_direct_xxx_declarator_3( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *var_quals = NULL;
    PyObject *var_arr = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cmp_Gt_1;
    int tmp_cmp_Gt_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_key_4;
    PyObject *tmp_dict_key_5;
    PyObject *tmp_dict_key_6;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_dict_value_4;
    PyObject *tmp_dict_value_5;
    PyObject *tmp_dict_value_6;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_kw_name_2;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_len_arg_2;
    int tmp_or_left_truth_1;
    PyObject *tmp_or_left_value_1;
    PyObject *tmp_or_right_value_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscribed_name_5;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    PyObject *tmp_subscript_name_5;
    static struct Nuitka_FrameObject *cache_frame_27d82a838ba49194322163c62da6de8b = NULL;

    struct Nuitka_FrameObject *frame_27d82a838ba49194322163c62da6de8b;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_27d82a838ba49194322163c62da6de8b, codeobj_27d82a838ba49194322163c62da6de8b, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_27d82a838ba49194322163c62da6de8b = cache_frame_27d82a838ba49194322163c62da6de8b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_27d82a838ba49194322163c62da6de8b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_27d82a838ba49194322163c62da6de8b ) == 2 ); // Frame stack

    // Framed code:
    tmp_len_arg_1 = par_p;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1049;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_pos_5;
    tmp_cmp_Gt_1 = RICH_COMPARE_BOOL_GT( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Gt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 1049;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Gt_1 == 1 )
    {
        goto condexpr_true_1;
    }
    else
    {
        goto condexpr_false_1;
    }
    condexpr_true_1:;
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1049;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_3;
    tmp_or_left_value_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_or_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1049;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    goto condexpr_end_1;
    condexpr_false_1:;
    tmp_or_left_value_1 = PyList_New( 0 );
    condexpr_end_1:;
    tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
    if ( tmp_or_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_or_left_value_1 );

        exception_lineno = 1049;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_or_left_truth_1 == 1 )
    {
        goto or_left_1;
    }
    else
    {
        goto or_right_1;
    }
    or_right_1:;
    Py_DECREF( tmp_or_left_value_1 );
    tmp_or_right_value_1 = PyList_New( 0 );
    tmp_assign_source_1 = tmp_or_right_value_1;
    goto or_end_1;
    or_left_1:;
    tmp_assign_source_1 = tmp_or_left_value_1;
    or_end_1:;
    assert( var_quals == NULL );
    var_quals = tmp_assign_source_1;

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1052;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_ArrayDecl );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1052;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_1 = _PyDict_NewPresized( 4 );
    tmp_dict_key_1 = const_str_plain_type;
    tmp_dict_value_1 = Py_None;
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_dim;
    tmp_len_arg_2 = par_p;

    if ( tmp_len_arg_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1054;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_left_2 = BUILTIN_LEN( tmp_len_arg_2 );
    if ( tmp_compare_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1054;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_2 = const_int_pos_5;
    tmp_cmp_Gt_2 = RICH_COMPARE_BOOL_GT( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Gt_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_compare_left_2 );

        exception_lineno = 1054;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_2 );
    if ( tmp_cmp_Gt_2 == 1 )
    {
        goto condexpr_true_2;
    }
    else
    {
        goto condexpr_false_2;
    }
    condexpr_true_2:;
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1054;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_4;
    tmp_dict_value_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_dict_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1054;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    goto condexpr_end_2;
    condexpr_false_2:;
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1054;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_3;
    tmp_dict_value_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_dict_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1054;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    condexpr_end_2:;
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    Py_DECREF( tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_3 = const_str_plain_dim_quals;
    tmp_dict_value_3 = var_quals;

    if ( tmp_dict_value_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "quals" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1055;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_4 = const_str_plain_coord;
    tmp_subscribed_name_4 = par_p;

    if ( tmp_subscribed_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1056;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_4 = const_int_pos_1;
    tmp_source_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_4 );
    if ( tmp_source_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1056;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_dict_value_4 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_coord );
    Py_DECREF( tmp_source_name_2 );
    if ( tmp_dict_value_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1056;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_4, tmp_dict_value_4 );
    Py_DECREF( tmp_dict_value_4 );
    assert( !(tmp_res != 0) );
    frame_27d82a838ba49194322163c62da6de8b->m_frame.f_lineno = 1052;
    tmp_assign_source_2 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1052;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_arr == NULL );
    var_arr = tmp_assign_source_2;

    tmp_source_name_3 = par_self;

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1058;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__type_modify_decl );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1058;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_2 = _PyDict_NewPresized( 2 );
    tmp_dict_key_5 = const_str_plain_decl;
    tmp_subscribed_name_5 = par_p;

    if ( tmp_subscribed_name_5 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1058;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_5 = const_int_pos_1;
    tmp_dict_value_5 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_5, tmp_subscript_name_5 );
    if ( tmp_dict_value_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_2 );

        exception_lineno = 1058;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_5, tmp_dict_value_5 );
    Py_DECREF( tmp_dict_value_5 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_6 = const_str_plain_modifier;
    tmp_dict_value_6 = var_arr;

    if ( tmp_dict_value_6 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "arr" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1058;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_6, tmp_dict_value_6 );
    assert( !(tmp_res != 0) );
    frame_27d82a838ba49194322163c62da6de8b->m_frame.f_lineno = 1058;
    tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_2, tmp_kw_name_2 );
    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_kw_name_2 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1058;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1058;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1058;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_27d82a838ba49194322163c62da6de8b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_27d82a838ba49194322163c62da6de8b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_27d82a838ba49194322163c62da6de8b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_27d82a838ba49194322163c62da6de8b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_27d82a838ba49194322163c62da6de8b, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_27d82a838ba49194322163c62da6de8b, type_description ,par_self, par_p, var_quals, var_arr );

    // Release cached frame.
    if ( frame_27d82a838ba49194322163c62da6de8b == cache_frame_27d82a838ba49194322163c62da6de8b )
    {
        Py_DECREF( frame_27d82a838ba49194322163c62da6de8b );
    }
    cache_frame_27d82a838ba49194322163c62da6de8b = NULL;

    assertFrameObject( frame_27d82a838ba49194322163c62da6de8b );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_76_p_direct_xxx_declarator_3 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_quals );
    var_quals = NULL;

    Py_XDECREF( var_arr );
    var_arr = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_quals );
    var_quals = NULL;

    Py_XDECREF( var_arr );
    var_arr = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_76_p_direct_xxx_declarator_3 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_77_p_direct_xxx_declarator_4( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *var_listed_quals = NULL;
    PyObject *var_dim_quals = NULL;
    PyObject *var_arr = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_key_4;
    PyObject *tmp_dict_key_5;
    PyObject *tmp_dict_key_6;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_dict_value_4;
    PyObject *tmp_dict_value_5;
    PyObject *tmp_dict_value_6;
    PyObject *tmp_dircall_arg1_1;
    PyObject *tmp_dircall_arg1_2;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_iter_arg_2;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_kw_name_2;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscribed_name_5;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    PyObject *tmp_subscript_name_5;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_b329363a2e1d615669c61b6bf24bd116 = NULL;

    struct Nuitka_FrameObject *frame_b329363a2e1d615669c61b6bf24bd116;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b329363a2e1d615669c61b6bf24bd116, codeobj_b329363a2e1d615669c61b6bf24bd116, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_b329363a2e1d615669c61b6bf24bd116 = cache_frame_b329363a2e1d615669c61b6bf24bd116;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b329363a2e1d615669c61b6bf24bd116 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b329363a2e1d615669c61b6bf24bd116 ) == 2 ); // Frame stack

    // Framed code:
    tmp_iter_arg_1 = PyTuple_New( 2 );
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_3;
    tmp_tuple_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_iter_arg_1 );

        exception_lineno = 1069;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_iter_arg_1, 0, tmp_tuple_element_1 );
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_iter_arg_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1069;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_4;
    tmp_tuple_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_iter_arg_1 );

        exception_lineno = 1069;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_iter_arg_1, 1, tmp_tuple_element_1 );
    tmp_dircall_arg1_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_dircall_arg1_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1068;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    {
        PyObject *dir_call_args[] = {tmp_dircall_arg1_1};
        tmp_assign_source_1 = impl_pycparser$c_parser$$$class_1_CParser$$$function_77_p_direct_xxx_declarator_4$$$function_1_listcontraction( dir_call_args );
    }
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1068;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_listed_quals == NULL );
    var_listed_quals = tmp_assign_source_1;

    tmp_iter_arg_2 = var_listed_quals;

    CHECK_OBJECT( tmp_iter_arg_2 );
    tmp_dircall_arg1_2 = MAKE_ITERATOR( tmp_iter_arg_2 );
    if ( tmp_dircall_arg1_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1070;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    {
        PyObject *dir_call_args[] = {tmp_dircall_arg1_2};
        tmp_assign_source_2 = impl_pycparser$c_parser$$$class_1_CParser$$$function_77_p_direct_xxx_declarator_4$$$function_2_listcontraction( dir_call_args );
    }
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1070;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_dim_quals == NULL );
    var_dim_quals = tmp_assign_source_2;

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1072;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_ArrayDecl );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1072;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_1 = _PyDict_NewPresized( 4 );
    tmp_dict_key_1 = const_str_plain_type;
    tmp_dict_value_1 = Py_None;
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_dim;
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1074;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_5;
    tmp_dict_value_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_dict_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1074;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    Py_DECREF( tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_3 = const_str_plain_dim_quals;
    tmp_dict_value_3 = var_dim_quals;

    if ( tmp_dict_value_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "dim_quals" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1075;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_4 = const_str_plain_coord;
    tmp_subscribed_name_4 = par_p;

    if ( tmp_subscribed_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1076;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_4 = const_int_pos_1;
    tmp_source_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_4 );
    if ( tmp_source_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1076;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_dict_value_4 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_coord );
    Py_DECREF( tmp_source_name_2 );
    if ( tmp_dict_value_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1076;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_4, tmp_dict_value_4 );
    Py_DECREF( tmp_dict_value_4 );
    assert( !(tmp_res != 0) );
    frame_b329363a2e1d615669c61b6bf24bd116->m_frame.f_lineno = 1072;
    tmp_assign_source_3 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1072;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_arr == NULL );
    var_arr = tmp_assign_source_3;

    tmp_source_name_3 = par_self;

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1078;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__type_modify_decl );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1078;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_2 = _PyDict_NewPresized( 2 );
    tmp_dict_key_5 = const_str_plain_decl;
    tmp_subscribed_name_5 = par_p;

    if ( tmp_subscribed_name_5 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1078;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_5 = const_int_pos_1;
    tmp_dict_value_5 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_5, tmp_subscript_name_5 );
    if ( tmp_dict_value_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_2 );

        exception_lineno = 1078;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_5, tmp_dict_value_5 );
    Py_DECREF( tmp_dict_value_5 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_6 = const_str_plain_modifier;
    tmp_dict_value_6 = var_arr;

    if ( tmp_dict_value_6 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "arr" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1078;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_6, tmp_dict_value_6 );
    assert( !(tmp_res != 0) );
    frame_b329363a2e1d615669c61b6bf24bd116->m_frame.f_lineno = 1078;
    tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_2, tmp_kw_name_2 );
    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_kw_name_2 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1078;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1078;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1078;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b329363a2e1d615669c61b6bf24bd116 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b329363a2e1d615669c61b6bf24bd116 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b329363a2e1d615669c61b6bf24bd116, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b329363a2e1d615669c61b6bf24bd116->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b329363a2e1d615669c61b6bf24bd116, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_b329363a2e1d615669c61b6bf24bd116, type_description ,par_self, par_p, var_listed_quals, var_dim_quals, var_arr );

    // Release cached frame.
    if ( frame_b329363a2e1d615669c61b6bf24bd116 == cache_frame_b329363a2e1d615669c61b6bf24bd116 )
    {
        Py_DECREF( frame_b329363a2e1d615669c61b6bf24bd116 );
    }
    cache_frame_b329363a2e1d615669c61b6bf24bd116 = NULL;

    assertFrameObject( frame_b329363a2e1d615669c61b6bf24bd116 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_77_p_direct_xxx_declarator_4 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_listed_quals );
    var_listed_quals = NULL;

    Py_XDECREF( var_dim_quals );
    var_dim_quals = NULL;

    Py_XDECREF( var_arr );
    var_arr = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_listed_quals );
    var_listed_quals = NULL;

    Py_XDECREF( var_dim_quals );
    var_dim_quals = NULL;

    Py_XDECREF( var_arr );
    var_arr = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_77_p_direct_xxx_declarator_4 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


NUITKA_LOCAL_MODULE PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_77_p_direct_xxx_declarator_4$$$function_1_listcontraction( PyObject **python_pars )
{
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
    assert(!had_error); // Do not enter inlined functions with error set.
#endif

    // Local variable declarations.
    PyObject *par_$0 = python_pars[ 0 ];
    PyObject *var_item = NULL;
    PyObject *tmp_contraction_result = NULL;
    PyObject *tmp_iter_value_0 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_append_list_1;
    PyObject *tmp_append_value_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_list_element_1;
    PyObject *tmp_next_source_1;
    int tmp_res;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_c4d7d483d924a5fff5f3a76668a73267 = NULL;

    struct Nuitka_FrameObject *frame_c4d7d483d924a5fff5f3a76668a73267;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_assign_source_1 = PyList_New( 0 );
    assert( tmp_contraction_result == NULL );
    tmp_contraction_result = tmp_assign_source_1;

    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c4d7d483d924a5fff5f3a76668a73267, codeobj_c4d7d483d924a5fff5f3a76668a73267, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_c4d7d483d924a5fff5f3a76668a73267 = cache_frame_c4d7d483d924a5fff5f3a76668a73267;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c4d7d483d924a5fff5f3a76668a73267 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c4d7d483d924a5fff5f3a76668a73267 ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    loop_start_1:;
    tmp_next_source_1 = par_$0;

    CHECK_OBJECT( tmp_next_source_1 );
    tmp_assign_source_2 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            type_description = "oo";
            exception_lineno = 1068;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_iter_value_0;
        tmp_iter_value_0 = tmp_assign_source_2;
        Py_XDECREF( old );
    }

    tmp_assign_source_3 = tmp_iter_value_0;

    CHECK_OBJECT( tmp_assign_source_3 );
    {
        PyObject *old = var_item;
        var_item = tmp_assign_source_3;
        Py_INCREF( var_item );
        Py_XDECREF( old );
    }

    tmp_append_list_1 = tmp_contraction_result;

    CHECK_OBJECT( tmp_append_list_1 );
    tmp_isinstance_inst_1 = var_item;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = (PyObject *)&PyList_Type;
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1068;
        type_description = "oo";
        goto try_except_handler_2;
    }
    if ( tmp_res == 1 )
    {
        goto condexpr_true_1;
    }
    else
    {
        goto condexpr_false_1;
    }
    condexpr_true_1:;
    tmp_append_value_1 = var_item;

    CHECK_OBJECT( tmp_append_value_1 );
    Py_INCREF( tmp_append_value_1 );
    goto condexpr_end_1;
    condexpr_false_1:;
    tmp_append_value_1 = PyList_New( 1 );
    tmp_list_element_1 = var_item;

    CHECK_OBJECT( tmp_list_element_1 );
    Py_INCREF( tmp_list_element_1 );
    PyList_SET_ITEM( tmp_append_value_1, 0, tmp_list_element_1 );
    condexpr_end_1:;
    assert( PyList_Check( tmp_append_list_1 ) );
    tmp_res = PyList_Append( tmp_append_list_1, tmp_append_value_1 );
    Py_DECREF( tmp_append_value_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1068;
        type_description = "oo";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1068;
        type_description = "oo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    tmp_return_value = tmp_contraction_result;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_2;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_77_p_direct_xxx_declarator_4$$$function_1_listcontraction );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    Py_XDECREF( tmp_contraction_result );
    tmp_contraction_result = NULL;

    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    goto frame_return_exit_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_contraction_result );
    tmp_contraction_result = NULL;

    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c4d7d483d924a5fff5f3a76668a73267 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_c4d7d483d924a5fff5f3a76668a73267 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c4d7d483d924a5fff5f3a76668a73267 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c4d7d483d924a5fff5f3a76668a73267, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c4d7d483d924a5fff5f3a76668a73267->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c4d7d483d924a5fff5f3a76668a73267, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_c4d7d483d924a5fff5f3a76668a73267, type_description ,par_$0, var_item );

    // Release cached frame.
    if ( frame_c4d7d483d924a5fff5f3a76668a73267 == cache_frame_c4d7d483d924a5fff5f3a76668a73267 )
    {
        Py_DECREF( frame_c4d7d483d924a5fff5f3a76668a73267 );
    }
    cache_frame_c4d7d483d924a5fff5f3a76668a73267 = NULL;

    assertFrameObject( frame_c4d7d483d924a5fff5f3a76668a73267 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_77_p_direct_xxx_declarator_4$$$function_1_listcontraction );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_$0 );
    par_$0 = NULL;

    Py_XDECREF( var_item );
    var_item = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_$0 );
    par_$0 = NULL;

    Py_XDECREF( var_item );
    var_item = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_77_p_direct_xxx_declarator_4$$$function_1_listcontraction );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


NUITKA_LOCAL_MODULE PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_77_p_direct_xxx_declarator_4$$$function_2_listcontraction( PyObject **python_pars )
{
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
    assert(!had_error); // Do not enter inlined functions with error set.
#endif

    // Local variable declarations.
    PyObject *par_$0 = python_pars[ 0 ];
    PyObject *var_sublist = NULL;
    PyObject *var_qual = NULL;
    PyObject *tmp_contraction_iter_0 = NULL;
    PyObject *tmp_contraction_result = NULL;
    PyObject *tmp_iter_value_0 = NULL;
    PyObject *tmp_iter_value_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_append_list_1;
    PyObject *tmp_append_value_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    bool tmp_isnot_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_next_source_1;
    PyObject *tmp_next_source_2;
    int tmp_res;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_4bc9e4c6643ef221ad4182ae532b0a87 = NULL;

    struct Nuitka_FrameObject *frame_4bc9e4c6643ef221ad4182ae532b0a87;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_assign_source_1 = PyList_New( 0 );
    assert( tmp_contraction_result == NULL );
    tmp_contraction_result = tmp_assign_source_1;

    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_4bc9e4c6643ef221ad4182ae532b0a87, codeobj_4bc9e4c6643ef221ad4182ae532b0a87, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_4bc9e4c6643ef221ad4182ae532b0a87 = cache_frame_4bc9e4c6643ef221ad4182ae532b0a87;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_4bc9e4c6643ef221ad4182ae532b0a87 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_4bc9e4c6643ef221ad4182ae532b0a87 ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    loop_start_1:;
    tmp_next_source_1 = par_$0;

    CHECK_OBJECT( tmp_next_source_1 );
    tmp_assign_source_2 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            type_description = "ooo";
            exception_lineno = 1070;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_iter_value_1;
        tmp_iter_value_1 = tmp_assign_source_2;
        Py_XDECREF( old );
    }

    tmp_assign_source_3 = tmp_iter_value_1;

    CHECK_OBJECT( tmp_assign_source_3 );
    {
        PyObject *old = var_sublist;
        var_sublist = tmp_assign_source_3;
        Py_INCREF( var_sublist );
        Py_XDECREF( old );
    }

    tmp_iter_arg_1 = var_sublist;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_4 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1070;
        type_description = "ooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = tmp_contraction_iter_0;
        tmp_contraction_iter_0 = tmp_assign_source_4;
        Py_XDECREF( old );
    }

    loop_start_2:;
    tmp_next_source_2 = tmp_contraction_iter_0;

    CHECK_OBJECT( tmp_next_source_2 );
    tmp_assign_source_5 = ITERATOR_NEXT( tmp_next_source_2 );
    if ( tmp_assign_source_5 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_2;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            type_description = "ooo";
            exception_lineno = 1070;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_iter_value_0;
        tmp_iter_value_0 = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    tmp_assign_source_6 = tmp_iter_value_0;

    CHECK_OBJECT( tmp_assign_source_6 );
    {
        PyObject *old = var_qual;
        var_qual = tmp_assign_source_6;
        Py_INCREF( var_qual );
        Py_XDECREF( old );
    }

    tmp_compare_left_1 = var_qual;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = Py_None;
    tmp_isnot_1 = ( tmp_compare_left_1 != tmp_compare_right_1 );
    if ( tmp_isnot_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_append_list_1 = tmp_contraction_result;

    CHECK_OBJECT( tmp_append_list_1 );
    tmp_append_value_1 = var_qual;

    if ( tmp_append_value_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "qual" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1070;
        type_description = "ooo";
        goto try_except_handler_2;
    }

    assert( PyList_Check( tmp_append_list_1 ) );
    tmp_res = PyList_Append( tmp_append_list_1, tmp_append_value_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1070;
        type_description = "ooo";
        goto try_except_handler_2;
    }
    branch_no_1:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1070;
        type_description = "ooo";
        goto try_except_handler_2;
    }
    goto loop_start_2;
    loop_end_2:;
    Py_XDECREF( tmp_contraction_iter_0 );
    tmp_contraction_iter_0 = NULL;

    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1070;
        type_description = "ooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    tmp_return_value = tmp_contraction_result;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_2;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_77_p_direct_xxx_declarator_4$$$function_2_listcontraction );
    return NULL;
    // Return handler code:
    try_return_handler_2:;
    Py_XDECREF( tmp_contraction_result );
    tmp_contraction_result = NULL;

    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    Py_XDECREF( tmp_contraction_iter_0 );
    tmp_contraction_iter_0 = NULL;

    Py_XDECREF( tmp_iter_value_1 );
    tmp_iter_value_1 = NULL;

    goto frame_return_exit_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_contraction_result );
    tmp_contraction_result = NULL;

    Py_XDECREF( tmp_iter_value_0 );
    tmp_iter_value_0 = NULL;

    Py_XDECREF( tmp_contraction_iter_0 );
    tmp_contraction_iter_0 = NULL;

    Py_XDECREF( tmp_iter_value_1 );
    tmp_iter_value_1 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4bc9e4c6643ef221ad4182ae532b0a87 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_4bc9e4c6643ef221ad4182ae532b0a87 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4bc9e4c6643ef221ad4182ae532b0a87 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_4bc9e4c6643ef221ad4182ae532b0a87, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_4bc9e4c6643ef221ad4182ae532b0a87->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_4bc9e4c6643ef221ad4182ae532b0a87, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_4bc9e4c6643ef221ad4182ae532b0a87, type_description ,par_$0, var_sublist, var_qual );

    // Release cached frame.
    if ( frame_4bc9e4c6643ef221ad4182ae532b0a87 == cache_frame_4bc9e4c6643ef221ad4182ae532b0a87 )
    {
        Py_DECREF( frame_4bc9e4c6643ef221ad4182ae532b0a87 );
    }
    cache_frame_4bc9e4c6643ef221ad4182ae532b0a87 = NULL;

    assertFrameObject( frame_4bc9e4c6643ef221ad4182ae532b0a87 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_77_p_direct_xxx_declarator_4$$$function_2_listcontraction );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_$0 );
    par_$0 = NULL;

    Py_XDECREF( var_sublist );
    var_sublist = NULL;

    Py_XDECREF( var_qual );
    var_qual = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_$0 );
    par_$0 = NULL;

    Py_XDECREF( var_sublist );
    var_sublist = NULL;

    Py_XDECREF( var_qual );
    var_qual = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_77_p_direct_xxx_declarator_4$$$function_2_listcontraction );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_78_p_direct_xxx_declarator_5( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *var_arr = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    int tmp_cmp_NotEq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_key_4;
    PyObject *tmp_dict_key_5;
    PyObject *tmp_dict_key_6;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_dict_value_4;
    PyObject *tmp_dict_value_5;
    PyObject *tmp_dict_value_6;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_kw_name_2;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscribed_name_5;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    PyObject *tmp_subscript_name_5;
    static struct Nuitka_FrameObject *cache_frame_ed4050f5ceb4859fce3f8015827a9ddd = NULL;

    struct Nuitka_FrameObject *frame_ed4050f5ceb4859fce3f8015827a9ddd;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ed4050f5ceb4859fce3f8015827a9ddd, codeobj_ed4050f5ceb4859fce3f8015827a9ddd, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_ed4050f5ceb4859fce3f8015827a9ddd = cache_frame_ed4050f5ceb4859fce3f8015827a9ddd;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ed4050f5ceb4859fce3f8015827a9ddd );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ed4050f5ceb4859fce3f8015827a9ddd ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1086;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_ArrayDecl );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1086;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_1 = _PyDict_NewPresized( 4 );
    tmp_dict_key_1 = const_str_plain_type;
    tmp_dict_value_1 = Py_None;
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_dim;
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1088;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_ID );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1088;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1088;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_4;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1088;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_self;

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1088;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__token_coord );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1088;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = par_p;

    if ( tmp_args_element_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1088;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = const_int_pos_4;
    frame_ed4050f5ceb4859fce3f8015827a9ddd->m_frame.f_lineno = 1088;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_args_element_name_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1088;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    frame_ed4050f5ceb4859fce3f8015827a9ddd->m_frame.f_lineno = 1088;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_dict_value_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_dict_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1088;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    Py_DECREF( tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_3 = const_str_plain_dim_quals;
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1089;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_3;
    tmp_compare_left_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1089;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = Py_None;
    tmp_cmp_NotEq_1 = RICH_COMPARE_BOOL_NE( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_NotEq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 1089;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_NotEq_1 == 1 )
    {
        goto condexpr_true_1;
    }
    else
    {
        goto condexpr_false_1;
    }
    condexpr_true_1:;
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1089;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_3;
    tmp_dict_value_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_dict_value_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1089;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    goto condexpr_end_1;
    condexpr_false_1:;
    tmp_dict_value_3 = PyList_New( 0 );
    condexpr_end_1:;
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3 );
    Py_DECREF( tmp_dict_value_3 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_4 = const_str_plain_coord;
    tmp_subscribed_name_4 = par_p;

    if ( tmp_subscribed_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1090;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_4 = const_int_pos_1;
    tmp_source_name_4 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_4 );
    if ( tmp_source_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1090;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_dict_value_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_coord );
    Py_DECREF( tmp_source_name_4 );
    if ( tmp_dict_value_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1090;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_4, tmp_dict_value_4 );
    Py_DECREF( tmp_dict_value_4 );
    assert( !(tmp_res != 0) );
    frame_ed4050f5ceb4859fce3f8015827a9ddd->m_frame.f_lineno = 1086;
    tmp_assign_source_1 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1086;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_arr == NULL );
    var_arr = tmp_assign_source_1;

    tmp_source_name_5 = par_self;

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1092;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__type_modify_decl );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1092;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_2 = _PyDict_NewPresized( 2 );
    tmp_dict_key_5 = const_str_plain_decl;
    tmp_subscribed_name_5 = par_p;

    if ( tmp_subscribed_name_5 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1092;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_5 = const_int_pos_1;
    tmp_dict_value_5 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_5, tmp_subscript_name_5 );
    if ( tmp_dict_value_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_kw_name_2 );

        exception_lineno = 1092;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_5, tmp_dict_value_5 );
    Py_DECREF( tmp_dict_value_5 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_6 = const_str_plain_modifier;
    tmp_dict_value_6 = var_arr;

    if ( tmp_dict_value_6 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "arr" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1092;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_6, tmp_dict_value_6 );
    assert( !(tmp_res != 0) );
    frame_ed4050f5ceb4859fce3f8015827a9ddd->m_frame.f_lineno = 1092;
    tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_4, tmp_kw_name_2 );
    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_kw_name_2 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1092;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1092;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1092;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ed4050f5ceb4859fce3f8015827a9ddd );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ed4050f5ceb4859fce3f8015827a9ddd );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ed4050f5ceb4859fce3f8015827a9ddd, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ed4050f5ceb4859fce3f8015827a9ddd->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ed4050f5ceb4859fce3f8015827a9ddd, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_ed4050f5ceb4859fce3f8015827a9ddd, type_description ,par_self, par_p, var_arr );

    // Release cached frame.
    if ( frame_ed4050f5ceb4859fce3f8015827a9ddd == cache_frame_ed4050f5ceb4859fce3f8015827a9ddd )
    {
        Py_DECREF( frame_ed4050f5ceb4859fce3f8015827a9ddd );
    }
    cache_frame_ed4050f5ceb4859fce3f8015827a9ddd = NULL;

    assertFrameObject( frame_ed4050f5ceb4859fce3f8015827a9ddd );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_78_p_direct_xxx_declarator_5 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_arr );
    var_arr = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_arr );
    var_arr = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_78_p_direct_xxx_declarator_5 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_79_p_direct_xxx_declarator_6( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *var_func = NULL;
    PyObject *var_param = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_key_4;
    PyObject *tmp_dict_key_5;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_dict_value_4;
    PyObject *tmp_dict_value_5;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    bool tmp_isnot_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_kw_name_2;
    PyObject *tmp_next_source_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_source_name_11;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_e4b4c3a4569c493600c917b20c1f31dd = NULL;

    struct Nuitka_FrameObject *frame_e4b4c3a4569c493600c917b20c1f31dd;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_e4b4c3a4569c493600c917b20c1f31dd, codeobj_e4b4c3a4569c493600c917b20c1f31dd, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_e4b4c3a4569c493600c917b20c1f31dd = cache_frame_e4b4c3a4569c493600c917b20c1f31dd;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_e4b4c3a4569c493600c917b20c1f31dd );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_e4b4c3a4569c493600c917b20c1f31dd ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1099;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_FuncDecl );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1099;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_1 = _PyDict_NewPresized( 3 );
    tmp_dict_key_1 = const_str_plain_args;
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1100;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_3;
    tmp_dict_value_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_dict_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1100;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    Py_DECREF( tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_type;
    tmp_dict_value_2 = Py_None;
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_3 = const_str_plain_coord;
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1102;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_1;
    tmp_source_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_source_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1102;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_dict_value_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_coord );
    Py_DECREF( tmp_source_name_2 );
    if ( tmp_dict_value_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1102;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3 );
    Py_DECREF( tmp_dict_value_3 );
    assert( !(tmp_res != 0) );
    frame_e4b4c3a4569c493600c917b20c1f31dd->m_frame.f_lineno = 1099;
    tmp_assign_source_1 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1099;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_func == NULL );
    var_func = tmp_assign_source_1;

    tmp_called_instance_1 = par_self;

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1115;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

    frame_e4b4c3a4569c493600c917b20c1f31dd->m_frame.f_lineno = 1115;
    tmp_source_name_3 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__get_yacc_lookahead_token );
    if ( tmp_source_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1115;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_type );
    Py_DECREF( tmp_source_name_3 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1115;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_str_plain_LBRACE;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 1115;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_4 = var_func;

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "func" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1116;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_args );
    if ( tmp_compare_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1116;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_2 = Py_None;
    tmp_isnot_1 = ( tmp_compare_left_2 != tmp_compare_right_2 );
    Py_DECREF( tmp_compare_left_2 );
    if ( tmp_isnot_1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_source_name_6 = var_func;

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "func" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1117;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_args );
    if ( tmp_source_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1117;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_iter_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_params );
    Py_DECREF( tmp_source_name_5 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1117;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1117;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_2;

    // Tried code:
    loop_start_1:;
    tmp_next_source_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_next_source_1 );
    tmp_assign_source_3 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            type_description = "oooo";
            exception_lineno = 1117;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_3;
        Py_XDECREF( old );
    }

    tmp_assign_source_4 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_4 );
    {
        PyObject *old = var_param;
        var_param = tmp_assign_source_4;
        Py_INCREF( var_param );
        Py_XDECREF( old );
    }

    tmp_isinstance_inst_1 = var_param;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_source_name_7 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_7 == NULL ))
    {
        tmp_source_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1118;
        type_description = "oooo";
        goto try_except_handler_2;
    }

    tmp_isinstance_cls_1 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_EllipsisParam );
    if ( tmp_isinstance_cls_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1118;
        type_description = "oooo";
        goto try_except_handler_2;
    }
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    Py_DECREF( tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1118;
        type_description = "oooo";
        goto try_except_handler_2;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    goto loop_end_1;
    branch_no_3:;
    tmp_source_name_8 = par_self;

    if ( tmp_source_name_8 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1119;
        type_description = "oooo";
        goto try_except_handler_2;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain__add_identifier );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1119;
        type_description = "oooo";
        goto try_except_handler_2;
    }
    tmp_source_name_9 = var_param;

    if ( tmp_source_name_9 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "param" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1119;
        type_description = "oooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_name );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1119;
        type_description = "oooo";
        goto try_except_handler_2;
    }
    tmp_source_name_10 = var_param;

    if ( tmp_source_name_10 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "param" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1119;
        type_description = "oooo";
        goto try_except_handler_2;
    }

    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_coord );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1119;
        type_description = "oooo";
        goto try_except_handler_2;
    }
    frame_e4b4c3a4569c493600c917b20c1f31dd->m_frame.f_lineno = 1119;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1119;
        type_description = "oooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1117;
        type_description = "oooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    Py_XDECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    Py_XDECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    branch_no_2:;
    branch_no_1:;
    tmp_source_name_11 = par_self;

    if ( tmp_source_name_11 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1121;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain__type_modify_decl );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1121;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_2 = _PyDict_NewPresized( 2 );
    tmp_dict_key_4 = const_str_plain_decl;
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1121;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_1;
    tmp_dict_value_4 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_dict_value_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_kw_name_2 );

        exception_lineno = 1121;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_4, tmp_dict_value_4 );
    Py_DECREF( tmp_dict_value_4 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_5 = const_str_plain_modifier;
    tmp_dict_value_5 = var_func;

    if ( tmp_dict_value_5 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "func" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1121;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_5, tmp_dict_value_5 );
    assert( !(tmp_res != 0) );
    frame_e4b4c3a4569c493600c917b20c1f31dd->m_frame.f_lineno = 1121;
    tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_3, tmp_kw_name_2 );
    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_kw_name_2 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1121;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1121;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1121;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e4b4c3a4569c493600c917b20c1f31dd );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_e4b4c3a4569c493600c917b20c1f31dd );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_e4b4c3a4569c493600c917b20c1f31dd, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_e4b4c3a4569c493600c917b20c1f31dd->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_e4b4c3a4569c493600c917b20c1f31dd, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_e4b4c3a4569c493600c917b20c1f31dd, type_description ,par_self, par_p, var_func, var_param );

    // Release cached frame.
    if ( frame_e4b4c3a4569c493600c917b20c1f31dd == cache_frame_e4b4c3a4569c493600c917b20c1f31dd )
    {
        Py_DECREF( frame_e4b4c3a4569c493600c917b20c1f31dd );
    }
    cache_frame_e4b4c3a4569c493600c917b20c1f31dd = NULL;

    assertFrameObject( frame_e4b4c3a4569c493600c917b20c1f31dd );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_79_p_direct_xxx_declarator_6 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_func );
    var_func = NULL;

    Py_XDECREF( var_param );
    var_param = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_func );
    var_func = NULL;

    Py_XDECREF( var_param );
    var_param = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_79_p_direct_xxx_declarator_6 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_80_p_pointer( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *var_coord = NULL;
    PyObject *var_nested_type = NULL;
    PyObject *var_tail_type = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscribed_2;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subscript_2;
    int tmp_ass_subscript_res_1;
    int tmp_ass_subscript_res_2;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_ass_subvalue_2;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cmp_Gt_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    bool tmp_is_1;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_len_arg_1;
    int tmp_or_left_truth_1;
    PyObject *tmp_or_left_value_1;
    PyObject *tmp_or_right_value_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    static struct Nuitka_FrameObject *cache_frame_878a1c18fbce981d7e9ea80408cd4b98 = NULL;

    struct Nuitka_FrameObject *frame_878a1c18fbce981d7e9ea80408cd4b98;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_878a1c18fbce981d7e9ea80408cd4b98, codeobj_878a1c18fbce981d7e9ea80408cd4b98, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_878a1c18fbce981d7e9ea80408cd4b98 = cache_frame_878a1c18fbce981d7e9ea80408cd4b98;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_878a1c18fbce981d7e9ea80408cd4b98 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_878a1c18fbce981d7e9ea80408cd4b98 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__token_coord );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1127;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_p;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1127;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = const_int_pos_1;
    frame_878a1c18fbce981d7e9ea80408cd4b98->m_frame.f_lineno = 1127;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1127;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_coord == NULL );
    var_coord = tmp_assign_source_1;

    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1143;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_PtrDecl );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1143;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_1 = _PyDict_NewPresized( 3 );
    tmp_dict_key_1 = const_str_plain_quals;
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1143;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_2;
    tmp_or_left_value_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_or_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1143;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
    if ( tmp_or_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_or_left_value_1 );

        exception_lineno = 1143;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_or_left_truth_1 == 1 )
    {
        goto or_left_1;
    }
    else
    {
        goto or_right_1;
    }
    or_right_1:;
    Py_DECREF( tmp_or_left_value_1 );
    tmp_or_right_value_1 = PyList_New( 0 );
    tmp_dict_value_1 = tmp_or_right_value_1;
    goto or_end_1;
    or_left_1:;
    tmp_dict_value_1 = tmp_or_left_value_1;
    or_end_1:;
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    Py_DECREF( tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_type;
    tmp_dict_value_2 = Py_None;
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_3 = const_str_plain_coord;
    tmp_dict_value_3 = var_coord;

    if ( tmp_dict_value_3 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "coord" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1143;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3 );
    assert( !(tmp_res != 0) );
    frame_878a1c18fbce981d7e9ea80408cd4b98->m_frame.f_lineno = 1143;
    tmp_assign_source_2 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_2, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1143;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_nested_type == NULL );
    var_nested_type = tmp_assign_source_2;

    tmp_len_arg_1 = par_p;

    if ( tmp_len_arg_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1144;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1144;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_pos_3;
    tmp_cmp_Gt_1 = RICH_COMPARE_BOOL_GT( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Gt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 1144;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Gt_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1145;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_3;
    tmp_assign_source_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1145;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_tail_type == NULL );
    var_tail_type = tmp_assign_source_3;

    loop_start_1:;
    tmp_source_name_3 = var_tail_type;

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "tail_type" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1146;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_type );
    if ( tmp_compare_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1146;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_2 = Py_None;
    tmp_is_1 = ( tmp_compare_left_2 == tmp_compare_right_2 );
    Py_DECREF( tmp_compare_left_2 );
    if ( tmp_is_1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    goto loop_end_1;
    branch_no_2:;
    tmp_source_name_4 = var_tail_type;

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "tail_type" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1147;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_assign_source_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_type );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1147;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_tail_type;
        var_tail_type = tmp_assign_source_4;
        Py_XDECREF( old );
    }

    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1146;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    goto loop_start_1;
    loop_end_1:;
    tmp_assattr_name_1 = var_nested_type;

    if ( tmp_assattr_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "nested_type" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1148;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_assattr_target_1 = var_tail_type;

    if ( tmp_assattr_target_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "tail_type" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1148;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_type, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1148;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1149;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_3;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1149;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1149;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1149;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    goto branch_end_1;
    branch_no_1:;
    tmp_ass_subvalue_2 = var_nested_type;

    if ( tmp_ass_subvalue_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "nested_type" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1151;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscribed_2 = par_p;

    if ( tmp_ass_subscribed_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1151;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_2 = const_int_0;
    tmp_ass_subscript_res_2 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_2, tmp_ass_subscript_2, 0, tmp_ass_subvalue_2 );
    if ( tmp_ass_subscript_res_2 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1151;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_878a1c18fbce981d7e9ea80408cd4b98 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_878a1c18fbce981d7e9ea80408cd4b98 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_878a1c18fbce981d7e9ea80408cd4b98, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_878a1c18fbce981d7e9ea80408cd4b98->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_878a1c18fbce981d7e9ea80408cd4b98, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_878a1c18fbce981d7e9ea80408cd4b98, type_description ,par_self, par_p, var_coord, var_nested_type, var_tail_type );

    // Release cached frame.
    if ( frame_878a1c18fbce981d7e9ea80408cd4b98 == cache_frame_878a1c18fbce981d7e9ea80408cd4b98 )
    {
        Py_DECREF( frame_878a1c18fbce981d7e9ea80408cd4b98 );
    }
    cache_frame_878a1c18fbce981d7e9ea80408cd4b98 = NULL;

    assertFrameObject( frame_878a1c18fbce981d7e9ea80408cd4b98 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_80_p_pointer );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_coord );
    var_coord = NULL;

    Py_XDECREF( var_nested_type );
    var_nested_type = NULL;

    Py_XDECREF( var_tail_type );
    var_tail_type = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_coord );
    var_coord = NULL;

    Py_XDECREF( var_nested_type );
    var_nested_type = NULL;

    Py_XDECREF( var_tail_type );
    var_tail_type = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_80_p_pointer );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_81_p_type_qualifier_list( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_list_element_1;
    PyObject *tmp_list_element_2;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    static struct Nuitka_FrameObject *cache_frame_5d32d7d5b0f216e650e8a6ecb453fe6c = NULL;

    struct Nuitka_FrameObject *frame_5d32d7d5b0f216e650e8a6ecb453fe6c;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5d32d7d5b0f216e650e8a6ecb453fe6c, codeobj_5d32d7d5b0f216e650e8a6ecb453fe6c, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_5d32d7d5b0f216e650e8a6ecb453fe6c = cache_frame_5d32d7d5b0f216e650e8a6ecb453fe6c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5d32d7d5b0f216e650e8a6ecb453fe6c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5d32d7d5b0f216e650e8a6ecb453fe6c ) == 2 ); // Frame stack

    // Framed code:
    tmp_len_arg_1 = par_p;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1157;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_pos_2;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 1157;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto condexpr_true_1;
    }
    else
    {
        goto condexpr_false_1;
    }
    condexpr_true_1:;
    tmp_ass_subvalue_1 = PyList_New( 1 );
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1157;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_list_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_list_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_1 );

        exception_lineno = 1157;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyList_SET_ITEM( tmp_ass_subvalue_1, 0, tmp_list_element_1 );
    goto condexpr_end_1;
    condexpr_false_1:;
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1157;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_1;
    tmp_left_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_left_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1157;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_1 = PyList_New( 1 );
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_left_name_1 );
        Py_DECREF( tmp_right_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1157;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_2;
    tmp_list_element_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_list_element_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_1 );
        Py_DECREF( tmp_right_name_1 );

        exception_lineno = 1157;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyList_SET_ITEM( tmp_right_name_1, 0, tmp_list_element_2 );
    tmp_ass_subvalue_1 = BINARY_OPERATION_ADD( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_left_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1157;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    condexpr_end_1:;
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1157;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1157;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5d32d7d5b0f216e650e8a6ecb453fe6c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5d32d7d5b0f216e650e8a6ecb453fe6c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5d32d7d5b0f216e650e8a6ecb453fe6c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5d32d7d5b0f216e650e8a6ecb453fe6c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5d32d7d5b0f216e650e8a6ecb453fe6c, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_5d32d7d5b0f216e650e8a6ecb453fe6c, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_5d32d7d5b0f216e650e8a6ecb453fe6c == cache_frame_5d32d7d5b0f216e650e8a6ecb453fe6c )
    {
        Py_DECREF( frame_5d32d7d5b0f216e650e8a6ecb453fe6c );
    }
    cache_frame_5d32d7d5b0f216e650e8a6ecb453fe6c = NULL;

    assertFrameObject( frame_5d32d7d5b0f216e650e8a6ecb453fe6c );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_81_p_type_qualifier_list );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_81_p_type_qualifier_list );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_82_p_parameter_type_list( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    int tmp_cmp_Gt_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_11b37f28b0696e358af2a7dcdff91c68 = NULL;

    struct Nuitka_FrameObject *frame_11b37f28b0696e358af2a7dcdff91c68;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_11b37f28b0696e358af2a7dcdff91c68, codeobj_11b37f28b0696e358af2a7dcdff91c68, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_11b37f28b0696e358af2a7dcdff91c68 = cache_frame_11b37f28b0696e358af2a7dcdff91c68;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_11b37f28b0696e358af2a7dcdff91c68 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_11b37f28b0696e358af2a7dcdff91c68 ) == 2 ); // Frame stack

    // Framed code:
    tmp_len_arg_1 = par_p;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1163;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_pos_2;
    tmp_cmp_Gt_1 = RICH_COMPARE_BOOL_GT( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Gt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 1163;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Gt_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1164;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_source_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_source_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1164;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_params );
    Py_DECREF( tmp_source_name_2 );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1164;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_append );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1164;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1164;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_EllipsisParam );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1164;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = par_self;

    if ( tmp_source_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1164;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__token_coord );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1164;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = par_p;

    if ( tmp_args_element_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1164;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = const_int_pos_3;
    frame_11b37f28b0696e358af2a7dcdff91c68->m_frame.f_lineno = 1164;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_args_element_name_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1164;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_11b37f28b0696e358af2a7dcdff91c68->m_frame.f_lineno = 1164;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1164;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_11b37f28b0696e358af2a7dcdff91c68->m_frame.f_lineno = 1164;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1164;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_1:;
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1166;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_1;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1166;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1166;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1166;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_11b37f28b0696e358af2a7dcdff91c68 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_11b37f28b0696e358af2a7dcdff91c68 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_11b37f28b0696e358af2a7dcdff91c68, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_11b37f28b0696e358af2a7dcdff91c68->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_11b37f28b0696e358af2a7dcdff91c68, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_11b37f28b0696e358af2a7dcdff91c68, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_11b37f28b0696e358af2a7dcdff91c68 == cache_frame_11b37f28b0696e358af2a7dcdff91c68 )
    {
        Py_DECREF( frame_11b37f28b0696e358af2a7dcdff91c68 );
    }
    cache_frame_11b37f28b0696e358af2a7dcdff91c68 = NULL;

    assertFrameObject( frame_11b37f28b0696e358af2a7dcdff91c68 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_82_p_parameter_type_list );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_82_p_parameter_type_list );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_83_p_parameter_list( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscribed_2;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subscript_2;
    int tmp_ass_subscript_res_1;
    int tmp_ass_subscript_res_2;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_ass_subvalue_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_list_element_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscribed_name_5;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    PyObject *tmp_subscript_name_5;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_33c782c9369ccb6646fd10ca5266b9cf = NULL;

    struct Nuitka_FrameObject *frame_33c782c9369ccb6646fd10ca5266b9cf;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_33c782c9369ccb6646fd10ca5266b9cf, codeobj_33c782c9369ccb6646fd10ca5266b9cf, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_33c782c9369ccb6646fd10ca5266b9cf = cache_frame_33c782c9369ccb6646fd10ca5266b9cf;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_33c782c9369ccb6646fd10ca5266b9cf );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_33c782c9369ccb6646fd10ca5266b9cf ) == 2 ); // Frame stack

    // Framed code:
    tmp_len_arg_1 = par_p;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1172;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_pos_2;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 1172;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1173;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_ParamList );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1173;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = PyList_New( 1 );
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1173;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_list_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_list_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1173;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyList_SET_ITEM( tmp_args_element_name_1, 0, tmp_list_element_1 );
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1173;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_1;
    tmp_source_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_source_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1173;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_coord );
    Py_DECREF( tmp_source_name_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1173;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_33c782c9369ccb6646fd10ca5266b9cf->m_frame.f_lineno = 1173;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1173;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1173;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1173;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto branch_end_1;
    branch_no_1:;
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1175;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_1;
    tmp_source_name_4 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_source_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1175;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_params );
    Py_DECREF( tmp_source_name_4 );
    if ( tmp_source_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1175;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_append );
    Py_DECREF( tmp_source_name_3 );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1175;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_4 = par_p;

    if ( tmp_subscribed_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1175;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_4 = const_int_pos_3;
    tmp_args_element_name_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_4 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1175;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_33c782c9369ccb6646fd10ca5266b9cf->m_frame.f_lineno = 1175;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1175;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_subscribed_name_5 = par_p;

    if ( tmp_subscribed_name_5 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1176;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_5 = const_int_pos_1;
    tmp_ass_subvalue_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_5, tmp_subscript_name_5 );
    if ( tmp_ass_subvalue_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1176;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_2 = par_p;

    if ( tmp_ass_subscribed_2 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1176;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_2 = const_int_0;
    tmp_ass_subscript_res_2 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_2, tmp_ass_subscript_2, 0, tmp_ass_subvalue_2 );
    Py_DECREF( tmp_ass_subvalue_2 );
    if ( tmp_ass_subscript_res_2 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1176;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_33c782c9369ccb6646fd10ca5266b9cf );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_33c782c9369ccb6646fd10ca5266b9cf );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_33c782c9369ccb6646fd10ca5266b9cf, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_33c782c9369ccb6646fd10ca5266b9cf->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_33c782c9369ccb6646fd10ca5266b9cf, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_33c782c9369ccb6646fd10ca5266b9cf, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_33c782c9369ccb6646fd10ca5266b9cf == cache_frame_33c782c9369ccb6646fd10ca5266b9cf )
    {
        Py_DECREF( frame_33c782c9369ccb6646fd10ca5266b9cf );
    }
    cache_frame_33c782c9369ccb6646fd10ca5266b9cf = NULL;

    assertFrameObject( frame_33c782c9369ccb6646fd10ca5266b9cf );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_83_p_parameter_list );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_83_p_parameter_list );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_84_p_parameter_declaration_1( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *var_spec = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_name_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscribed_2;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subscript_2;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_ass_subvalue_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_key_4;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_dict_value_4;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_kw_name_2;
    PyObject *tmp_list_element_1;
    PyObject *tmp_list_element_2;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    static struct Nuitka_FrameObject *cache_frame_1802192b2a03b205fa58a441ed52b1bb = NULL;

    struct Nuitka_FrameObject *frame_1802192b2a03b205fa58a441ed52b1bb;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1802192b2a03b205fa58a441ed52b1bb, codeobj_1802192b2a03b205fa58a441ed52b1bb, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_1802192b2a03b205fa58a441ed52b1bb = cache_frame_1802192b2a03b205fa58a441ed52b1bb;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1802192b2a03b205fa58a441ed52b1bb );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1802192b2a03b205fa58a441ed52b1bb ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_assign_source_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1192;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_spec == NULL );
    var_spec = tmp_assign_source_1;

    tmp_subscribed_name_2 = var_spec;

    CHECK_OBJECT( tmp_subscribed_name_2 );
    tmp_subscript_name_2 = const_str_plain_type;
    tmp_cond_value_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1193;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 1193;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_ass_subvalue_1 = PyList_New( 1 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1194;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_IdentifierType );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_1 );

        exception_lineno = 1194;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_name_1 = DEEP_COPY( const_tuple_list_str_plain_int_list_tuple );
    tmp_kw_name_1 = _PyDict_NewPresized( 1 );
    tmp_dict_key_1 = const_str_plain_coord;
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1195;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_1 );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1195;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_p;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1195;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = const_int_pos_1;
    frame_1802192b2a03b205fa58a441ed52b1bb->m_frame.f_lineno = 1195;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_dict_value_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_dict_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_1 );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1195;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    Py_DECREF( tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    frame_1802192b2a03b205fa58a441ed52b1bb->m_frame.f_lineno = 1194;
    tmp_list_element_1 = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_list_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_1 );

        exception_lineno = 1194;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    PyList_SET_ITEM( tmp_ass_subvalue_1, 0, tmp_list_element_1 );
    tmp_ass_subscribed_1 = var_spec;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1194;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_str_plain_type;
    tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_1, tmp_ass_subscript_1, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1194;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    branch_no_1:;
    tmp_source_name_3 = par_self;

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1196;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__build_declarations );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1196;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_2 = _PyDict_NewPresized( 2 );
    tmp_dict_key_2 = const_str_plain_spec;
    tmp_dict_value_2 = var_spec;

    if ( tmp_dict_value_2 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1197;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_2, tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_3 = const_str_plain_decls;
    tmp_dict_value_3 = PyList_New( 1 );
    tmp_list_element_2 = _PyDict_NewPresized( 1 );
    tmp_dict_key_4 = const_str_plain_decl;
    tmp_subscribed_name_4 = par_p;

    if ( tmp_subscribed_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_kw_name_2 );
        Py_DECREF( tmp_dict_value_3 );
        Py_DECREF( tmp_list_element_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1198;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_2;
    tmp_dict_value_4 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_3 );
    if ( tmp_dict_value_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_kw_name_2 );
        Py_DECREF( tmp_dict_value_3 );
        Py_DECREF( tmp_list_element_2 );

        exception_lineno = 1198;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_list_element_2, tmp_dict_key_4, tmp_dict_value_4 );
    Py_DECREF( tmp_dict_value_4 );
    assert( !(tmp_res != 0) );
    PyList_SET_ITEM( tmp_dict_value_3, 0, tmp_list_element_2 );
    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_3, tmp_dict_value_3 );
    Py_DECREF( tmp_dict_value_3 );
    assert( !(tmp_res != 0) );
    frame_1802192b2a03b205fa58a441ed52b1bb->m_frame.f_lineno = 1196;
    tmp_subscribed_name_3 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_3, tmp_kw_name_2 );
    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_kw_name_2 );
    if ( tmp_subscribed_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1196;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_4 = const_int_0;
    tmp_ass_subvalue_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_4 );
    Py_DECREF( tmp_subscribed_name_3 );
    if ( tmp_ass_subvalue_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1196;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_2 = par_p;

    if ( tmp_ass_subscribed_2 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1196;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_2 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_2, tmp_ass_subscript_2, 0, tmp_ass_subvalue_2 );
    Py_DECREF( tmp_ass_subvalue_2 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1196;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1802192b2a03b205fa58a441ed52b1bb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1802192b2a03b205fa58a441ed52b1bb );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1802192b2a03b205fa58a441ed52b1bb, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1802192b2a03b205fa58a441ed52b1bb->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1802192b2a03b205fa58a441ed52b1bb, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_1802192b2a03b205fa58a441ed52b1bb, type_description ,par_self, par_p, var_spec );

    // Release cached frame.
    if ( frame_1802192b2a03b205fa58a441ed52b1bb == cache_frame_1802192b2a03b205fa58a441ed52b1bb )
    {
        Py_DECREF( frame_1802192b2a03b205fa58a441ed52b1bb );
    }
    cache_frame_1802192b2a03b205fa58a441ed52b1bb = NULL;

    assertFrameObject( frame_1802192b2a03b205fa58a441ed52b1bb );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_84_p_parameter_declaration_1 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_spec );
    var_spec = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_spec );
    var_spec = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_84_p_parameter_declaration_1 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_85_p_parameter_declaration_2( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *var_spec = NULL;
    PyObject *var_decl = NULL;
    PyObject *var_typename = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_and_left_truth_1;
    int tmp_and_left_truth_2;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_left_value_2;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_and_right_value_2;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_name_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscribed_2;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subscript_2;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_ass_subvalue_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_key_4;
    PyObject *tmp_dict_key_5;
    PyObject *tmp_dict_key_6;
    PyObject *tmp_dict_key_7;
    PyObject *tmp_dict_key_8;
    PyObject *tmp_dict_key_9;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_dict_value_4;
    PyObject *tmp_dict_value_5;
    PyObject *tmp_dict_value_6;
    PyObject *tmp_dict_value_7;
    PyObject *tmp_dict_value_8;
    PyObject *tmp_dict_value_9;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_kw_name_2;
    PyObject *tmp_kw_name_3;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_len_arg_2;
    PyObject *tmp_list_element_1;
    PyObject *tmp_list_element_2;
    int tmp_or_left_truth_1;
    PyObject *tmp_or_left_value_1;
    PyObject *tmp_or_right_value_1;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscribed_name_5;
    PyObject *tmp_subscribed_name_6;
    PyObject *tmp_subscribed_name_7;
    PyObject *tmp_subscribed_name_8;
    PyObject *tmp_subscribed_name_9;
    PyObject *tmp_subscribed_name_10;
    PyObject *tmp_subscribed_name_11;
    PyObject *tmp_subscribed_name_12;
    PyObject *tmp_subscribed_name_13;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    PyObject *tmp_subscript_name_5;
    PyObject *tmp_subscript_name_6;
    PyObject *tmp_subscript_name_7;
    PyObject *tmp_subscript_name_8;
    PyObject *tmp_subscript_name_9;
    PyObject *tmp_subscript_name_10;
    PyObject *tmp_subscript_name_11;
    PyObject *tmp_subscript_name_12;
    PyObject *tmp_subscript_name_13;
    static struct Nuitka_FrameObject *cache_frame_ec7e7fa34698fe0d0aeabdfc87e00cd0 = NULL;

    struct Nuitka_FrameObject *frame_ec7e7fa34698fe0d0aeabdfc87e00cd0;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ec7e7fa34698fe0d0aeabdfc87e00cd0, codeobj_ec7e7fa34698fe0d0aeabdfc87e00cd0, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_ec7e7fa34698fe0d0aeabdfc87e00cd0 = cache_frame_ec7e7fa34698fe0d0aeabdfc87e00cd0;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ec7e7fa34698fe0d0aeabdfc87e00cd0 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ec7e7fa34698fe0d0aeabdfc87e00cd0 ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_assign_source_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1203;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_spec == NULL );
    var_spec = tmp_assign_source_1;

    tmp_subscribed_name_2 = var_spec;

    CHECK_OBJECT( tmp_subscribed_name_2 );
    tmp_subscript_name_2 = const_str_plain_type;
    tmp_cond_value_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1204;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 1204;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_ass_subvalue_1 = PyList_New( 1 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1205;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_IdentifierType );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_1 );

        exception_lineno = 1205;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_name_1 = DEEP_COPY( const_tuple_list_str_plain_int_list_tuple );
    tmp_kw_name_1 = _PyDict_NewPresized( 1 );
    tmp_dict_key_1 = const_str_plain_coord;
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1206;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_1 );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1206;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_p;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1206;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = const_int_pos_1;
    frame_ec7e7fa34698fe0d0aeabdfc87e00cd0->m_frame.f_lineno = 1206;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_dict_value_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_dict_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_1 );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1206;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    Py_DECREF( tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    frame_ec7e7fa34698fe0d0aeabdfc87e00cd0->m_frame.f_lineno = 1205;
    tmp_list_element_1 = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_list_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_1 );

        exception_lineno = 1205;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    PyList_SET_ITEM( tmp_ass_subvalue_1, 0, tmp_list_element_1 );
    tmp_ass_subscribed_1 = var_spec;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1205;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_str_plain_type;
    tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_1, tmp_ass_subscript_1, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1205;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    branch_no_1:;
    tmp_subscribed_name_3 = var_spec;

    if ( tmp_subscribed_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1212;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_str_plain_type;
    tmp_len_arg_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_len_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1212;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    Py_DECREF( tmp_len_arg_1 );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1212;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_1 = const_int_pos_1;
    tmp_and_left_value_1 = RICH_COMPARE_GT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    if ( tmp_and_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1212;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_1 );

        exception_lineno = 1213;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    Py_DECREF( tmp_and_left_value_1 );
    tmp_subscribed_name_5 = var_spec;

    if ( tmp_subscribed_name_5 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1212;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_4 = const_str_plain_type;
    tmp_subscribed_name_4 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_5, tmp_subscript_name_4 );
    if ( tmp_subscribed_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1212;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_5 = const_int_neg_1;
    tmp_source_name_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_5 );
    Py_DECREF( tmp_subscribed_name_4 );
    if ( tmp_source_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1212;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_len_arg_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_names );
    Py_DECREF( tmp_source_name_3 );
    if ( tmp_len_arg_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1212;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_left_2 = BUILTIN_LEN( tmp_len_arg_2 );
    Py_DECREF( tmp_len_arg_2 );
    if ( tmp_compexpr_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1212;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_2 = const_int_pos_1;
    tmp_and_left_value_2 = RICH_COMPARE_EQ( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    Py_DECREF( tmp_compexpr_left_2 );
    if ( tmp_and_left_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1212;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_2 = CHECK_IF_TRUE( tmp_and_left_value_2 );
    if ( tmp_and_left_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_2 );

        exception_lineno = 1213;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_2 == 1 )
    {
        goto and_right_2;
    }
    else
    {
        goto and_left_2;
    }
    and_right_2:;
    Py_DECREF( tmp_and_left_value_2 );
    tmp_source_name_4 = par_self;

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1213;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__is_type_in_scope );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1213;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_8 = var_spec;

    if ( tmp_subscribed_name_8 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1213;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_6 = const_str_plain_type;
    tmp_subscribed_name_7 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_8, tmp_subscript_name_6 );
    if ( tmp_subscribed_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1213;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_7 = const_int_neg_1;
    tmp_source_name_5 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_7, tmp_subscript_name_7 );
    Py_DECREF( tmp_subscribed_name_7 );
    if ( tmp_source_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1213;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_names );
    Py_DECREF( tmp_source_name_5 );
    if ( tmp_subscribed_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1213;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_8 = const_int_0;
    tmp_args_element_name_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_6, tmp_subscript_name_8 );
    Py_DECREF( tmp_subscribed_name_6 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1213;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    frame_ec7e7fa34698fe0d0aeabdfc87e00cd0->m_frame.f_lineno = 1213;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_and_right_value_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_and_right_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1213;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_and_right_value_1 = tmp_and_right_value_2;
    goto and_end_2;
    and_left_2:;
    tmp_and_right_value_1 = tmp_and_left_value_2;
    and_end_2:;
    tmp_cond_value_2 = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_cond_value_2 = tmp_and_left_value_1;
    and_end_1:;
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_2 );

        exception_lineno = 1213;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_source_name_6 = par_self;

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1214;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain__build_declarations );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1214;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_2 = _PyDict_NewPresized( 2 );
    tmp_dict_key_2 = const_str_plain_spec;
    tmp_dict_value_2 = var_spec;

    if ( tmp_dict_value_2 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1215;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_2, tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_3 = const_str_plain_decls;
    tmp_dict_value_3 = PyList_New( 1 );
    tmp_list_element_2 = _PyDict_NewPresized( 2 );
    tmp_dict_key_4 = const_str_plain_decl;
    tmp_subscribed_name_10 = par_p;

    if ( tmp_subscribed_name_10 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_kw_name_2 );
        Py_DECREF( tmp_dict_value_3 );
        Py_DECREF( tmp_list_element_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1216;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_9 = const_int_pos_2;
    tmp_dict_value_4 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_10, tmp_subscript_name_9 );
    if ( tmp_dict_value_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_kw_name_2 );
        Py_DECREF( tmp_dict_value_3 );
        Py_DECREF( tmp_list_element_2 );

        exception_lineno = 1216;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_list_element_2, tmp_dict_key_4, tmp_dict_value_4 );
    Py_DECREF( tmp_dict_value_4 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_5 = const_str_plain_init;
    tmp_dict_value_5 = Py_None;
    tmp_res = PyDict_SetItem( tmp_list_element_2, tmp_dict_key_5, tmp_dict_value_5 );
    assert( !(tmp_res != 0) );
    PyList_SET_ITEM( tmp_dict_value_3, 0, tmp_list_element_2 );
    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_3, tmp_dict_value_3 );
    Py_DECREF( tmp_dict_value_3 );
    assert( !(tmp_res != 0) );
    frame_ec7e7fa34698fe0d0aeabdfc87e00cd0->m_frame.f_lineno = 1214;
    tmp_subscribed_name_9 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_4, tmp_kw_name_2 );
    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_kw_name_2 );
    if ( tmp_subscribed_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1214;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_10 = const_int_0;
    tmp_assign_source_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_9, tmp_subscript_name_10 );
    Py_DECREF( tmp_subscribed_name_9 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1214;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_decl == NULL );
    var_decl = tmp_assign_source_2;

    goto branch_end_2;
    branch_no_2:;
    tmp_source_name_7 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_7 == NULL ))
    {
        tmp_source_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1221;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_Typename );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1221;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_3 = _PyDict_NewPresized( 4 );
    tmp_dict_key_6 = const_str_plain_name;
    tmp_dict_value_6 = const_str_empty;
    tmp_res = PyDict_SetItem( tmp_kw_name_3, tmp_dict_key_6, tmp_dict_value_6 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_7 = const_str_plain_quals;
    tmp_subscribed_name_11 = var_spec;

    if ( tmp_subscribed_name_11 == NULL )
    {
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_kw_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1223;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_11 = const_str_plain_qual;
    tmp_dict_value_7 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_11, tmp_subscript_name_11 );
    if ( tmp_dict_value_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_kw_name_3 );

        exception_lineno = 1223;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_3, tmp_dict_key_7, tmp_dict_value_7 );
    Py_DECREF( tmp_dict_value_7 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_8 = const_str_plain_type;
    tmp_subscribed_name_12 = par_p;

    if ( tmp_subscribed_name_12 == NULL )
    {
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_kw_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1224;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_12 = const_int_pos_2;
    tmp_or_left_value_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_12, tmp_subscript_name_12 );
    if ( tmp_or_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_kw_name_3 );

        exception_lineno = 1224;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
    if ( tmp_or_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_kw_name_3 );
        Py_DECREF( tmp_or_left_value_1 );

        exception_lineno = 1224;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_or_left_truth_1 == 1 )
    {
        goto or_left_1;
    }
    else
    {
        goto or_right_1;
    }
    or_right_1:;
    Py_DECREF( tmp_or_left_value_1 );
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_called_instance_1 == NULL )
    {
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_kw_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1224;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    frame_ec7e7fa34698fe0d0aeabdfc87e00cd0->m_frame.f_lineno = 1224;
    tmp_or_right_value_1 = CALL_METHOD_WITH_ARGS3( tmp_called_instance_1, const_str_plain_TypeDecl, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

    if ( tmp_or_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_kw_name_3 );

        exception_lineno = 1224;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_dict_value_8 = tmp_or_right_value_1;
    goto or_end_1;
    or_left_1:;
    tmp_dict_value_8 = tmp_or_left_value_1;
    or_end_1:;
    tmp_res = PyDict_SetItem( tmp_kw_name_3, tmp_dict_key_8, tmp_dict_value_8 );
    Py_DECREF( tmp_dict_value_8 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_9 = const_str_plain_coord;
    tmp_source_name_8 = par_self;

    if ( tmp_source_name_8 == NULL )
    {
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_kw_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1225;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain__token_coord );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_kw_name_3 );

        exception_lineno = 1225;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = par_p;

    if ( tmp_args_element_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_kw_name_3 );
        Py_DECREF( tmp_called_name_6 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1225;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = const_int_pos_2;
    frame_ec7e7fa34698fe0d0aeabdfc87e00cd0->m_frame.f_lineno = 1225;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_dict_value_9 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_called_name_6 );
    if ( tmp_dict_value_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );
        Py_DECREF( tmp_kw_name_3 );

        exception_lineno = 1225;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_3, tmp_dict_key_9, tmp_dict_value_9 );
    Py_DECREF( tmp_dict_value_9 );
    assert( !(tmp_res != 0) );
    frame_ec7e7fa34698fe0d0aeabdfc87e00cd0->m_frame.f_lineno = 1221;
    tmp_assign_source_3 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_5, tmp_kw_name_3 );
    Py_DECREF( tmp_called_name_5 );
    Py_DECREF( tmp_kw_name_3 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1221;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_decl == NULL );
    var_decl = tmp_assign_source_3;

    tmp_subscribed_name_13 = var_spec;

    if ( tmp_subscribed_name_13 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "spec" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1226;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_13 = const_str_plain_type;
    tmp_assign_source_4 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_13, tmp_subscript_name_13 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1226;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_typename == NULL );
    var_typename = tmp_assign_source_4;

    tmp_source_name_9 = par_self;

    if ( tmp_source_name_9 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1227;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain__fix_decl_name_type );
    if ( tmp_called_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1227;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_6 = var_decl;

    if ( tmp_args_element_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_7 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "decl" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1227;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_7 = var_typename;

    if ( tmp_args_element_name_7 == NULL )
    {
        Py_DECREF( tmp_called_name_7 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "typename" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1227;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    frame_ec7e7fa34698fe0d0aeabdfc87e00cd0->m_frame.f_lineno = 1227;
    {
        PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
        tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_7, call_args );
    }

    Py_DECREF( tmp_called_name_7 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1227;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_decl;
        var_decl = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    branch_end_2:;
    tmp_ass_subvalue_2 = var_decl;

    CHECK_OBJECT( tmp_ass_subvalue_2 );
    tmp_ass_subscribed_2 = par_p;

    if ( tmp_ass_subscribed_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1229;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_2 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_2, tmp_ass_subscript_2, 0, tmp_ass_subvalue_2 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1229;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ec7e7fa34698fe0d0aeabdfc87e00cd0 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ec7e7fa34698fe0d0aeabdfc87e00cd0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ec7e7fa34698fe0d0aeabdfc87e00cd0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ec7e7fa34698fe0d0aeabdfc87e00cd0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ec7e7fa34698fe0d0aeabdfc87e00cd0, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_ec7e7fa34698fe0d0aeabdfc87e00cd0, type_description ,par_self, par_p, var_spec, var_decl, var_typename );

    // Release cached frame.
    if ( frame_ec7e7fa34698fe0d0aeabdfc87e00cd0 == cache_frame_ec7e7fa34698fe0d0aeabdfc87e00cd0 )
    {
        Py_DECREF( frame_ec7e7fa34698fe0d0aeabdfc87e00cd0 );
    }
    cache_frame_ec7e7fa34698fe0d0aeabdfc87e00cd0 = NULL;

    assertFrameObject( frame_ec7e7fa34698fe0d0aeabdfc87e00cd0 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_85_p_parameter_declaration_2 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_spec );
    var_spec = NULL;

    Py_XDECREF( var_decl );
    var_decl = NULL;

    Py_XDECREF( var_typename );
    var_typename = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_spec );
    var_spec = NULL;

    Py_XDECREF( var_decl );
    var_decl = NULL;

    Py_XDECREF( var_typename );
    var_typename = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_85_p_parameter_declaration_2 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_86_p_identifier_list( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscribed_2;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subscript_2;
    int tmp_ass_subscript_res_1;
    int tmp_ass_subscript_res_2;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_ass_subvalue_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_list_element_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscribed_name_5;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    PyObject *tmp_subscript_name_5;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_867142bdf96c9102a846ef71dc64dcbc = NULL;

    struct Nuitka_FrameObject *frame_867142bdf96c9102a846ef71dc64dcbc;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_867142bdf96c9102a846ef71dc64dcbc, codeobj_867142bdf96c9102a846ef71dc64dcbc, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_867142bdf96c9102a846ef71dc64dcbc = cache_frame_867142bdf96c9102a846ef71dc64dcbc;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_867142bdf96c9102a846ef71dc64dcbc );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_867142bdf96c9102a846ef71dc64dcbc ) == 2 ); // Frame stack

    // Framed code:
    tmp_len_arg_1 = par_p;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1235;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_pos_2;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 1235;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1236;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_ParamList );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1236;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = PyList_New( 1 );
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1236;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_list_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_list_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1236;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyList_SET_ITEM( tmp_args_element_name_1, 0, tmp_list_element_1 );
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1236;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_1;
    tmp_source_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_source_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1236;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_coord );
    Py_DECREF( tmp_source_name_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1236;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_867142bdf96c9102a846ef71dc64dcbc->m_frame.f_lineno = 1236;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1236;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1236;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1236;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto branch_end_1;
    branch_no_1:;
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1238;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_1;
    tmp_source_name_4 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_source_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1238;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_params );
    Py_DECREF( tmp_source_name_4 );
    if ( tmp_source_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1238;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_append );
    Py_DECREF( tmp_source_name_3 );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1238;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_4 = par_p;

    if ( tmp_subscribed_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1238;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_4 = const_int_pos_3;
    tmp_args_element_name_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_4 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1238;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_867142bdf96c9102a846ef71dc64dcbc->m_frame.f_lineno = 1238;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1238;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_subscribed_name_5 = par_p;

    if ( tmp_subscribed_name_5 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1239;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_5 = const_int_pos_1;
    tmp_ass_subvalue_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_5, tmp_subscript_name_5 );
    if ( tmp_ass_subvalue_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1239;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_2 = par_p;

    if ( tmp_ass_subscribed_2 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1239;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_2 = const_int_0;
    tmp_ass_subscript_res_2 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_2, tmp_ass_subscript_2, 0, tmp_ass_subvalue_2 );
    Py_DECREF( tmp_ass_subvalue_2 );
    if ( tmp_ass_subscript_res_2 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1239;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_867142bdf96c9102a846ef71dc64dcbc );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_867142bdf96c9102a846ef71dc64dcbc );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_867142bdf96c9102a846ef71dc64dcbc, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_867142bdf96c9102a846ef71dc64dcbc->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_867142bdf96c9102a846ef71dc64dcbc, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_867142bdf96c9102a846ef71dc64dcbc, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_867142bdf96c9102a846ef71dc64dcbc == cache_frame_867142bdf96c9102a846ef71dc64dcbc )
    {
        Py_DECREF( frame_867142bdf96c9102a846ef71dc64dcbc );
    }
    cache_frame_867142bdf96c9102a846ef71dc64dcbc = NULL;

    assertFrameObject( frame_867142bdf96c9102a846ef71dc64dcbc );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_86_p_identifier_list );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_86_p_identifier_list );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_87_p_initializer_1( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_return_value;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_3286b72abfbf9883a8da41cbb843f21f = NULL;

    struct Nuitka_FrameObject *frame_3286b72abfbf9883a8da41cbb843f21f;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3286b72abfbf9883a8da41cbb843f21f, codeobj_3286b72abfbf9883a8da41cbb843f21f, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_3286b72abfbf9883a8da41cbb843f21f = cache_frame_3286b72abfbf9883a8da41cbb843f21f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3286b72abfbf9883a8da41cbb843f21f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3286b72abfbf9883a8da41cbb843f21f ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1244;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1244;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1244;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3286b72abfbf9883a8da41cbb843f21f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3286b72abfbf9883a8da41cbb843f21f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3286b72abfbf9883a8da41cbb843f21f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3286b72abfbf9883a8da41cbb843f21f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3286b72abfbf9883a8da41cbb843f21f, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_3286b72abfbf9883a8da41cbb843f21f, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_3286b72abfbf9883a8da41cbb843f21f == cache_frame_3286b72abfbf9883a8da41cbb843f21f )
    {
        Py_DECREF( frame_3286b72abfbf9883a8da41cbb843f21f );
    }
    cache_frame_3286b72abfbf9883a8da41cbb843f21f = NULL;

    assertFrameObject( frame_3286b72abfbf9883a8da41cbb843f21f );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_87_p_initializer_1 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_87_p_initializer_1 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_88_p_initializer_2( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscribed_2;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subscript_2;
    int tmp_ass_subscript_res_1;
    int tmp_ass_subscript_res_2;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_ass_subvalue_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    bool tmp_is_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    static struct Nuitka_FrameObject *cache_frame_2981cd55a1d00047fb71fd4a3e5caa1e = NULL;

    struct Nuitka_FrameObject *frame_2981cd55a1d00047fb71fd4a3e5caa1e;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2981cd55a1d00047fb71fd4a3e5caa1e, codeobj_2981cd55a1d00047fb71fd4a3e5caa1e, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_2981cd55a1d00047fb71fd4a3e5caa1e = cache_frame_2981cd55a1d00047fb71fd4a3e5caa1e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2981cd55a1d00047fb71fd4a3e5caa1e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2981cd55a1d00047fb71fd4a3e5caa1e ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_2;
    tmp_compare_left_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1250;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1251;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_InitList );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1251;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = PyList_New( 0 );
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1251;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1251;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = par_p;

    if ( tmp_args_element_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1251;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = const_int_pos_1;
    frame_2981cd55a1d00047fb71fd4a3e5caa1e->m_frame.f_lineno = 1251;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_args_element_name_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1251;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_2981cd55a1d00047fb71fd4a3e5caa1e->m_frame.f_lineno = 1251;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1251;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1251;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1251;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto branch_end_1;
    branch_no_1:;
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1253;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_2;
    tmp_ass_subvalue_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_ass_subvalue_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1253;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_2 = par_p;

    if ( tmp_ass_subscribed_2 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1253;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_2 = const_int_0;
    tmp_ass_subscript_res_2 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_2, tmp_ass_subscript_2, 0, tmp_ass_subvalue_2 );
    Py_DECREF( tmp_ass_subvalue_2 );
    if ( tmp_ass_subscript_res_2 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1253;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2981cd55a1d00047fb71fd4a3e5caa1e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2981cd55a1d00047fb71fd4a3e5caa1e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2981cd55a1d00047fb71fd4a3e5caa1e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2981cd55a1d00047fb71fd4a3e5caa1e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2981cd55a1d00047fb71fd4a3e5caa1e, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_2981cd55a1d00047fb71fd4a3e5caa1e, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_2981cd55a1d00047fb71fd4a3e5caa1e == cache_frame_2981cd55a1d00047fb71fd4a3e5caa1e )
    {
        Py_DECREF( frame_2981cd55a1d00047fb71fd4a3e5caa1e );
    }
    cache_frame_2981cd55a1d00047fb71fd4a3e5caa1e = NULL;

    assertFrameObject( frame_2981cd55a1d00047fb71fd4a3e5caa1e );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_88_p_initializer_2 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_88_p_initializer_2 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_89_p_initializer_list( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *var_init = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscribed_2;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subscript_2;
    int tmp_ass_subscript_res_1;
    int tmp_ass_subscript_res_2;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_ass_subvalue_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    bool tmp_is_1;
    bool tmp_is_2;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_list_element_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscribed_name_5;
    PyObject *tmp_subscribed_name_6;
    PyObject *tmp_subscribed_name_7;
    PyObject *tmp_subscribed_name_8;
    PyObject *tmp_subscribed_name_9;
    PyObject *tmp_subscribed_name_10;
    PyObject *tmp_subscribed_name_11;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    PyObject *tmp_subscript_name_5;
    PyObject *tmp_subscript_name_6;
    PyObject *tmp_subscript_name_7;
    PyObject *tmp_subscript_name_8;
    PyObject *tmp_subscript_name_9;
    PyObject *tmp_subscript_name_10;
    PyObject *tmp_subscript_name_11;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_7bdedbef7a00776795107daa1bc963d5 = NULL;

    struct Nuitka_FrameObject *frame_7bdedbef7a00776795107daa1bc963d5;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7bdedbef7a00776795107daa1bc963d5, codeobj_7bdedbef7a00776795107daa1bc963d5, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_7bdedbef7a00776795107daa1bc963d5 = cache_frame_7bdedbef7a00776795107daa1bc963d5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7bdedbef7a00776795107daa1bc963d5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7bdedbef7a00776795107daa1bc963d5 ) == 2 ); // Frame stack

    // Framed code:
    tmp_len_arg_1 = par_p;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1259;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_pos_3;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 1259;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1260;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_compare_left_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_compare_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1260;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_2 = Py_None;
    tmp_is_1 = ( tmp_compare_left_2 == tmp_compare_right_2 );
    Py_DECREF( tmp_compare_left_2 );
    if ( tmp_is_1 )
    {
        goto condexpr_true_1;
    }
    else
    {
        goto condexpr_false_1;
    }
    condexpr_true_1:;
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1260;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_2;
    tmp_assign_source_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1260;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    goto condexpr_end_1;
    condexpr_false_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1260;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_NamedInitializer );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1260;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1260;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_1;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1260;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_4 = par_p;

    if ( tmp_subscribed_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1260;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_4 = const_int_pos_2;
    tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_4 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1260;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    frame_7bdedbef7a00776795107daa1bc963d5->m_frame.f_lineno = 1260;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1260;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    condexpr_end_1:;
    assert( var_init == NULL );
    var_init = tmp_assign_source_1;

    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1261;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_InitList );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1261;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = PyList_New( 1 );
    tmp_list_element_1 = var_init;

    if ( tmp_list_element_1 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "init" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1261;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_list_element_1 );
    PyList_SET_ITEM( tmp_args_element_name_3, 0, tmp_list_element_1 );
    tmp_subscribed_name_5 = par_p;

    if ( tmp_subscribed_name_5 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1261;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_5 = const_int_pos_2;
    tmp_source_name_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_5, tmp_subscript_name_5 );
    if ( tmp_source_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );

        exception_lineno = 1261;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_coord );
    Py_DECREF( tmp_source_name_3 );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );

        exception_lineno = 1261;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    frame_7bdedbef7a00776795107daa1bc963d5->m_frame.f_lineno = 1261;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1261;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1261;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1261;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    goto branch_end_1;
    branch_no_1:;
    tmp_subscribed_name_6 = par_p;

    if ( tmp_subscribed_name_6 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1263;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_6 = const_int_pos_3;
    tmp_compare_left_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_6, tmp_subscript_name_6 );
    if ( tmp_compare_left_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1263;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_3 = Py_None;
    tmp_is_2 = ( tmp_compare_left_3 == tmp_compare_right_3 );
    Py_DECREF( tmp_compare_left_3 );
    if ( tmp_is_2 )
    {
        goto condexpr_true_2;
    }
    else
    {
        goto condexpr_false_2;
    }
    condexpr_true_2:;
    tmp_subscribed_name_7 = par_p;

    if ( tmp_subscribed_name_7 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1263;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_7 = const_int_pos_4;
    tmp_assign_source_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_7, tmp_subscript_name_7 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1263;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    goto condexpr_end_2;
    condexpr_false_2:;
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1263;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_NamedInitializer );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1263;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_8 = par_p;

    if ( tmp_subscribed_name_8 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1263;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_8 = const_int_pos_3;
    tmp_args_element_name_5 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_8, tmp_subscript_name_8 );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1263;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_9 = par_p;

    if ( tmp_subscribed_name_9 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1263;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_9 = const_int_pos_4;
    tmp_args_element_name_6 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_9, tmp_subscript_name_9 );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );

        exception_lineno = 1263;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    frame_7bdedbef7a00776795107daa1bc963d5->m_frame.f_lineno = 1263;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_5 );
    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1263;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    condexpr_end_2:;
    assert( var_init == NULL );
    var_init = tmp_assign_source_2;

    tmp_subscribed_name_10 = par_p;

    if ( tmp_subscribed_name_10 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1264;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_10 = const_int_pos_1;
    tmp_source_name_6 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_10, tmp_subscript_name_10 );
    if ( tmp_source_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1264;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_exprs );
    Py_DECREF( tmp_source_name_6 );
    if ( tmp_source_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1264;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_append );
    Py_DECREF( tmp_source_name_5 );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1264;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_7 = var_init;

    if ( tmp_args_element_name_7 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "init" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1264;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    frame_7bdedbef7a00776795107daa1bc963d5->m_frame.f_lineno = 1264;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1264;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_subscribed_name_11 = par_p;

    if ( tmp_subscribed_name_11 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1265;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_11 = const_int_pos_1;
    tmp_ass_subvalue_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_11, tmp_subscript_name_11 );
    if ( tmp_ass_subvalue_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1265;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_2 = par_p;

    if ( tmp_ass_subscribed_2 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1265;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_2 = const_int_0;
    tmp_ass_subscript_res_2 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_2, tmp_ass_subscript_2, 0, tmp_ass_subvalue_2 );
    Py_DECREF( tmp_ass_subvalue_2 );
    if ( tmp_ass_subscript_res_2 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1265;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7bdedbef7a00776795107daa1bc963d5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7bdedbef7a00776795107daa1bc963d5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7bdedbef7a00776795107daa1bc963d5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7bdedbef7a00776795107daa1bc963d5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7bdedbef7a00776795107daa1bc963d5, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_7bdedbef7a00776795107daa1bc963d5, type_description ,par_self, par_p, var_init );

    // Release cached frame.
    if ( frame_7bdedbef7a00776795107daa1bc963d5 == cache_frame_7bdedbef7a00776795107daa1bc963d5 )
    {
        Py_DECREF( frame_7bdedbef7a00776795107daa1bc963d5 );
    }
    cache_frame_7bdedbef7a00776795107daa1bc963d5 = NULL;

    assertFrameObject( frame_7bdedbef7a00776795107daa1bc963d5 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_89_p_initializer_list );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_init );
    var_init = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_init );
    var_init = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_89_p_initializer_list );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_90_p_designation( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_return_value;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_85094ef0f04670a999427ff66a78ee6f = NULL;

    struct Nuitka_FrameObject *frame_85094ef0f04670a999427ff66a78ee6f;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_85094ef0f04670a999427ff66a78ee6f, codeobj_85094ef0f04670a999427ff66a78ee6f, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_85094ef0f04670a999427ff66a78ee6f = cache_frame_85094ef0f04670a999427ff66a78ee6f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_85094ef0f04670a999427ff66a78ee6f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_85094ef0f04670a999427ff66a78ee6f ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1270;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1270;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1270;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_85094ef0f04670a999427ff66a78ee6f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_85094ef0f04670a999427ff66a78ee6f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_85094ef0f04670a999427ff66a78ee6f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_85094ef0f04670a999427ff66a78ee6f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_85094ef0f04670a999427ff66a78ee6f, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_85094ef0f04670a999427ff66a78ee6f, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_85094ef0f04670a999427ff66a78ee6f == cache_frame_85094ef0f04670a999427ff66a78ee6f )
    {
        Py_DECREF( frame_85094ef0f04670a999427ff66a78ee6f );
    }
    cache_frame_85094ef0f04670a999427ff66a78ee6f = NULL;

    assertFrameObject( frame_85094ef0f04670a999427ff66a78ee6f );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_90_p_designation );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_90_p_designation );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_91_p_designator_list( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_list_element_1;
    PyObject *tmp_list_element_2;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    static struct Nuitka_FrameObject *cache_frame_52eb0d57f6175eba75633633bbe54ef2 = NULL;

    struct Nuitka_FrameObject *frame_52eb0d57f6175eba75633633bbe54ef2;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_52eb0d57f6175eba75633633bbe54ef2, codeobj_52eb0d57f6175eba75633633bbe54ef2, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_52eb0d57f6175eba75633633bbe54ef2 = cache_frame_52eb0d57f6175eba75633633bbe54ef2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_52eb0d57f6175eba75633633bbe54ef2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_52eb0d57f6175eba75633633bbe54ef2 ) == 2 ); // Frame stack

    // Framed code:
    tmp_len_arg_1 = par_p;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1279;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_pos_2;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 1279;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto condexpr_true_1;
    }
    else
    {
        goto condexpr_false_1;
    }
    condexpr_true_1:;
    tmp_ass_subvalue_1 = PyList_New( 1 );
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1279;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_list_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_list_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_1 );

        exception_lineno = 1279;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyList_SET_ITEM( tmp_ass_subvalue_1, 0, tmp_list_element_1 );
    goto condexpr_end_1;
    condexpr_false_1:;
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1279;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_1;
    tmp_left_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_left_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1279;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_1 = PyList_New( 1 );
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_left_name_1 );
        Py_DECREF( tmp_right_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1279;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_2;
    tmp_list_element_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_list_element_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_1 );
        Py_DECREF( tmp_right_name_1 );

        exception_lineno = 1279;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyList_SET_ITEM( tmp_right_name_1, 0, tmp_list_element_2 );
    tmp_ass_subvalue_1 = BINARY_OPERATION_ADD( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_left_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1279;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    condexpr_end_1:;
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1279;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1279;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_52eb0d57f6175eba75633633bbe54ef2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_52eb0d57f6175eba75633633bbe54ef2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_52eb0d57f6175eba75633633bbe54ef2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_52eb0d57f6175eba75633633bbe54ef2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_52eb0d57f6175eba75633633bbe54ef2, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_52eb0d57f6175eba75633633bbe54ef2, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_52eb0d57f6175eba75633633bbe54ef2 == cache_frame_52eb0d57f6175eba75633633bbe54ef2 )
    {
        Py_DECREF( frame_52eb0d57f6175eba75633633bbe54ef2 );
    }
    cache_frame_52eb0d57f6175eba75633633bbe54ef2 = NULL;

    assertFrameObject( frame_52eb0d57f6175eba75633633bbe54ef2 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_91_p_designator_list );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_91_p_designator_list );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_92_p_designator( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_return_value;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_c0feafe8bd77b3b88cd6575e93ee8a8a = NULL;

    struct Nuitka_FrameObject *frame_c0feafe8bd77b3b88cd6575e93ee8a8a;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_c0feafe8bd77b3b88cd6575e93ee8a8a, codeobj_c0feafe8bd77b3b88cd6575e93ee8a8a, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_c0feafe8bd77b3b88cd6575e93ee8a8a = cache_frame_c0feafe8bd77b3b88cd6575e93ee8a8a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_c0feafe8bd77b3b88cd6575e93ee8a8a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_c0feafe8bd77b3b88cd6575e93ee8a8a ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_2;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1285;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1285;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1285;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c0feafe8bd77b3b88cd6575e93ee8a8a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_c0feafe8bd77b3b88cd6575e93ee8a8a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_c0feafe8bd77b3b88cd6575e93ee8a8a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_c0feafe8bd77b3b88cd6575e93ee8a8a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_c0feafe8bd77b3b88cd6575e93ee8a8a, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_c0feafe8bd77b3b88cd6575e93ee8a8a, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_c0feafe8bd77b3b88cd6575e93ee8a8a == cache_frame_c0feafe8bd77b3b88cd6575e93ee8a8a )
    {
        Py_DECREF( frame_c0feafe8bd77b3b88cd6575e93ee8a8a );
    }
    cache_frame_c0feafe8bd77b3b88cd6575e93ee8a8a = NULL;

    assertFrameObject( frame_c0feafe8bd77b3b88cd6575e93ee8a8a );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_92_p_designator );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_92_p_designator );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_93_p_type_name( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *var_typename = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_key_4;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_dict_value_4;
    PyObject *tmp_kw_name_1;
    int tmp_or_left_truth_1;
    PyObject *tmp_or_left_value_1;
    PyObject *tmp_or_right_value_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscribed_name_5;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    PyObject *tmp_subscript_name_5;
    static struct Nuitka_FrameObject *cache_frame_febe702af8a1cd2b2bf16ba9e9fd3f58 = NULL;

    struct Nuitka_FrameObject *frame_febe702af8a1cd2b2bf16ba9e9fd3f58;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_febe702af8a1cd2b2bf16ba9e9fd3f58, codeobj_febe702af8a1cd2b2bf16ba9e9fd3f58, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_febe702af8a1cd2b2bf16ba9e9fd3f58 = cache_frame_febe702af8a1cd2b2bf16ba9e9fd3f58;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_febe702af8a1cd2b2bf16ba9e9fd3f58 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_febe702af8a1cd2b2bf16ba9e9fd3f58 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1290;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_Typename );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1290;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_1 = _PyDict_NewPresized( 4 );
    tmp_dict_key_1 = const_str_plain_name;
    tmp_dict_value_1 = const_str_empty;
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_quals;
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1292;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_subscribed_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_1 );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1292;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_2 = const_str_plain_qual;
    tmp_dict_value_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_2 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_dict_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1292;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    Py_DECREF( tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_3 = const_str_plain_type;
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1293;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_2;
    tmp_or_left_value_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_or_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1293;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
    if ( tmp_or_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_or_left_value_1 );

        exception_lineno = 1293;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_or_left_truth_1 == 1 )
    {
        goto or_left_1;
    }
    else
    {
        goto or_right_1;
    }
    or_right_1:;
    Py_DECREF( tmp_or_left_value_1 );
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_called_instance_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1293;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    frame_febe702af8a1cd2b2bf16ba9e9fd3f58->m_frame.f_lineno = 1293;
    tmp_or_right_value_1 = CALL_METHOD_WITH_ARGS3( tmp_called_instance_1, const_str_plain_TypeDecl, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

    if ( tmp_or_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1293;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_dict_value_3 = tmp_or_right_value_1;
    goto or_end_1;
    or_left_1:;
    tmp_dict_value_3 = tmp_or_left_value_1;
    or_end_1:;
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3 );
    Py_DECREF( tmp_dict_value_3 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_4 = const_str_plain_coord;
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1294;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1294;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_p;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1294;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = const_int_pos_2;
    frame_febe702af8a1cd2b2bf16ba9e9fd3f58->m_frame.f_lineno = 1294;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_dict_value_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_dict_value_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1294;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_4, tmp_dict_value_4 );
    Py_DECREF( tmp_dict_value_4 );
    assert( !(tmp_res != 0) );
    frame_febe702af8a1cd2b2bf16ba9e9fd3f58->m_frame.f_lineno = 1290;
    tmp_assign_source_1 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1290;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_typename == NULL );
    var_typename = tmp_assign_source_1;

    tmp_source_name_3 = par_self;

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1296;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__fix_decl_name_type );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1296;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = var_typename;

    if ( tmp_args_element_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "typename" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1296;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscribed_name_5 = par_p;

    if ( tmp_subscribed_name_5 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1296;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_4 = const_int_pos_1;
    tmp_subscribed_name_4 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_5, tmp_subscript_name_4 );
    if ( tmp_subscribed_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1296;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_5 = const_str_plain_type;
    tmp_args_element_name_4 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_5 );
    Py_DECREF( tmp_subscribed_name_4 );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1296;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    frame_febe702af8a1cd2b2bf16ba9e9fd3f58->m_frame.f_lineno = 1296;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1296;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1296;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1296;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_febe702af8a1cd2b2bf16ba9e9fd3f58 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_febe702af8a1cd2b2bf16ba9e9fd3f58 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_febe702af8a1cd2b2bf16ba9e9fd3f58, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_febe702af8a1cd2b2bf16ba9e9fd3f58->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_febe702af8a1cd2b2bf16ba9e9fd3f58, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_febe702af8a1cd2b2bf16ba9e9fd3f58, type_description ,par_self, par_p, var_typename );

    // Release cached frame.
    if ( frame_febe702af8a1cd2b2bf16ba9e9fd3f58 == cache_frame_febe702af8a1cd2b2bf16ba9e9fd3f58 )
    {
        Py_DECREF( frame_febe702af8a1cd2b2bf16ba9e9fd3f58 );
    }
    cache_frame_febe702af8a1cd2b2bf16ba9e9fd3f58 = NULL;

    assertFrameObject( frame_febe702af8a1cd2b2bf16ba9e9fd3f58 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_93_p_type_name );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_typename );
    var_typename = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_typename );
    var_typename = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_93_p_type_name );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_94_p_abstract_declarator_1( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *var_dummytype = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_kw_name_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_ac70248d42fae48a157ba1db8b5e4a7b = NULL;

    struct Nuitka_FrameObject *frame_ac70248d42fae48a157ba1db8b5e4a7b;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ac70248d42fae48a157ba1db8b5e4a7b, codeobj_ac70248d42fae48a157ba1db8b5e4a7b, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_ac70248d42fae48a157ba1db8b5e4a7b = cache_frame_ac70248d42fae48a157ba1db8b5e4a7b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ac70248d42fae48a157ba1db8b5e4a7b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ac70248d42fae48a157ba1db8b5e4a7b ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1301;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    frame_ac70248d42fae48a157ba1db8b5e4a7b->m_frame.f_lineno = 1301;
    tmp_assign_source_1 = CALL_METHOD_WITH_ARGS3( tmp_called_instance_1, const_str_plain_TypeDecl, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1301;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_dummytype == NULL );
    var_dummytype = tmp_assign_source_1;

    tmp_source_name_1 = par_self;

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1302;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__type_modify_decl );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1302;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_1 = _PyDict_NewPresized( 2 );
    tmp_dict_key_1 = const_str_plain_decl;
    tmp_dict_value_1 = var_dummytype;

    if ( tmp_dict_value_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "dummytype" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1303;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_modifier;
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1304;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_dict_value_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_dict_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1304;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    Py_DECREF( tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    frame_ac70248d42fae48a157ba1db8b5e4a7b->m_frame.f_lineno = 1302;
    tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1302;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1302;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1302;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ac70248d42fae48a157ba1db8b5e4a7b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ac70248d42fae48a157ba1db8b5e4a7b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ac70248d42fae48a157ba1db8b5e4a7b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ac70248d42fae48a157ba1db8b5e4a7b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ac70248d42fae48a157ba1db8b5e4a7b, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_ac70248d42fae48a157ba1db8b5e4a7b, type_description ,par_self, par_p, var_dummytype );

    // Release cached frame.
    if ( frame_ac70248d42fae48a157ba1db8b5e4a7b == cache_frame_ac70248d42fae48a157ba1db8b5e4a7b )
    {
        Py_DECREF( frame_ac70248d42fae48a157ba1db8b5e4a7b );
    }
    cache_frame_ac70248d42fae48a157ba1db8b5e4a7b = NULL;

    assertFrameObject( frame_ac70248d42fae48a157ba1db8b5e4a7b );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_94_p_abstract_declarator_1 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_dummytype );
    var_dummytype = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_dummytype );
    var_dummytype = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_94_p_abstract_declarator_1 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_95_p_abstract_declarator_2( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    static struct Nuitka_FrameObject *cache_frame_51b554cea9d0e7f1e3adf8f99cc405e4 = NULL;

    struct Nuitka_FrameObject *frame_51b554cea9d0e7f1e3adf8f99cc405e4;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_51b554cea9d0e7f1e3adf8f99cc405e4, codeobj_51b554cea9d0e7f1e3adf8f99cc405e4, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_51b554cea9d0e7f1e3adf8f99cc405e4 = cache_frame_51b554cea9d0e7f1e3adf8f99cc405e4;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_51b554cea9d0e7f1e3adf8f99cc405e4 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_51b554cea9d0e7f1e3adf8f99cc405e4 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__type_modify_decl );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1309;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1309;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_2;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1309;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1309;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_1;
    tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1309;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_51b554cea9d0e7f1e3adf8f99cc405e4->m_frame.f_lineno = 1309;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1309;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1309;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1309;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_51b554cea9d0e7f1e3adf8f99cc405e4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_51b554cea9d0e7f1e3adf8f99cc405e4 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_51b554cea9d0e7f1e3adf8f99cc405e4, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_51b554cea9d0e7f1e3adf8f99cc405e4->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_51b554cea9d0e7f1e3adf8f99cc405e4, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_51b554cea9d0e7f1e3adf8f99cc405e4, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_51b554cea9d0e7f1e3adf8f99cc405e4 == cache_frame_51b554cea9d0e7f1e3adf8f99cc405e4 )
    {
        Py_DECREF( frame_51b554cea9d0e7f1e3adf8f99cc405e4 );
    }
    cache_frame_51b554cea9d0e7f1e3adf8f99cc405e4 = NULL;

    assertFrameObject( frame_51b554cea9d0e7f1e3adf8f99cc405e4 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_95_p_abstract_declarator_2 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_95_p_abstract_declarator_2 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_96_p_abstract_declarator_3( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_return_value;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_dbbbd791f6d9a09e74dbfc14504f2e29 = NULL;

    struct Nuitka_FrameObject *frame_dbbbd791f6d9a09e74dbfc14504f2e29;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_dbbbd791f6d9a09e74dbfc14504f2e29, codeobj_dbbbd791f6d9a09e74dbfc14504f2e29, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_dbbbd791f6d9a09e74dbfc14504f2e29 = cache_frame_dbbbd791f6d9a09e74dbfc14504f2e29;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_dbbbd791f6d9a09e74dbfc14504f2e29 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_dbbbd791f6d9a09e74dbfc14504f2e29 ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1314;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1314;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1314;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dbbbd791f6d9a09e74dbfc14504f2e29 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dbbbd791f6d9a09e74dbfc14504f2e29 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_dbbbd791f6d9a09e74dbfc14504f2e29, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_dbbbd791f6d9a09e74dbfc14504f2e29->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_dbbbd791f6d9a09e74dbfc14504f2e29, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_dbbbd791f6d9a09e74dbfc14504f2e29, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_dbbbd791f6d9a09e74dbfc14504f2e29 == cache_frame_dbbbd791f6d9a09e74dbfc14504f2e29 )
    {
        Py_DECREF( frame_dbbbd791f6d9a09e74dbfc14504f2e29 );
    }
    cache_frame_dbbbd791f6d9a09e74dbfc14504f2e29 = NULL;

    assertFrameObject( frame_dbbbd791f6d9a09e74dbfc14504f2e29 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_96_p_abstract_declarator_3 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_96_p_abstract_declarator_3 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_97_p_direct_abstract_declarator_1( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_return_value;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_5257b1cf3d2353a8c350ec764d19c8d2 = NULL;

    struct Nuitka_FrameObject *frame_5257b1cf3d2353a8c350ec764d19c8d2;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5257b1cf3d2353a8c350ec764d19c8d2, codeobj_5257b1cf3d2353a8c350ec764d19c8d2, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_5257b1cf3d2353a8c350ec764d19c8d2 = cache_frame_5257b1cf3d2353a8c350ec764d19c8d2;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5257b1cf3d2353a8c350ec764d19c8d2 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5257b1cf3d2353a8c350ec764d19c8d2 ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_2;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1323;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1323;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1323;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5257b1cf3d2353a8c350ec764d19c8d2 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5257b1cf3d2353a8c350ec764d19c8d2 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5257b1cf3d2353a8c350ec764d19c8d2, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5257b1cf3d2353a8c350ec764d19c8d2->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5257b1cf3d2353a8c350ec764d19c8d2, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_5257b1cf3d2353a8c350ec764d19c8d2, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_5257b1cf3d2353a8c350ec764d19c8d2 == cache_frame_5257b1cf3d2353a8c350ec764d19c8d2 )
    {
        Py_DECREF( frame_5257b1cf3d2353a8c350ec764d19c8d2 );
    }
    cache_frame_5257b1cf3d2353a8c350ec764d19c8d2 = NULL;

    assertFrameObject( frame_5257b1cf3d2353a8c350ec764d19c8d2 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_97_p_direct_abstract_declarator_1 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_97_p_direct_abstract_declarator_1 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_98_p_direct_abstract_declarator_2( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *var_arr = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_key_4;
    PyObject *tmp_dict_key_5;
    PyObject *tmp_dict_key_6;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_dict_value_4;
    PyObject *tmp_dict_value_5;
    PyObject *tmp_dict_value_6;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_kw_name_2;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    static struct Nuitka_FrameObject *cache_frame_f10314a14c8ac1925cc08a640435747f = NULL;

    struct Nuitka_FrameObject *frame_f10314a14c8ac1925cc08a640435747f;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f10314a14c8ac1925cc08a640435747f, codeobj_f10314a14c8ac1925cc08a640435747f, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_f10314a14c8ac1925cc08a640435747f = cache_frame_f10314a14c8ac1925cc08a640435747f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f10314a14c8ac1925cc08a640435747f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f10314a14c8ac1925cc08a640435747f ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1328;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_ArrayDecl );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1328;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_1 = _PyDict_NewPresized( 4 );
    tmp_dict_key_1 = const_str_plain_type;
    tmp_dict_value_1 = Py_None;
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_dim;
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1330;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_3;
    tmp_dict_value_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_dict_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1330;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    Py_DECREF( tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_3 = const_str_plain_dim_quals;
    tmp_dict_value_3 = PyList_New( 0 );
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3 );
    Py_DECREF( tmp_dict_value_3 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_4 = const_str_plain_coord;
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1332;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_1;
    tmp_source_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_source_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1332;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_dict_value_4 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_coord );
    Py_DECREF( tmp_source_name_2 );
    if ( tmp_dict_value_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1332;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_4, tmp_dict_value_4 );
    Py_DECREF( tmp_dict_value_4 );
    assert( !(tmp_res != 0) );
    frame_f10314a14c8ac1925cc08a640435747f->m_frame.f_lineno = 1328;
    tmp_assign_source_1 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1328;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_arr == NULL );
    var_arr = tmp_assign_source_1;

    tmp_source_name_3 = par_self;

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1334;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__type_modify_decl );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1334;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_2 = _PyDict_NewPresized( 2 );
    tmp_dict_key_5 = const_str_plain_decl;
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1334;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_1;
    tmp_dict_value_5 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_dict_value_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_2 );

        exception_lineno = 1334;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_5, tmp_dict_value_5 );
    Py_DECREF( tmp_dict_value_5 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_6 = const_str_plain_modifier;
    tmp_dict_value_6 = var_arr;

    if ( tmp_dict_value_6 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "arr" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1334;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_6, tmp_dict_value_6 );
    assert( !(tmp_res != 0) );
    frame_f10314a14c8ac1925cc08a640435747f->m_frame.f_lineno = 1334;
    tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_2, tmp_kw_name_2 );
    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_kw_name_2 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1334;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1334;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1334;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f10314a14c8ac1925cc08a640435747f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f10314a14c8ac1925cc08a640435747f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f10314a14c8ac1925cc08a640435747f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f10314a14c8ac1925cc08a640435747f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f10314a14c8ac1925cc08a640435747f, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_f10314a14c8ac1925cc08a640435747f, type_description ,par_self, par_p, var_arr );

    // Release cached frame.
    if ( frame_f10314a14c8ac1925cc08a640435747f == cache_frame_f10314a14c8ac1925cc08a640435747f )
    {
        Py_DECREF( frame_f10314a14c8ac1925cc08a640435747f );
    }
    cache_frame_f10314a14c8ac1925cc08a640435747f = NULL;

    assertFrameObject( frame_f10314a14c8ac1925cc08a640435747f );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_98_p_direct_abstract_declarator_2 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_arr );
    var_arr = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_arr );
    var_arr = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_98_p_direct_abstract_declarator_2 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_99_p_direct_abstract_declarator_3( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_key_4;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_dict_value_4;
    PyObject *tmp_kw_name_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_5290c3915469426265e7f52d66a998a4 = NULL;

    struct Nuitka_FrameObject *frame_5290c3915469426265e7f52d66a998a4;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5290c3915469426265e7f52d66a998a4, codeobj_5290c3915469426265e7f52d66a998a4, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_5290c3915469426265e7f52d66a998a4 = cache_frame_5290c3915469426265e7f52d66a998a4;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5290c3915469426265e7f52d66a998a4 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5290c3915469426265e7f52d66a998a4 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1339;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_ArrayDecl );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1339;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_1 = _PyDict_NewPresized( 4 );
    tmp_dict_key_1 = const_str_plain_type;
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_called_instance_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1340;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    frame_5290c3915469426265e7f52d66a998a4->m_frame.f_lineno = 1340;
    tmp_dict_value_1 = CALL_METHOD_WITH_ARGS3( tmp_called_instance_1, const_str_plain_TypeDecl, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

    if ( tmp_dict_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1340;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    Py_DECREF( tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_dim;
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1341;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_2;
    tmp_dict_value_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_dict_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1341;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    Py_DECREF( tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_3 = const_str_plain_dim_quals;
    tmp_dict_value_3 = PyList_New( 0 );
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3 );
    Py_DECREF( tmp_dict_value_3 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_4 = const_str_plain_coord;
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1343;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1343;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_p;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1343;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = const_int_pos_1;
    frame_5290c3915469426265e7f52d66a998a4->m_frame.f_lineno = 1343;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_dict_value_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_dict_value_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1343;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_4, tmp_dict_value_4 );
    Py_DECREF( tmp_dict_value_4 );
    assert( !(tmp_res != 0) );
    frame_5290c3915469426265e7f52d66a998a4->m_frame.f_lineno = 1339;
    tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1339;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1339;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1339;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5290c3915469426265e7f52d66a998a4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5290c3915469426265e7f52d66a998a4 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5290c3915469426265e7f52d66a998a4, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5290c3915469426265e7f52d66a998a4->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5290c3915469426265e7f52d66a998a4, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_5290c3915469426265e7f52d66a998a4, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_5290c3915469426265e7f52d66a998a4 == cache_frame_5290c3915469426265e7f52d66a998a4 )
    {
        Py_DECREF( frame_5290c3915469426265e7f52d66a998a4 );
    }
    cache_frame_5290c3915469426265e7f52d66a998a4 = NULL;

    assertFrameObject( frame_5290c3915469426265e7f52d66a998a4 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_99_p_direct_abstract_declarator_3 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_99_p_direct_abstract_declarator_3 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_100_p_direct_abstract_declarator_4( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *var_arr = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_key_4;
    PyObject *tmp_dict_key_5;
    PyObject *tmp_dict_key_6;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_dict_value_4;
    PyObject *tmp_dict_value_5;
    PyObject *tmp_dict_value_6;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_kw_name_2;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    static struct Nuitka_FrameObject *cache_frame_1689f9118a658d2fccef32175084540f = NULL;

    struct Nuitka_FrameObject *frame_1689f9118a658d2fccef32175084540f;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1689f9118a658d2fccef32175084540f, codeobj_1689f9118a658d2fccef32175084540f, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_1689f9118a658d2fccef32175084540f = cache_frame_1689f9118a658d2fccef32175084540f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1689f9118a658d2fccef32175084540f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1689f9118a658d2fccef32175084540f ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1348;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_ArrayDecl );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1348;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_1 = _PyDict_NewPresized( 4 );
    tmp_dict_key_1 = const_str_plain_type;
    tmp_dict_value_1 = Py_None;
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_dim;
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1350;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_ID );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1350;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1350;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_3;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1350;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_self;

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1350;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__token_coord );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1350;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = par_p;

    if ( tmp_args_element_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1350;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = const_int_pos_3;
    frame_1689f9118a658d2fccef32175084540f->m_frame.f_lineno = 1350;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_args_element_name_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1350;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    frame_1689f9118a658d2fccef32175084540f->m_frame.f_lineno = 1350;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_dict_value_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_dict_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1350;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    Py_DECREF( tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_3 = const_str_plain_dim_quals;
    tmp_dict_value_3 = PyList_New( 0 );
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3 );
    Py_DECREF( tmp_dict_value_3 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_4 = const_str_plain_coord;
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1352;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_1;
    tmp_source_name_4 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_source_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1352;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_dict_value_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_coord );
    Py_DECREF( tmp_source_name_4 );
    if ( tmp_dict_value_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1352;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_4, tmp_dict_value_4 );
    Py_DECREF( tmp_dict_value_4 );
    assert( !(tmp_res != 0) );
    frame_1689f9118a658d2fccef32175084540f->m_frame.f_lineno = 1348;
    tmp_assign_source_1 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1348;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_arr == NULL );
    var_arr = tmp_assign_source_1;

    tmp_source_name_5 = par_self;

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1354;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__type_modify_decl );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1354;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_2 = _PyDict_NewPresized( 2 );
    tmp_dict_key_5 = const_str_plain_decl;
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1354;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_1;
    tmp_dict_value_5 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_dict_value_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_kw_name_2 );

        exception_lineno = 1354;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_5, tmp_dict_value_5 );
    Py_DECREF( tmp_dict_value_5 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_6 = const_str_plain_modifier;
    tmp_dict_value_6 = var_arr;

    if ( tmp_dict_value_6 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "arr" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1354;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_6, tmp_dict_value_6 );
    assert( !(tmp_res != 0) );
    frame_1689f9118a658d2fccef32175084540f->m_frame.f_lineno = 1354;
    tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_4, tmp_kw_name_2 );
    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_kw_name_2 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1354;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1354;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1354;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1689f9118a658d2fccef32175084540f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1689f9118a658d2fccef32175084540f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1689f9118a658d2fccef32175084540f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1689f9118a658d2fccef32175084540f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1689f9118a658d2fccef32175084540f, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_1689f9118a658d2fccef32175084540f, type_description ,par_self, par_p, var_arr );

    // Release cached frame.
    if ( frame_1689f9118a658d2fccef32175084540f == cache_frame_1689f9118a658d2fccef32175084540f )
    {
        Py_DECREF( frame_1689f9118a658d2fccef32175084540f );
    }
    cache_frame_1689f9118a658d2fccef32175084540f = NULL;

    assertFrameObject( frame_1689f9118a658d2fccef32175084540f );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_100_p_direct_abstract_declarator_4 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_arr );
    var_arr = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_arr );
    var_arr = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_100_p_direct_abstract_declarator_4 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_101_p_direct_abstract_declarator_5( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_key_4;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_dict_value_4;
    PyObject *tmp_kw_name_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_0ed528daae5194b75aa45f30a70a7d2a = NULL;

    struct Nuitka_FrameObject *frame_0ed528daae5194b75aa45f30a70a7d2a;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_0ed528daae5194b75aa45f30a70a7d2a, codeobj_0ed528daae5194b75aa45f30a70a7d2a, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_0ed528daae5194b75aa45f30a70a7d2a = cache_frame_0ed528daae5194b75aa45f30a70a7d2a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_0ed528daae5194b75aa45f30a70a7d2a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_0ed528daae5194b75aa45f30a70a7d2a ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1359;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_ArrayDecl );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1359;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_1 = _PyDict_NewPresized( 4 );
    tmp_dict_key_1 = const_str_plain_type;
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_called_instance_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1360;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    frame_0ed528daae5194b75aa45f30a70a7d2a->m_frame.f_lineno = 1360;
    tmp_dict_value_1 = CALL_METHOD_WITH_ARGS3( tmp_called_instance_1, const_str_plain_TypeDecl, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

    if ( tmp_dict_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1360;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    Py_DECREF( tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_dim;
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1361;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_ID );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1361;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1361;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_3;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1361;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_self;

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1361;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__token_coord );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1361;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = par_p;

    if ( tmp_args_element_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1361;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = const_int_pos_3;
    frame_0ed528daae5194b75aa45f30a70a7d2a->m_frame.f_lineno = 1361;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_args_element_name_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1361;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_0ed528daae5194b75aa45f30a70a7d2a->m_frame.f_lineno = 1361;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_dict_value_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_dict_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1361;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    Py_DECREF( tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_3 = const_str_plain_dim_quals;
    tmp_dict_value_3 = PyList_New( 0 );
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3 );
    Py_DECREF( tmp_dict_value_3 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_4 = const_str_plain_coord;
    tmp_source_name_4 = par_self;

    if ( tmp_source_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1363;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__token_coord );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1363;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_5 = par_p;

    if ( tmp_args_element_name_5 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_4 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1363;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_6 = const_int_pos_1;
    frame_0ed528daae5194b75aa45f30a70a7d2a->m_frame.f_lineno = 1363;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_dict_value_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    if ( tmp_dict_value_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1363;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_4, tmp_dict_value_4 );
    Py_DECREF( tmp_dict_value_4 );
    assert( !(tmp_res != 0) );
    frame_0ed528daae5194b75aa45f30a70a7d2a->m_frame.f_lineno = 1359;
    tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1359;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1359;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1359;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0ed528daae5194b75aa45f30a70a7d2a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_0ed528daae5194b75aa45f30a70a7d2a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_0ed528daae5194b75aa45f30a70a7d2a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_0ed528daae5194b75aa45f30a70a7d2a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_0ed528daae5194b75aa45f30a70a7d2a, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_0ed528daae5194b75aa45f30a70a7d2a, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_0ed528daae5194b75aa45f30a70a7d2a == cache_frame_0ed528daae5194b75aa45f30a70a7d2a )
    {
        Py_DECREF( frame_0ed528daae5194b75aa45f30a70a7d2a );
    }
    cache_frame_0ed528daae5194b75aa45f30a70a7d2a = NULL;

    assertFrameObject( frame_0ed528daae5194b75aa45f30a70a7d2a );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_101_p_direct_abstract_declarator_5 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_101_p_direct_abstract_declarator_5 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_102_p_direct_abstract_declarator_6( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *var_func = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_key_4;
    PyObject *tmp_dict_key_5;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_dict_value_4;
    PyObject *tmp_dict_value_5;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_kw_name_2;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    static struct Nuitka_FrameObject *cache_frame_d0ddb5710ee04c11b9c8b5e7929925bb = NULL;

    struct Nuitka_FrameObject *frame_d0ddb5710ee04c11b9c8b5e7929925bb;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d0ddb5710ee04c11b9c8b5e7929925bb, codeobj_d0ddb5710ee04c11b9c8b5e7929925bb, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_d0ddb5710ee04c11b9c8b5e7929925bb = cache_frame_d0ddb5710ee04c11b9c8b5e7929925bb;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d0ddb5710ee04c11b9c8b5e7929925bb );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d0ddb5710ee04c11b9c8b5e7929925bb ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1368;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_FuncDecl );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1368;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_1 = _PyDict_NewPresized( 3 );
    tmp_dict_key_1 = const_str_plain_args;
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1369;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_3;
    tmp_dict_value_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_dict_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1369;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    Py_DECREF( tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_type;
    tmp_dict_value_2 = Py_None;
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_3 = const_str_plain_coord;
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1371;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_1;
    tmp_source_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_source_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1371;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_dict_value_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_coord );
    Py_DECREF( tmp_source_name_2 );
    if ( tmp_dict_value_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1371;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3 );
    Py_DECREF( tmp_dict_value_3 );
    assert( !(tmp_res != 0) );
    frame_d0ddb5710ee04c11b9c8b5e7929925bb->m_frame.f_lineno = 1368;
    tmp_assign_source_1 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1368;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_func == NULL );
    var_func = tmp_assign_source_1;

    tmp_source_name_3 = par_self;

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1373;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__type_modify_decl );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1373;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_2 = _PyDict_NewPresized( 2 );
    tmp_dict_key_4 = const_str_plain_decl;
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1373;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_1;
    tmp_dict_value_4 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_dict_value_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_2 );

        exception_lineno = 1373;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_4, tmp_dict_value_4 );
    Py_DECREF( tmp_dict_value_4 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_5 = const_str_plain_modifier;
    tmp_dict_value_5 = var_func;

    if ( tmp_dict_value_5 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "func" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1373;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_SetItem( tmp_kw_name_2, tmp_dict_key_5, tmp_dict_value_5 );
    assert( !(tmp_res != 0) );
    frame_d0ddb5710ee04c11b9c8b5e7929925bb->m_frame.f_lineno = 1373;
    tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_2, tmp_kw_name_2 );
    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_kw_name_2 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1373;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1373;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1373;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d0ddb5710ee04c11b9c8b5e7929925bb );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d0ddb5710ee04c11b9c8b5e7929925bb );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d0ddb5710ee04c11b9c8b5e7929925bb, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d0ddb5710ee04c11b9c8b5e7929925bb->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d0ddb5710ee04c11b9c8b5e7929925bb, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_d0ddb5710ee04c11b9c8b5e7929925bb, type_description ,par_self, par_p, var_func );

    // Release cached frame.
    if ( frame_d0ddb5710ee04c11b9c8b5e7929925bb == cache_frame_d0ddb5710ee04c11b9c8b5e7929925bb )
    {
        Py_DECREF( frame_d0ddb5710ee04c11b9c8b5e7929925bb );
    }
    cache_frame_d0ddb5710ee04c11b9c8b5e7929925bb = NULL;

    assertFrameObject( frame_d0ddb5710ee04c11b9c8b5e7929925bb );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_102_p_direct_abstract_declarator_6 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_func );
    var_func = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_func );
    var_func = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_102_p_direct_abstract_declarator_6 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_103_p_direct_abstract_declarator_7( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_kw_name_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_40828e27474f8175923acb31cbff0852 = NULL;

    struct Nuitka_FrameObject *frame_40828e27474f8175923acb31cbff0852;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_40828e27474f8175923acb31cbff0852, codeobj_40828e27474f8175923acb31cbff0852, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_40828e27474f8175923acb31cbff0852 = cache_frame_40828e27474f8175923acb31cbff0852;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_40828e27474f8175923acb31cbff0852 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_40828e27474f8175923acb31cbff0852 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1378;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_FuncDecl );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1378;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_1 = _PyDict_NewPresized( 3 );
    tmp_dict_key_1 = const_str_plain_args;
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1379;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_2;
    tmp_dict_value_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_dict_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1379;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    Py_DECREF( tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_type;
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_called_instance_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1380;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    frame_40828e27474f8175923acb31cbff0852->m_frame.f_lineno = 1380;
    tmp_dict_value_2 = CALL_METHOD_WITH_ARGS3( tmp_called_instance_1, const_str_plain_TypeDecl, &PyTuple_GET_ITEM( const_tuple_none_none_none_tuple, 0 ) );

    if ( tmp_dict_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1380;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    Py_DECREF( tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_3 = const_str_plain_coord;
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1381;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1381;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_p;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1381;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = const_int_pos_1;
    frame_40828e27474f8175923acb31cbff0852->m_frame.f_lineno = 1381;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_dict_value_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_dict_value_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1381;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3 );
    Py_DECREF( tmp_dict_value_3 );
    assert( !(tmp_res != 0) );
    frame_40828e27474f8175923acb31cbff0852->m_frame.f_lineno = 1378;
    tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1378;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1378;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1378;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_40828e27474f8175923acb31cbff0852 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_40828e27474f8175923acb31cbff0852 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_40828e27474f8175923acb31cbff0852, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_40828e27474f8175923acb31cbff0852->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_40828e27474f8175923acb31cbff0852, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_40828e27474f8175923acb31cbff0852, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_40828e27474f8175923acb31cbff0852 == cache_frame_40828e27474f8175923acb31cbff0852 )
    {
        Py_DECREF( frame_40828e27474f8175923acb31cbff0852 );
    }
    cache_frame_40828e27474f8175923acb31cbff0852 = NULL;

    assertFrameObject( frame_40828e27474f8175923acb31cbff0852 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_103_p_direct_abstract_declarator_7 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_103_p_direct_abstract_declarator_7 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_104_p_block_item( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_list_element_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    static struct Nuitka_FrameObject *cache_frame_d418cf27184b2bf16ca054052e01d977 = NULL;

    struct Nuitka_FrameObject *frame_d418cf27184b2bf16ca054052e01d977;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d418cf27184b2bf16ca054052e01d977, codeobj_d418cf27184b2bf16ca054052e01d977, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_d418cf27184b2bf16ca054052e01d977 = cache_frame_d418cf27184b2bf16ca054052e01d977;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d418cf27184b2bf16ca054052e01d977 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d418cf27184b2bf16ca054052e01d977 ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_isinstance_inst_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_isinstance_inst_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1390;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_isinstance_cls_1 = (PyObject *)&PyList_Type;
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    Py_DECREF( tmp_isinstance_inst_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1390;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto condexpr_true_1;
    }
    else
    {
        goto condexpr_false_1;
    }
    condexpr_true_1:;
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1390;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_1;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1390;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto condexpr_end_1;
    condexpr_false_1:;
    tmp_ass_subvalue_1 = PyList_New( 1 );
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1390;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_1;
    tmp_list_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_list_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_1 );

        exception_lineno = 1390;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyList_SET_ITEM( tmp_ass_subvalue_1, 0, tmp_list_element_1 );
    condexpr_end_1:;
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1390;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1390;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d418cf27184b2bf16ca054052e01d977 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d418cf27184b2bf16ca054052e01d977 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d418cf27184b2bf16ca054052e01d977, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d418cf27184b2bf16ca054052e01d977->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d418cf27184b2bf16ca054052e01d977, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_d418cf27184b2bf16ca054052e01d977, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_d418cf27184b2bf16ca054052e01d977 == cache_frame_d418cf27184b2bf16ca054052e01d977 )
    {
        Py_DECREF( frame_d418cf27184b2bf16ca054052e01d977 );
    }
    cache_frame_d418cf27184b2bf16ca054052e01d977 = NULL;

    assertFrameObject( frame_d418cf27184b2bf16ca054052e01d977 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_104_p_block_item );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_104_p_block_item );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_105_p_block_item_list( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_len_arg_1;
    int tmp_or_left_truth_1;
    PyObject *tmp_or_left_value_1;
    PyObject *tmp_or_right_value_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    static struct Nuitka_FrameObject *cache_frame_f876f59d4cd77fb6f7eab21d385ae078 = NULL;

    struct Nuitka_FrameObject *frame_f876f59d4cd77fb6f7eab21d385ae078;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_f876f59d4cd77fb6f7eab21d385ae078, codeobj_f876f59d4cd77fb6f7eab21d385ae078, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_f876f59d4cd77fb6f7eab21d385ae078 = cache_frame_f876f59d4cd77fb6f7eab21d385ae078;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_f876f59d4cd77fb6f7eab21d385ae078 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_f876f59d4cd77fb6f7eab21d385ae078 ) == 2 ); // Frame stack

    // Framed code:
    tmp_len_arg_1 = par_p;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_compexpr_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1399;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_1 = const_int_pos_2;
    tmp_or_left_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    if ( tmp_or_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1399;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
    if ( tmp_or_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_or_left_value_1 );

        exception_lineno = 1399;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_or_left_truth_1 == 1 )
    {
        goto or_left_1;
    }
    else
    {
        goto or_right_1;
    }
    or_right_1:;
    Py_DECREF( tmp_or_left_value_1 );
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1399;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_2;
    tmp_compexpr_left_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_compexpr_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1399;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_2 = LIST_COPY( const_list_none_list );
    tmp_or_right_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    Py_DECREF( tmp_compexpr_left_2 );
    Py_DECREF( tmp_compexpr_right_2 );
    if ( tmp_or_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1399;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_cond_value_1 = tmp_or_right_value_1;
    goto or_end_1;
    or_left_1:;
    tmp_cond_value_1 = tmp_or_left_value_1;
    or_end_1:;
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 1399;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto condexpr_true_1;
    }
    else
    {
        goto condexpr_false_1;
    }
    condexpr_true_1:;
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1399;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_1;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1399;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto condexpr_end_1;
    condexpr_false_1:;
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1399;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_1;
    tmp_left_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_left_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1399;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_4 = par_p;

    if ( tmp_subscribed_name_4 == NULL )
    {
        Py_DECREF( tmp_left_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1399;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_4 = const_int_pos_2;
    tmp_right_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_4 );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_1 );

        exception_lineno = 1399;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subvalue_1 = BINARY_OPERATION_ADD( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_left_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1399;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    condexpr_end_1:;
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1399;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1399;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f876f59d4cd77fb6f7eab21d385ae078 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_f876f59d4cd77fb6f7eab21d385ae078 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_f876f59d4cd77fb6f7eab21d385ae078, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_f876f59d4cd77fb6f7eab21d385ae078->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_f876f59d4cd77fb6f7eab21d385ae078, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_f876f59d4cd77fb6f7eab21d385ae078, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_f876f59d4cd77fb6f7eab21d385ae078 == cache_frame_f876f59d4cd77fb6f7eab21d385ae078 )
    {
        Py_DECREF( frame_f876f59d4cd77fb6f7eab21d385ae078 );
    }
    cache_frame_f876f59d4cd77fb6f7eab21d385ae078 = NULL;

    assertFrameObject( frame_f876f59d4cd77fb6f7eab21d385ae078 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_105_p_block_item_list );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_105_p_block_item_list );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_106_p_compound_statement_1( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_kw_name_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_a80f7b2846d23973abaf0cf769aa2159 = NULL;

    struct Nuitka_FrameObject *frame_a80f7b2846d23973abaf0cf769aa2159;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a80f7b2846d23973abaf0cf769aa2159, codeobj_a80f7b2846d23973abaf0cf769aa2159, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_a80f7b2846d23973abaf0cf769aa2159 = cache_frame_a80f7b2846d23973abaf0cf769aa2159;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a80f7b2846d23973abaf0cf769aa2159 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a80f7b2846d23973abaf0cf769aa2159 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1403;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_Compound );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1403;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_1 = _PyDict_NewPresized( 2 );
    tmp_dict_key_1 = const_str_plain_block_items;
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1404;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_2;
    tmp_dict_value_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_dict_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1404;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    Py_DECREF( tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_coord;
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1405;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1405;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_p;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1405;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = const_int_pos_1;
    frame_a80f7b2846d23973abaf0cf769aa2159->m_frame.f_lineno = 1405;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_dict_value_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_dict_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1405;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    Py_DECREF( tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    frame_a80f7b2846d23973abaf0cf769aa2159->m_frame.f_lineno = 1403;
    tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1403;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1403;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1403;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a80f7b2846d23973abaf0cf769aa2159 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a80f7b2846d23973abaf0cf769aa2159 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a80f7b2846d23973abaf0cf769aa2159, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a80f7b2846d23973abaf0cf769aa2159->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a80f7b2846d23973abaf0cf769aa2159, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_a80f7b2846d23973abaf0cf769aa2159, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_a80f7b2846d23973abaf0cf769aa2159 == cache_frame_a80f7b2846d23973abaf0cf769aa2159 )
    {
        Py_DECREF( frame_a80f7b2846d23973abaf0cf769aa2159 );
    }
    cache_frame_a80f7b2846d23973abaf0cf769aa2159 = NULL;

    assertFrameObject( frame_a80f7b2846d23973abaf0cf769aa2159 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_106_p_compound_statement_1 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_106_p_compound_statement_1 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_107_p_labeled_statement_1( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    static struct Nuitka_FrameObject *cache_frame_1310901836337014bc882ee72d64976b = NULL;

    struct Nuitka_FrameObject *frame_1310901836337014bc882ee72d64976b;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1310901836337014bc882ee72d64976b, codeobj_1310901836337014bc882ee72d64976b, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_1310901836337014bc882ee72d64976b = cache_frame_1310901836337014bc882ee72d64976b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1310901836337014bc882ee72d64976b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1310901836337014bc882ee72d64976b ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1409;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_Label );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1409;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1409;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1409;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1409;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_3;
    tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1409;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1409;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1409;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = par_p;

    if ( tmp_args_element_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1409;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = const_int_pos_1;
    frame_1310901836337014bc882ee72d64976b->m_frame.f_lineno = 1409;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_args_element_name_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1409;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_1310901836337014bc882ee72d64976b->m_frame.f_lineno = 1409;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1409;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1409;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1409;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1310901836337014bc882ee72d64976b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1310901836337014bc882ee72d64976b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1310901836337014bc882ee72d64976b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1310901836337014bc882ee72d64976b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1310901836337014bc882ee72d64976b, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_1310901836337014bc882ee72d64976b, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_1310901836337014bc882ee72d64976b == cache_frame_1310901836337014bc882ee72d64976b )
    {
        Py_DECREF( frame_1310901836337014bc882ee72d64976b );
    }
    cache_frame_1310901836337014bc882ee72d64976b = NULL;

    assertFrameObject( frame_1310901836337014bc882ee72d64976b );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_107_p_labeled_statement_1 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_107_p_labeled_statement_1 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_108_p_labeled_statement_2( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_list_element_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    static struct Nuitka_FrameObject *cache_frame_848b6d36ac8046f93895c4f1c5e3f20a = NULL;

    struct Nuitka_FrameObject *frame_848b6d36ac8046f93895c4f1c5e3f20a;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_848b6d36ac8046f93895c4f1c5e3f20a, codeobj_848b6d36ac8046f93895c4f1c5e3f20a, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_848b6d36ac8046f93895c4f1c5e3f20a = cache_frame_848b6d36ac8046f93895c4f1c5e3f20a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_848b6d36ac8046f93895c4f1c5e3f20a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_848b6d36ac8046f93895c4f1c5e3f20a ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1413;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_Case );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1413;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1413;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_2;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1413;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = PyList_New( 1 );
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1413;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_4;
    tmp_list_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_list_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1413;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyList_SET_ITEM( tmp_args_element_name_2, 0, tmp_list_element_1 );
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1413;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1413;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = par_p;

    if ( tmp_args_element_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1413;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = const_int_pos_1;
    frame_848b6d36ac8046f93895c4f1c5e3f20a->m_frame.f_lineno = 1413;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_args_element_name_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1413;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_848b6d36ac8046f93895c4f1c5e3f20a->m_frame.f_lineno = 1413;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1413;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1413;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1413;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_848b6d36ac8046f93895c4f1c5e3f20a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_848b6d36ac8046f93895c4f1c5e3f20a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_848b6d36ac8046f93895c4f1c5e3f20a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_848b6d36ac8046f93895c4f1c5e3f20a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_848b6d36ac8046f93895c4f1c5e3f20a, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_848b6d36ac8046f93895c4f1c5e3f20a, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_848b6d36ac8046f93895c4f1c5e3f20a == cache_frame_848b6d36ac8046f93895c4f1c5e3f20a )
    {
        Py_DECREF( frame_848b6d36ac8046f93895c4f1c5e3f20a );
    }
    cache_frame_848b6d36ac8046f93895c4f1c5e3f20a = NULL;

    assertFrameObject( frame_848b6d36ac8046f93895c4f1c5e3f20a );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_108_p_labeled_statement_2 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_108_p_labeled_statement_2 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_109_p_labeled_statement_3( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_list_element_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_4b2ca4185e772da831d9fd26e5c441de = NULL;

    struct Nuitka_FrameObject *frame_4b2ca4185e772da831d9fd26e5c441de;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_4b2ca4185e772da831d9fd26e5c441de, codeobj_4b2ca4185e772da831d9fd26e5c441de, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_4b2ca4185e772da831d9fd26e5c441de = cache_frame_4b2ca4185e772da831d9fd26e5c441de;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_4b2ca4185e772da831d9fd26e5c441de );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_4b2ca4185e772da831d9fd26e5c441de ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1417;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_Default );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1417;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = PyList_New( 1 );
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1417;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_3;
    tmp_list_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_list_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1417;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyList_SET_ITEM( tmp_args_element_name_1, 0, tmp_list_element_1 );
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1417;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1417;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = par_p;

    if ( tmp_args_element_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1417;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = const_int_pos_1;
    frame_4b2ca4185e772da831d9fd26e5c441de->m_frame.f_lineno = 1417;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_args_element_name_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1417;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_4b2ca4185e772da831d9fd26e5c441de->m_frame.f_lineno = 1417;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1417;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1417;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1417;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4b2ca4185e772da831d9fd26e5c441de );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4b2ca4185e772da831d9fd26e5c441de );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_4b2ca4185e772da831d9fd26e5c441de, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_4b2ca4185e772da831d9fd26e5c441de->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_4b2ca4185e772da831d9fd26e5c441de, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_4b2ca4185e772da831d9fd26e5c441de, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_4b2ca4185e772da831d9fd26e5c441de == cache_frame_4b2ca4185e772da831d9fd26e5c441de )
    {
        Py_DECREF( frame_4b2ca4185e772da831d9fd26e5c441de );
    }
    cache_frame_4b2ca4185e772da831d9fd26e5c441de = NULL;

    assertFrameObject( frame_4b2ca4185e772da831d9fd26e5c441de );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_109_p_labeled_statement_3 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_109_p_labeled_statement_3 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_110_p_selection_statement_1( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    static struct Nuitka_FrameObject *cache_frame_3827ee0116b2c686ac4a629dc5c8d41b = NULL;

    struct Nuitka_FrameObject *frame_3827ee0116b2c686ac4a629dc5c8d41b;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3827ee0116b2c686ac4a629dc5c8d41b, codeobj_3827ee0116b2c686ac4a629dc5c8d41b, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_3827ee0116b2c686ac4a629dc5c8d41b = cache_frame_3827ee0116b2c686ac4a629dc5c8d41b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3827ee0116b2c686ac4a629dc5c8d41b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3827ee0116b2c686ac4a629dc5c8d41b ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1421;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_If );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1421;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1421;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_3;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1421;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1421;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_5;
    tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1421;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = Py_None;
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1421;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1421;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_5 = par_p;

    if ( tmp_args_element_name_5 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1421;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_6 = const_int_pos_1;
    frame_3827ee0116b2c686ac4a629dc5c8d41b->m_frame.f_lineno = 1421;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_args_element_name_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1421;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_3827ee0116b2c686ac4a629dc5c8d41b->m_frame.f_lineno = 1421;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1421;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1421;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1421;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3827ee0116b2c686ac4a629dc5c8d41b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3827ee0116b2c686ac4a629dc5c8d41b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3827ee0116b2c686ac4a629dc5c8d41b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3827ee0116b2c686ac4a629dc5c8d41b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3827ee0116b2c686ac4a629dc5c8d41b, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_3827ee0116b2c686ac4a629dc5c8d41b, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_3827ee0116b2c686ac4a629dc5c8d41b == cache_frame_3827ee0116b2c686ac4a629dc5c8d41b )
    {
        Py_DECREF( frame_3827ee0116b2c686ac4a629dc5c8d41b );
    }
    cache_frame_3827ee0116b2c686ac4a629dc5c8d41b = NULL;

    assertFrameObject( frame_3827ee0116b2c686ac4a629dc5c8d41b );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_110_p_selection_statement_1 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_110_p_selection_statement_1 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_111_p_selection_statement_2( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    static struct Nuitka_FrameObject *cache_frame_02c27f43617c9de50be853bd11a02557 = NULL;

    struct Nuitka_FrameObject *frame_02c27f43617c9de50be853bd11a02557;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_02c27f43617c9de50be853bd11a02557, codeobj_02c27f43617c9de50be853bd11a02557, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_02c27f43617c9de50be853bd11a02557 = cache_frame_02c27f43617c9de50be853bd11a02557;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_02c27f43617c9de50be853bd11a02557 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_02c27f43617c9de50be853bd11a02557 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1425;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_If );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1425;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1425;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_3;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1425;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1425;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_5;
    tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1425;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1425;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_7;
    tmp_args_element_name_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1425;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1425;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );

        exception_lineno = 1425;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_5 = par_p;

    if ( tmp_args_element_name_5 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1425;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_6 = const_int_pos_1;
    frame_02c27f43617c9de50be853bd11a02557->m_frame.f_lineno = 1425;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_args_element_name_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );

        exception_lineno = 1425;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_02c27f43617c9de50be853bd11a02557->m_frame.f_lineno = 1425;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1425;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1425;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1425;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_02c27f43617c9de50be853bd11a02557 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_02c27f43617c9de50be853bd11a02557 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_02c27f43617c9de50be853bd11a02557, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_02c27f43617c9de50be853bd11a02557->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_02c27f43617c9de50be853bd11a02557, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_02c27f43617c9de50be853bd11a02557, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_02c27f43617c9de50be853bd11a02557 == cache_frame_02c27f43617c9de50be853bd11a02557 )
    {
        Py_DECREF( frame_02c27f43617c9de50be853bd11a02557 );
    }
    cache_frame_02c27f43617c9de50be853bd11a02557 = NULL;

    assertFrameObject( frame_02c27f43617c9de50be853bd11a02557 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_111_p_selection_statement_2 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_111_p_selection_statement_2 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_112_p_selection_statement_3( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    static struct Nuitka_FrameObject *cache_frame_df0dd4c7f3200da012ac0fd7c5300dee = NULL;

    struct Nuitka_FrameObject *frame_df0dd4c7f3200da012ac0fd7c5300dee;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_df0dd4c7f3200da012ac0fd7c5300dee, codeobj_df0dd4c7f3200da012ac0fd7c5300dee, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_df0dd4c7f3200da012ac0fd7c5300dee = cache_frame_df0dd4c7f3200da012ac0fd7c5300dee;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_df0dd4c7f3200da012ac0fd7c5300dee );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_df0dd4c7f3200da012ac0fd7c5300dee ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_fix_switch_cases );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_fix_switch_cases );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "fix_switch_cases" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1429;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1430;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_Switch );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1430;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1430;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_3;
    tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1430;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1430;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_5;
    tmp_args_element_name_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1430;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1430;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );

        exception_lineno = 1430;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_5 = par_p;

    if ( tmp_args_element_name_5 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1430;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_6 = const_int_pos_1;
    frame_df0dd4c7f3200da012ac0fd7c5300dee->m_frame.f_lineno = 1430;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_args_element_name_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );

        exception_lineno = 1430;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_df0dd4c7f3200da012ac0fd7c5300dee->m_frame.f_lineno = 1430;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1430;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_df0dd4c7f3200da012ac0fd7c5300dee->m_frame.f_lineno = 1429;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1429;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1429;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1429;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_df0dd4c7f3200da012ac0fd7c5300dee );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_df0dd4c7f3200da012ac0fd7c5300dee );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_df0dd4c7f3200da012ac0fd7c5300dee, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_df0dd4c7f3200da012ac0fd7c5300dee->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_df0dd4c7f3200da012ac0fd7c5300dee, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_df0dd4c7f3200da012ac0fd7c5300dee, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_df0dd4c7f3200da012ac0fd7c5300dee == cache_frame_df0dd4c7f3200da012ac0fd7c5300dee )
    {
        Py_DECREF( frame_df0dd4c7f3200da012ac0fd7c5300dee );
    }
    cache_frame_df0dd4c7f3200da012ac0fd7c5300dee = NULL;

    assertFrameObject( frame_df0dd4c7f3200da012ac0fd7c5300dee );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_112_p_selection_statement_3 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_112_p_selection_statement_3 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_113_p_iteration_statement_1( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    static struct Nuitka_FrameObject *cache_frame_802c5dcca4e0dc3da51d1647e1b1c44b = NULL;

    struct Nuitka_FrameObject *frame_802c5dcca4e0dc3da51d1647e1b1c44b;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_802c5dcca4e0dc3da51d1647e1b1c44b, codeobj_802c5dcca4e0dc3da51d1647e1b1c44b, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_802c5dcca4e0dc3da51d1647e1b1c44b = cache_frame_802c5dcca4e0dc3da51d1647e1b1c44b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_802c5dcca4e0dc3da51d1647e1b1c44b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_802c5dcca4e0dc3da51d1647e1b1c44b ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1434;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_While );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1434;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1434;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_3;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1434;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1434;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_5;
    tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1434;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1434;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1434;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = par_p;

    if ( tmp_args_element_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1434;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = const_int_pos_1;
    frame_802c5dcca4e0dc3da51d1647e1b1c44b->m_frame.f_lineno = 1434;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_args_element_name_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1434;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_802c5dcca4e0dc3da51d1647e1b1c44b->m_frame.f_lineno = 1434;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1434;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1434;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1434;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_802c5dcca4e0dc3da51d1647e1b1c44b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_802c5dcca4e0dc3da51d1647e1b1c44b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_802c5dcca4e0dc3da51d1647e1b1c44b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_802c5dcca4e0dc3da51d1647e1b1c44b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_802c5dcca4e0dc3da51d1647e1b1c44b, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_802c5dcca4e0dc3da51d1647e1b1c44b, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_802c5dcca4e0dc3da51d1647e1b1c44b == cache_frame_802c5dcca4e0dc3da51d1647e1b1c44b )
    {
        Py_DECREF( frame_802c5dcca4e0dc3da51d1647e1b1c44b );
    }
    cache_frame_802c5dcca4e0dc3da51d1647e1b1c44b = NULL;

    assertFrameObject( frame_802c5dcca4e0dc3da51d1647e1b1c44b );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_113_p_iteration_statement_1 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_113_p_iteration_statement_1 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_114_p_iteration_statement_2( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    static struct Nuitka_FrameObject *cache_frame_af8b24a7fb187d46cbff465e53ea8988 = NULL;

    struct Nuitka_FrameObject *frame_af8b24a7fb187d46cbff465e53ea8988;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_af8b24a7fb187d46cbff465e53ea8988, codeobj_af8b24a7fb187d46cbff465e53ea8988, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_af8b24a7fb187d46cbff465e53ea8988 = cache_frame_af8b24a7fb187d46cbff465e53ea8988;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_af8b24a7fb187d46cbff465e53ea8988 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_af8b24a7fb187d46cbff465e53ea8988 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1438;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_DoWhile );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1438;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1438;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_5;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1438;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1438;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_2;
    tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1438;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1438;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1438;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = par_p;

    if ( tmp_args_element_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1438;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = const_int_pos_1;
    frame_af8b24a7fb187d46cbff465e53ea8988->m_frame.f_lineno = 1438;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_args_element_name_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1438;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_af8b24a7fb187d46cbff465e53ea8988->m_frame.f_lineno = 1438;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1438;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1438;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1438;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_af8b24a7fb187d46cbff465e53ea8988 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_af8b24a7fb187d46cbff465e53ea8988 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_af8b24a7fb187d46cbff465e53ea8988, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_af8b24a7fb187d46cbff465e53ea8988->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_af8b24a7fb187d46cbff465e53ea8988, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_af8b24a7fb187d46cbff465e53ea8988, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_af8b24a7fb187d46cbff465e53ea8988 == cache_frame_af8b24a7fb187d46cbff465e53ea8988 )
    {
        Py_DECREF( frame_af8b24a7fb187d46cbff465e53ea8988 );
    }
    cache_frame_af8b24a7fb187d46cbff465e53ea8988 = NULL;

    assertFrameObject( frame_af8b24a7fb187d46cbff465e53ea8988 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_114_p_iteration_statement_2 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_114_p_iteration_statement_2 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_115_p_iteration_statement_3( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    static struct Nuitka_FrameObject *cache_frame_08768331755421b59b3b286c6aa14448 = NULL;

    struct Nuitka_FrameObject *frame_08768331755421b59b3b286c6aa14448;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_08768331755421b59b3b286c6aa14448, codeobj_08768331755421b59b3b286c6aa14448, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_08768331755421b59b3b286c6aa14448 = cache_frame_08768331755421b59b3b286c6aa14448;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_08768331755421b59b3b286c6aa14448 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_08768331755421b59b3b286c6aa14448 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1442;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_For );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1442;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1442;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_3;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1442;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1442;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_5;
    tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1442;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1442;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_7;
    tmp_args_element_name_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1442;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_4 = par_p;

    if ( tmp_subscribed_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1442;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_4 = const_int_pos_9;
    tmp_args_element_name_4 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_4 );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );

        exception_lineno = 1442;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_args_element_name_4 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1442;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_args_element_name_4 );

        exception_lineno = 1442;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_6 = par_p;

    if ( tmp_args_element_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_args_element_name_4 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1442;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_7 = const_int_pos_1;
    frame_08768331755421b59b3b286c6aa14448->m_frame.f_lineno = 1442;
    {
        PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
        tmp_args_element_name_5 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_args_element_name_4 );

        exception_lineno = 1442;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_08768331755421b59b3b286c6aa14448->m_frame.f_lineno = 1442;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS5( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1442;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1442;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1442;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_08768331755421b59b3b286c6aa14448 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_08768331755421b59b3b286c6aa14448 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_08768331755421b59b3b286c6aa14448, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_08768331755421b59b3b286c6aa14448->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_08768331755421b59b3b286c6aa14448, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_08768331755421b59b3b286c6aa14448, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_08768331755421b59b3b286c6aa14448 == cache_frame_08768331755421b59b3b286c6aa14448 )
    {
        Py_DECREF( frame_08768331755421b59b3b286c6aa14448 );
    }
    cache_frame_08768331755421b59b3b286c6aa14448 = NULL;

    assertFrameObject( frame_08768331755421b59b3b286c6aa14448 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_115_p_iteration_statement_3 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_115_p_iteration_statement_3 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_116_p_iteration_statement_4( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    static struct Nuitka_FrameObject *cache_frame_568ad40762c86bdbb2f4cf4156d8c64e = NULL;

    struct Nuitka_FrameObject *frame_568ad40762c86bdbb2f4cf4156d8c64e;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_568ad40762c86bdbb2f4cf4156d8c64e, codeobj_568ad40762c86bdbb2f4cf4156d8c64e, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_568ad40762c86bdbb2f4cf4156d8c64e = cache_frame_568ad40762c86bdbb2f4cf4156d8c64e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_568ad40762c86bdbb2f4cf4156d8c64e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_568ad40762c86bdbb2f4cf4156d8c64e ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1446;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_For );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1446;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1446;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_DeclList );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1446;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1446;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_3;
    tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1446;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_self;

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1446;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__token_coord );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1446;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = par_p;

    if ( tmp_args_element_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1446;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = const_int_pos_1;
    frame_568ad40762c86bdbb2f4cf4156d8c64e->m_frame.f_lineno = 1446;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_args_element_name_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1446;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_568ad40762c86bdbb2f4cf4156d8c64e->m_frame.f_lineno = 1446;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1446;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1447;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_4;
    tmp_args_element_name_6 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1447;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_6 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1447;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_6;
    tmp_args_element_name_7 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_args_element_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_6 );

        exception_lineno = 1447;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_4 = par_p;

    if ( tmp_subscribed_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_6 );
        Py_DECREF( tmp_args_element_name_7 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1447;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_4 = const_int_pos_8;
    tmp_args_element_name_8 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_4 );
    if ( tmp_args_element_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_6 );
        Py_DECREF( tmp_args_element_name_7 );

        exception_lineno = 1447;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = par_self;

    if ( tmp_source_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_6 );
        Py_DECREF( tmp_args_element_name_7 );
        Py_DECREF( tmp_args_element_name_8 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1447;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__token_coord );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_6 );
        Py_DECREF( tmp_args_element_name_7 );
        Py_DECREF( tmp_args_element_name_8 );

        exception_lineno = 1447;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_10 = par_p;

    if ( tmp_args_element_name_10 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_6 );
        Py_DECREF( tmp_args_element_name_7 );
        Py_DECREF( tmp_args_element_name_8 );
        Py_DECREF( tmp_called_name_4 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1447;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_11 = const_int_pos_1;
    frame_568ad40762c86bdbb2f4cf4156d8c64e->m_frame.f_lineno = 1447;
    {
        PyObject *call_args[] = { tmp_args_element_name_10, tmp_args_element_name_11 };
        tmp_args_element_name_9 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    if ( tmp_args_element_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_6 );
        Py_DECREF( tmp_args_element_name_7 );
        Py_DECREF( tmp_args_element_name_8 );

        exception_lineno = 1447;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_568ad40762c86bdbb2f4cf4156d8c64e->m_frame.f_lineno = 1446;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS5( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_6 );
    Py_DECREF( tmp_args_element_name_7 );
    Py_DECREF( tmp_args_element_name_8 );
    Py_DECREF( tmp_args_element_name_9 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1446;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1446;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1446;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_568ad40762c86bdbb2f4cf4156d8c64e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_568ad40762c86bdbb2f4cf4156d8c64e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_568ad40762c86bdbb2f4cf4156d8c64e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_568ad40762c86bdbb2f4cf4156d8c64e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_568ad40762c86bdbb2f4cf4156d8c64e, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_568ad40762c86bdbb2f4cf4156d8c64e, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_568ad40762c86bdbb2f4cf4156d8c64e == cache_frame_568ad40762c86bdbb2f4cf4156d8c64e )
    {
        Py_DECREF( frame_568ad40762c86bdbb2f4cf4156d8c64e );
    }
    cache_frame_568ad40762c86bdbb2f4cf4156d8c64e = NULL;

    assertFrameObject( frame_568ad40762c86bdbb2f4cf4156d8c64e );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_116_p_iteration_statement_4 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_116_p_iteration_statement_4 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_117_p_jump_statement_1( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_d4b13e566c43bcd4afcc2455b31001f3 = NULL;

    struct Nuitka_FrameObject *frame_d4b13e566c43bcd4afcc2455b31001f3;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d4b13e566c43bcd4afcc2455b31001f3, codeobj_d4b13e566c43bcd4afcc2455b31001f3, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_d4b13e566c43bcd4afcc2455b31001f3 = cache_frame_d4b13e566c43bcd4afcc2455b31001f3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d4b13e566c43bcd4afcc2455b31001f3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d4b13e566c43bcd4afcc2455b31001f3 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1451;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_Goto );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1451;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1451;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_2;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1451;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1451;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1451;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = par_p;

    if ( tmp_args_element_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1451;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = const_int_pos_1;
    frame_d4b13e566c43bcd4afcc2455b31001f3->m_frame.f_lineno = 1451;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_args_element_name_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1451;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_d4b13e566c43bcd4afcc2455b31001f3->m_frame.f_lineno = 1451;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1451;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1451;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1451;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d4b13e566c43bcd4afcc2455b31001f3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d4b13e566c43bcd4afcc2455b31001f3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d4b13e566c43bcd4afcc2455b31001f3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d4b13e566c43bcd4afcc2455b31001f3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d4b13e566c43bcd4afcc2455b31001f3, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_d4b13e566c43bcd4afcc2455b31001f3, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_d4b13e566c43bcd4afcc2455b31001f3 == cache_frame_d4b13e566c43bcd4afcc2455b31001f3 )
    {
        Py_DECREF( frame_d4b13e566c43bcd4afcc2455b31001f3 );
    }
    cache_frame_d4b13e566c43bcd4afcc2455b31001f3 = NULL;

    assertFrameObject( frame_d4b13e566c43bcd4afcc2455b31001f3 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_117_p_jump_statement_1 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_117_p_jump_statement_1 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_118_p_jump_statement_2( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_aa10437b2c7b7415d366a3591971e55e = NULL;

    struct Nuitka_FrameObject *frame_aa10437b2c7b7415d366a3591971e55e;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_aa10437b2c7b7415d366a3591971e55e, codeobj_aa10437b2c7b7415d366a3591971e55e, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_aa10437b2c7b7415d366a3591971e55e = cache_frame_aa10437b2c7b7415d366a3591971e55e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_aa10437b2c7b7415d366a3591971e55e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_aa10437b2c7b7415d366a3591971e55e ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1455;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_Break );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1455;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1455;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1455;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_p;

    if ( tmp_args_element_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1455;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = const_int_pos_1;
    frame_aa10437b2c7b7415d366a3591971e55e->m_frame.f_lineno = 1455;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1455;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_aa10437b2c7b7415d366a3591971e55e->m_frame.f_lineno = 1455;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1455;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1455;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1455;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_aa10437b2c7b7415d366a3591971e55e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_aa10437b2c7b7415d366a3591971e55e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_aa10437b2c7b7415d366a3591971e55e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_aa10437b2c7b7415d366a3591971e55e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_aa10437b2c7b7415d366a3591971e55e, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_aa10437b2c7b7415d366a3591971e55e, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_aa10437b2c7b7415d366a3591971e55e == cache_frame_aa10437b2c7b7415d366a3591971e55e )
    {
        Py_DECREF( frame_aa10437b2c7b7415d366a3591971e55e );
    }
    cache_frame_aa10437b2c7b7415d366a3591971e55e = NULL;

    assertFrameObject( frame_aa10437b2c7b7415d366a3591971e55e );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_118_p_jump_statement_2 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_118_p_jump_statement_2 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_119_p_jump_statement_3( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_9a7884aa4204ef4dbd3aad792656ee71 = NULL;

    struct Nuitka_FrameObject *frame_9a7884aa4204ef4dbd3aad792656ee71;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9a7884aa4204ef4dbd3aad792656ee71, codeobj_9a7884aa4204ef4dbd3aad792656ee71, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_9a7884aa4204ef4dbd3aad792656ee71 = cache_frame_9a7884aa4204ef4dbd3aad792656ee71;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9a7884aa4204ef4dbd3aad792656ee71 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9a7884aa4204ef4dbd3aad792656ee71 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1459;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_Continue );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1459;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1459;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1459;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_p;

    if ( tmp_args_element_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1459;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = const_int_pos_1;
    frame_9a7884aa4204ef4dbd3aad792656ee71->m_frame.f_lineno = 1459;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1459;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_9a7884aa4204ef4dbd3aad792656ee71->m_frame.f_lineno = 1459;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1459;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1459;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1459;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9a7884aa4204ef4dbd3aad792656ee71 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9a7884aa4204ef4dbd3aad792656ee71 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9a7884aa4204ef4dbd3aad792656ee71, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9a7884aa4204ef4dbd3aad792656ee71->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9a7884aa4204ef4dbd3aad792656ee71, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_9a7884aa4204ef4dbd3aad792656ee71, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_9a7884aa4204ef4dbd3aad792656ee71 == cache_frame_9a7884aa4204ef4dbd3aad792656ee71 )
    {
        Py_DECREF( frame_9a7884aa4204ef4dbd3aad792656ee71 );
    }
    cache_frame_9a7884aa4204ef4dbd3aad792656ee71 = NULL;

    assertFrameObject( frame_9a7884aa4204ef4dbd3aad792656ee71 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_119_p_jump_statement_3 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_119_p_jump_statement_3 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_120_p_jump_statement_4( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_42a6c9510c0bdcc207922abe14498274 = NULL;

    struct Nuitka_FrameObject *frame_42a6c9510c0bdcc207922abe14498274;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_42a6c9510c0bdcc207922abe14498274, codeobj_42a6c9510c0bdcc207922abe14498274, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_42a6c9510c0bdcc207922abe14498274 = cache_frame_42a6c9510c0bdcc207922abe14498274;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_42a6c9510c0bdcc207922abe14498274 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_42a6c9510c0bdcc207922abe14498274 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1465;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_Return );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1465;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_len_arg_1 = par_p;

    if ( tmp_len_arg_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1465;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1465;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_pos_4;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 1465;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto condexpr_true_1;
    }
    else
    {
        goto condexpr_false_1;
    }
    condexpr_true_1:;
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1465;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_2;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1465;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto condexpr_end_1;
    condexpr_false_1:;
    tmp_args_element_name_1 = Py_None;
    Py_INCREF( tmp_args_element_name_1 );
    condexpr_end_1:;
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1465;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1465;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = par_p;

    if ( tmp_args_element_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1465;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = const_int_pos_1;
    frame_42a6c9510c0bdcc207922abe14498274->m_frame.f_lineno = 1465;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_args_element_name_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1465;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_42a6c9510c0bdcc207922abe14498274->m_frame.f_lineno = 1465;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1465;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1465;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1465;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_42a6c9510c0bdcc207922abe14498274 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_42a6c9510c0bdcc207922abe14498274 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_42a6c9510c0bdcc207922abe14498274, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_42a6c9510c0bdcc207922abe14498274->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_42a6c9510c0bdcc207922abe14498274, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_42a6c9510c0bdcc207922abe14498274, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_42a6c9510c0bdcc207922abe14498274 == cache_frame_42a6c9510c0bdcc207922abe14498274 )
    {
        Py_DECREF( frame_42a6c9510c0bdcc207922abe14498274 );
    }
    cache_frame_42a6c9510c0bdcc207922abe14498274 = NULL;

    assertFrameObject( frame_42a6c9510c0bdcc207922abe14498274 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_120_p_jump_statement_4 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_120_p_jump_statement_4 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_121_p_expression_statement( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscribed_2;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subscript_2;
    int tmp_ass_subscript_res_1;
    int tmp_ass_subscript_res_2;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_ass_subvalue_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    bool tmp_is_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    static struct Nuitka_FrameObject *cache_frame_effdb1dfb0ba4b664777a5d6f9df0b8d = NULL;

    struct Nuitka_FrameObject *frame_effdb1dfb0ba4b664777a5d6f9df0b8d;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_effdb1dfb0ba4b664777a5d6f9df0b8d, codeobj_effdb1dfb0ba4b664777a5d6f9df0b8d, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_effdb1dfb0ba4b664777a5d6f9df0b8d = cache_frame_effdb1dfb0ba4b664777a5d6f9df0b8d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_effdb1dfb0ba4b664777a5d6f9df0b8d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_effdb1dfb0ba4b664777a5d6f9df0b8d ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_compare_left_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1469;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1470;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_EmptyStatement );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1470;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1470;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1470;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_p;

    if ( tmp_args_element_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1470;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = const_int_pos_2;
    frame_effdb1dfb0ba4b664777a5d6f9df0b8d->m_frame.f_lineno = 1470;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1470;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_effdb1dfb0ba4b664777a5d6f9df0b8d->m_frame.f_lineno = 1470;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1470;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1470;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1470;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto branch_end_1;
    branch_no_1:;
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1472;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_1;
    tmp_ass_subvalue_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_ass_subvalue_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1472;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_2 = par_p;

    if ( tmp_ass_subscribed_2 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1472;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_2 = const_int_0;
    tmp_ass_subscript_res_2 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_2, tmp_ass_subscript_2, 0, tmp_ass_subvalue_2 );
    Py_DECREF( tmp_ass_subvalue_2 );
    if ( tmp_ass_subscript_res_2 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1472;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_effdb1dfb0ba4b664777a5d6f9df0b8d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_effdb1dfb0ba4b664777a5d6f9df0b8d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_effdb1dfb0ba4b664777a5d6f9df0b8d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_effdb1dfb0ba4b664777a5d6f9df0b8d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_effdb1dfb0ba4b664777a5d6f9df0b8d, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_effdb1dfb0ba4b664777a5d6f9df0b8d, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_effdb1dfb0ba4b664777a5d6f9df0b8d == cache_frame_effdb1dfb0ba4b664777a5d6f9df0b8d )
    {
        Py_DECREF( frame_effdb1dfb0ba4b664777a5d6f9df0b8d );
    }
    cache_frame_effdb1dfb0ba4b664777a5d6f9df0b8d = NULL;

    assertFrameObject( frame_effdb1dfb0ba4b664777a5d6f9df0b8d );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_121_p_expression_statement );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_121_p_expression_statement );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_122_p_expression( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscribed_2;
    PyObject *tmp_ass_subscribed_3;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subscript_2;
    PyObject *tmp_ass_subscript_3;
    int tmp_ass_subscript_res_1;
    int tmp_ass_subscript_res_2;
    int tmp_ass_subscript_res_3;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_ass_subvalue_2;
    PyObject *tmp_ass_subvalue_3;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_list_element_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscribed_name_5;
    PyObject *tmp_subscribed_name_6;
    PyObject *tmp_subscribed_name_7;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    PyObject *tmp_subscript_name_5;
    PyObject *tmp_subscript_name_6;
    PyObject *tmp_subscript_name_7;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_890693400d4202a153b8e1e690365ade = NULL;

    struct Nuitka_FrameObject *frame_890693400d4202a153b8e1e690365ade;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_890693400d4202a153b8e1e690365ade, codeobj_890693400d4202a153b8e1e690365ade, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_890693400d4202a153b8e1e690365ade = cache_frame_890693400d4202a153b8e1e690365ade;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_890693400d4202a153b8e1e690365ade );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_890693400d4202a153b8e1e690365ade ) == 2 ); // Frame stack

    // Framed code:
    tmp_len_arg_1 = par_p;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1478;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_pos_2;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 1478;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1479;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1479;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1479;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1479;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto branch_end_1;
    branch_no_1:;
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1481;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_1;
    tmp_isinstance_inst_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_isinstance_inst_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1481;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {
        Py_DECREF( tmp_isinstance_inst_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1481;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_isinstance_cls_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_ExprList );
    if ( tmp_isinstance_cls_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_isinstance_inst_1 );

        exception_lineno = 1481;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    Py_DECREF( tmp_isinstance_inst_1 );
    Py_DECREF( tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1481;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1482;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_ExprList );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1482;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = PyList_New( 1 );
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1482;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_1;
    tmp_list_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_list_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1482;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyList_SET_ITEM( tmp_args_element_name_1, 0, tmp_list_element_1 );
    tmp_subscribed_name_4 = par_p;

    if ( tmp_subscribed_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1482;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_4 = const_int_pos_1;
    tmp_source_name_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_4 );
    if ( tmp_source_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1482;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_coord );
    Py_DECREF( tmp_source_name_3 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1482;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_890693400d4202a153b8e1e690365ade->m_frame.f_lineno = 1482;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_ass_subvalue_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_ass_subvalue_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1482;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_2 = par_p;

    if ( tmp_ass_subscribed_2 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1482;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_2 = const_int_pos_1;
    tmp_ass_subscript_res_2 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_2, tmp_ass_subscript_2, 1, tmp_ass_subvalue_2 );
    Py_DECREF( tmp_ass_subvalue_2 );
    if ( tmp_ass_subscript_res_2 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1482;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    branch_no_2:;
    tmp_subscribed_name_5 = par_p;

    if ( tmp_subscribed_name_5 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1484;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_5 = const_int_pos_1;
    tmp_source_name_5 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_5, tmp_subscript_name_5 );
    if ( tmp_source_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1484;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_exprs );
    Py_DECREF( tmp_source_name_5 );
    if ( tmp_source_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1484;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_append );
    Py_DECREF( tmp_source_name_4 );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1484;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_6 = par_p;

    if ( tmp_subscribed_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1484;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_6 = const_int_pos_3;
    tmp_args_element_name_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_6, tmp_subscript_name_6 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1484;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_890693400d4202a153b8e1e690365ade->m_frame.f_lineno = 1484;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1484;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_subscribed_name_7 = par_p;

    if ( tmp_subscribed_name_7 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1485;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_7 = const_int_pos_1;
    tmp_ass_subvalue_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_7, tmp_subscript_name_7 );
    if ( tmp_ass_subvalue_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1485;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_3 = par_p;

    if ( tmp_ass_subscribed_3 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1485;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_3 = const_int_0;
    tmp_ass_subscript_res_3 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_3, tmp_ass_subscript_3, 0, tmp_ass_subvalue_3 );
    Py_DECREF( tmp_ass_subvalue_3 );
    if ( tmp_ass_subscript_res_3 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1485;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_890693400d4202a153b8e1e690365ade );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_890693400d4202a153b8e1e690365ade );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_890693400d4202a153b8e1e690365ade, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_890693400d4202a153b8e1e690365ade->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_890693400d4202a153b8e1e690365ade, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_890693400d4202a153b8e1e690365ade, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_890693400d4202a153b8e1e690365ade == cache_frame_890693400d4202a153b8e1e690365ade )
    {
        Py_DECREF( frame_890693400d4202a153b8e1e690365ade );
    }
    cache_frame_890693400d4202a153b8e1e690365ade = NULL;

    assertFrameObject( frame_890693400d4202a153b8e1e690365ade );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_122_p_expression );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_122_p_expression );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_123_p_typedef_name( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_name_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_list_element_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_1f4b7bc9508ec89587d97c1950610acf = NULL;

    struct Nuitka_FrameObject *frame_1f4b7bc9508ec89587d97c1950610acf;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1f4b7bc9508ec89587d97c1950610acf, codeobj_1f4b7bc9508ec89587d97c1950610acf, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_1f4b7bc9508ec89587d97c1950610acf = cache_frame_1f4b7bc9508ec89587d97c1950610acf;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1f4b7bc9508ec89587d97c1950610acf );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1f4b7bc9508ec89587d97c1950610acf ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1489;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_IdentifierType );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1489;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_name_1 = PyTuple_New( 1 );
    tmp_tuple_element_1 = PyList_New( 1 );
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1489;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_list_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_list_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_tuple_element_1 );

        exception_lineno = 1489;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyList_SET_ITEM( tmp_tuple_element_1, 0, tmp_list_element_1 );
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_1 );
    tmp_kw_name_1 = _PyDict_NewPresized( 1 );
    tmp_dict_key_1 = const_str_plain_coord;
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1489;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1489;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_p;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1489;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = const_int_pos_1;
    frame_1f4b7bc9508ec89587d97c1950610acf->m_frame.f_lineno = 1489;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_dict_value_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_dict_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_name_1 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1489;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    Py_DECREF( tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    frame_1f4b7bc9508ec89587d97c1950610acf->m_frame.f_lineno = 1489;
    tmp_ass_subvalue_1 = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1489;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1489;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1489;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1f4b7bc9508ec89587d97c1950610acf );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1f4b7bc9508ec89587d97c1950610acf );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1f4b7bc9508ec89587d97c1950610acf, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1f4b7bc9508ec89587d97c1950610acf->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1f4b7bc9508ec89587d97c1950610acf, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_1f4b7bc9508ec89587d97c1950610acf, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_1f4b7bc9508ec89587d97c1950610acf == cache_frame_1f4b7bc9508ec89587d97c1950610acf )
    {
        Py_DECREF( frame_1f4b7bc9508ec89587d97c1950610acf );
    }
    cache_frame_1f4b7bc9508ec89587d97c1950610acf = NULL;

    assertFrameObject( frame_1f4b7bc9508ec89587d97c1950610acf );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_123_p_typedef_name );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_123_p_typedef_name );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_124_p_assignment_expression( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscribed_2;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subscript_2;
    int tmp_ass_subscript_res_1;
    int tmp_ass_subscript_res_2;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_ass_subvalue_2;
    PyObject *tmp_called_name_1;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscribed_name_5;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    PyObject *tmp_subscript_name_5;
    static struct Nuitka_FrameObject *cache_frame_19efd769ae32e39375b5f91ec8fbb547 = NULL;

    struct Nuitka_FrameObject *frame_19efd769ae32e39375b5f91ec8fbb547;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_19efd769ae32e39375b5f91ec8fbb547, codeobj_19efd769ae32e39375b5f91ec8fbb547, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_19efd769ae32e39375b5f91ec8fbb547 = cache_frame_19efd769ae32e39375b5f91ec8fbb547;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_19efd769ae32e39375b5f91ec8fbb547 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_19efd769ae32e39375b5f91ec8fbb547 ) == 2 ); // Frame stack

    // Framed code:
    tmp_len_arg_1 = par_p;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1495;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_pos_2;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 1495;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1496;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1496;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1496;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1496;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto branch_end_1;
    branch_no_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1498;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_Assignment );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1498;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1498;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_2;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1498;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1498;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_1;
    tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1498;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_4 = par_p;

    if ( tmp_subscribed_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1498;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_4 = const_int_pos_3;
    tmp_args_element_name_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_4 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1498;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_5 = par_p;

    if ( tmp_subscribed_name_5 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1498;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_5 = const_int_pos_1;
    tmp_source_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_5, tmp_subscript_name_5 );
    if ( tmp_source_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );

        exception_lineno = 1498;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_coord );
    Py_DECREF( tmp_source_name_2 );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );

        exception_lineno = 1498;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_19efd769ae32e39375b5f91ec8fbb547->m_frame.f_lineno = 1498;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_ass_subvalue_2 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_ass_subvalue_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1498;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_2 = par_p;

    if ( tmp_ass_subscribed_2 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1498;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_2 = const_int_0;
    tmp_ass_subscript_res_2 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_2, tmp_ass_subscript_2, 0, tmp_ass_subvalue_2 );
    Py_DECREF( tmp_ass_subvalue_2 );
    if ( tmp_ass_subscript_res_2 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1498;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_19efd769ae32e39375b5f91ec8fbb547 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_19efd769ae32e39375b5f91ec8fbb547 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_19efd769ae32e39375b5f91ec8fbb547, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_19efd769ae32e39375b5f91ec8fbb547->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_19efd769ae32e39375b5f91ec8fbb547, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_19efd769ae32e39375b5f91ec8fbb547, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_19efd769ae32e39375b5f91ec8fbb547 == cache_frame_19efd769ae32e39375b5f91ec8fbb547 )
    {
        Py_DECREF( frame_19efd769ae32e39375b5f91ec8fbb547 );
    }
    cache_frame_19efd769ae32e39375b5f91ec8fbb547 = NULL;

    assertFrameObject( frame_19efd769ae32e39375b5f91ec8fbb547 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_124_p_assignment_expression );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_124_p_assignment_expression );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_125_p_assignment_operator( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_return_value;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_a7092856904714539f2d6ca7e3306ef6 = NULL;

    struct Nuitka_FrameObject *frame_a7092856904714539f2d6ca7e3306ef6;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a7092856904714539f2d6ca7e3306ef6, codeobj_a7092856904714539f2d6ca7e3306ef6, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_a7092856904714539f2d6ca7e3306ef6 = cache_frame_a7092856904714539f2d6ca7e3306ef6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a7092856904714539f2d6ca7e3306ef6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a7092856904714539f2d6ca7e3306ef6 ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1518;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1518;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1518;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a7092856904714539f2d6ca7e3306ef6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a7092856904714539f2d6ca7e3306ef6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a7092856904714539f2d6ca7e3306ef6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a7092856904714539f2d6ca7e3306ef6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a7092856904714539f2d6ca7e3306ef6, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_a7092856904714539f2d6ca7e3306ef6, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_a7092856904714539f2d6ca7e3306ef6 == cache_frame_a7092856904714539f2d6ca7e3306ef6 )
    {
        Py_DECREF( frame_a7092856904714539f2d6ca7e3306ef6 );
    }
    cache_frame_a7092856904714539f2d6ca7e3306ef6 = NULL;

    assertFrameObject( frame_a7092856904714539f2d6ca7e3306ef6 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_125_p_assignment_operator );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_125_p_assignment_operator );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_126_p_constant_expression( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_return_value;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_d1032335e18e686c5a3e07c2a5efdd4f = NULL;

    struct Nuitka_FrameObject *frame_d1032335e18e686c5a3e07c2a5efdd4f;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_d1032335e18e686c5a3e07c2a5efdd4f, codeobj_d1032335e18e686c5a3e07c2a5efdd4f, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_d1032335e18e686c5a3e07c2a5efdd4f = cache_frame_d1032335e18e686c5a3e07c2a5efdd4f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_d1032335e18e686c5a3e07c2a5efdd4f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_d1032335e18e686c5a3e07c2a5efdd4f ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1522;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1522;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1522;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d1032335e18e686c5a3e07c2a5efdd4f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_d1032335e18e686c5a3e07c2a5efdd4f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_d1032335e18e686c5a3e07c2a5efdd4f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_d1032335e18e686c5a3e07c2a5efdd4f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_d1032335e18e686c5a3e07c2a5efdd4f, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_d1032335e18e686c5a3e07c2a5efdd4f, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_d1032335e18e686c5a3e07c2a5efdd4f == cache_frame_d1032335e18e686c5a3e07c2a5efdd4f )
    {
        Py_DECREF( frame_d1032335e18e686c5a3e07c2a5efdd4f );
    }
    cache_frame_d1032335e18e686c5a3e07c2a5efdd4f = NULL;

    assertFrameObject( frame_d1032335e18e686c5a3e07c2a5efdd4f );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_126_p_constant_expression );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_126_p_constant_expression );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_127_p_conditional_expression( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscribed_2;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subscript_2;
    int tmp_ass_subscript_res_1;
    int tmp_ass_subscript_res_2;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_ass_subvalue_2;
    PyObject *tmp_called_name_1;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscribed_name_5;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    PyObject *tmp_subscript_name_5;
    static struct Nuitka_FrameObject *cache_frame_db82277e54d8ea03459ccc4903704992 = NULL;

    struct Nuitka_FrameObject *frame_db82277e54d8ea03459ccc4903704992;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_db82277e54d8ea03459ccc4903704992, codeobj_db82277e54d8ea03459ccc4903704992, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_db82277e54d8ea03459ccc4903704992 = cache_frame_db82277e54d8ea03459ccc4903704992;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_db82277e54d8ea03459ccc4903704992 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_db82277e54d8ea03459ccc4903704992 ) == 2 ); // Frame stack

    // Framed code:
    tmp_len_arg_1 = par_p;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1528;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_pos_2;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 1528;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1529;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1529;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1529;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1529;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto branch_end_1;
    branch_no_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1531;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_TernaryOp );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1531;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1531;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_1;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1531;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1531;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_3;
    tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1531;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_4 = par_p;

    if ( tmp_subscribed_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1531;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_4 = const_int_pos_5;
    tmp_args_element_name_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_4 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1531;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_5 = par_p;

    if ( tmp_subscribed_name_5 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1531;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_5 = const_int_pos_1;
    tmp_source_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_5, tmp_subscript_name_5 );
    if ( tmp_source_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );

        exception_lineno = 1531;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_coord );
    Py_DECREF( tmp_source_name_2 );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );

        exception_lineno = 1531;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_db82277e54d8ea03459ccc4903704992->m_frame.f_lineno = 1531;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_ass_subvalue_2 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_ass_subvalue_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1531;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_2 = par_p;

    if ( tmp_ass_subscribed_2 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1531;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_2 = const_int_0;
    tmp_ass_subscript_res_2 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_2, tmp_ass_subscript_2, 0, tmp_ass_subvalue_2 );
    Py_DECREF( tmp_ass_subvalue_2 );
    if ( tmp_ass_subscript_res_2 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1531;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_db82277e54d8ea03459ccc4903704992 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_db82277e54d8ea03459ccc4903704992 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_db82277e54d8ea03459ccc4903704992, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_db82277e54d8ea03459ccc4903704992->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_db82277e54d8ea03459ccc4903704992, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_db82277e54d8ea03459ccc4903704992, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_db82277e54d8ea03459ccc4903704992 == cache_frame_db82277e54d8ea03459ccc4903704992 )
    {
        Py_DECREF( frame_db82277e54d8ea03459ccc4903704992 );
    }
    cache_frame_db82277e54d8ea03459ccc4903704992 = NULL;

    assertFrameObject( frame_db82277e54d8ea03459ccc4903704992 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_127_p_conditional_expression );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_127_p_conditional_expression );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_128_p_binary_expression( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscribed_2;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subscript_2;
    int tmp_ass_subscript_res_1;
    int tmp_ass_subscript_res_2;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_ass_subvalue_2;
    PyObject *tmp_called_name_1;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscribed_name_5;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    PyObject *tmp_subscript_name_5;
    static struct Nuitka_FrameObject *cache_frame_3beaa24096ba678266b7ce5a127daf1e = NULL;

    struct Nuitka_FrameObject *frame_3beaa24096ba678266b7ce5a127daf1e;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3beaa24096ba678266b7ce5a127daf1e, codeobj_3beaa24096ba678266b7ce5a127daf1e, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_3beaa24096ba678266b7ce5a127daf1e = cache_frame_3beaa24096ba678266b7ce5a127daf1e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3beaa24096ba678266b7ce5a127daf1e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3beaa24096ba678266b7ce5a127daf1e ) == 2 ); // Frame stack

    // Framed code:
    tmp_len_arg_1 = par_p;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1554;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_pos_2;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 1554;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1555;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1555;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1555;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1555;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto branch_end_1;
    branch_no_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1557;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_BinaryOp );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1557;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1557;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_2;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1557;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1557;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_1;
    tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1557;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_4 = par_p;

    if ( tmp_subscribed_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1557;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_4 = const_int_pos_3;
    tmp_args_element_name_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_4 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1557;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_5 = par_p;

    if ( tmp_subscribed_name_5 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1557;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_5 = const_int_pos_1;
    tmp_source_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_5, tmp_subscript_name_5 );
    if ( tmp_source_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );

        exception_lineno = 1557;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_coord );
    Py_DECREF( tmp_source_name_2 );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_args_element_name_3 );

        exception_lineno = 1557;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_3beaa24096ba678266b7ce5a127daf1e->m_frame.f_lineno = 1557;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_ass_subvalue_2 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_ass_subvalue_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1557;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_2 = par_p;

    if ( tmp_ass_subscribed_2 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1557;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_2 = const_int_0;
    tmp_ass_subscript_res_2 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_2, tmp_ass_subscript_2, 0, tmp_ass_subvalue_2 );
    Py_DECREF( tmp_ass_subvalue_2 );
    if ( tmp_ass_subscript_res_2 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1557;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3beaa24096ba678266b7ce5a127daf1e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3beaa24096ba678266b7ce5a127daf1e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3beaa24096ba678266b7ce5a127daf1e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3beaa24096ba678266b7ce5a127daf1e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3beaa24096ba678266b7ce5a127daf1e, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_3beaa24096ba678266b7ce5a127daf1e, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_3beaa24096ba678266b7ce5a127daf1e == cache_frame_3beaa24096ba678266b7ce5a127daf1e )
    {
        Py_DECREF( frame_3beaa24096ba678266b7ce5a127daf1e );
    }
    cache_frame_3beaa24096ba678266b7ce5a127daf1e = NULL;

    assertFrameObject( frame_3beaa24096ba678266b7ce5a127daf1e );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_128_p_binary_expression );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_128_p_binary_expression );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_129_p_cast_expression_1( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_return_value;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_6c76c6b906bebc731427f45496dd9bfe = NULL;

    struct Nuitka_FrameObject *frame_6c76c6b906bebc731427f45496dd9bfe;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6c76c6b906bebc731427f45496dd9bfe, codeobj_6c76c6b906bebc731427f45496dd9bfe, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_6c76c6b906bebc731427f45496dd9bfe = cache_frame_6c76c6b906bebc731427f45496dd9bfe;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6c76c6b906bebc731427f45496dd9bfe );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6c76c6b906bebc731427f45496dd9bfe ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1561;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1561;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1561;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6c76c6b906bebc731427f45496dd9bfe );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6c76c6b906bebc731427f45496dd9bfe );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6c76c6b906bebc731427f45496dd9bfe, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6c76c6b906bebc731427f45496dd9bfe->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6c76c6b906bebc731427f45496dd9bfe, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_6c76c6b906bebc731427f45496dd9bfe, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_6c76c6b906bebc731427f45496dd9bfe == cache_frame_6c76c6b906bebc731427f45496dd9bfe )
    {
        Py_DECREF( frame_6c76c6b906bebc731427f45496dd9bfe );
    }
    cache_frame_6c76c6b906bebc731427f45496dd9bfe = NULL;

    assertFrameObject( frame_6c76c6b906bebc731427f45496dd9bfe );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_129_p_cast_expression_1 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_129_p_cast_expression_1 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_130_p_cast_expression_2( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    static struct Nuitka_FrameObject *cache_frame_44fecbd2cd73bf009220006e0cf1357f = NULL;

    struct Nuitka_FrameObject *frame_44fecbd2cd73bf009220006e0cf1357f;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_44fecbd2cd73bf009220006e0cf1357f, codeobj_44fecbd2cd73bf009220006e0cf1357f, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_44fecbd2cd73bf009220006e0cf1357f = cache_frame_44fecbd2cd73bf009220006e0cf1357f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_44fecbd2cd73bf009220006e0cf1357f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_44fecbd2cd73bf009220006e0cf1357f ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1565;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_Cast );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1565;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1565;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_2;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1565;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1565;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_4;
    tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1565;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1565;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1565;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = par_p;

    if ( tmp_args_element_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1565;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = const_int_pos_1;
    frame_44fecbd2cd73bf009220006e0cf1357f->m_frame.f_lineno = 1565;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_args_element_name_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1565;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_44fecbd2cd73bf009220006e0cf1357f->m_frame.f_lineno = 1565;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1565;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1565;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1565;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_44fecbd2cd73bf009220006e0cf1357f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_44fecbd2cd73bf009220006e0cf1357f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_44fecbd2cd73bf009220006e0cf1357f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_44fecbd2cd73bf009220006e0cf1357f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_44fecbd2cd73bf009220006e0cf1357f, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_44fecbd2cd73bf009220006e0cf1357f, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_44fecbd2cd73bf009220006e0cf1357f == cache_frame_44fecbd2cd73bf009220006e0cf1357f )
    {
        Py_DECREF( frame_44fecbd2cd73bf009220006e0cf1357f );
    }
    cache_frame_44fecbd2cd73bf009220006e0cf1357f = NULL;

    assertFrameObject( frame_44fecbd2cd73bf009220006e0cf1357f );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_130_p_cast_expression_2 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_130_p_cast_expression_2 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_131_p_unary_expression_1( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_return_value;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_2805b5236c257d9892595ef331fe32b7 = NULL;

    struct Nuitka_FrameObject *frame_2805b5236c257d9892595ef331fe32b7;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2805b5236c257d9892595ef331fe32b7, codeobj_2805b5236c257d9892595ef331fe32b7, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_2805b5236c257d9892595ef331fe32b7 = cache_frame_2805b5236c257d9892595ef331fe32b7;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2805b5236c257d9892595ef331fe32b7 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2805b5236c257d9892595ef331fe32b7 ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1569;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1569;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1569;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2805b5236c257d9892595ef331fe32b7 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2805b5236c257d9892595ef331fe32b7 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2805b5236c257d9892595ef331fe32b7, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2805b5236c257d9892595ef331fe32b7->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2805b5236c257d9892595ef331fe32b7, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_2805b5236c257d9892595ef331fe32b7, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_2805b5236c257d9892595ef331fe32b7 == cache_frame_2805b5236c257d9892595ef331fe32b7 )
    {
        Py_DECREF( frame_2805b5236c257d9892595ef331fe32b7 );
    }
    cache_frame_2805b5236c257d9892595ef331fe32b7 = NULL;

    assertFrameObject( frame_2805b5236c257d9892595ef331fe32b7 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_131_p_unary_expression_1 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_131_p_unary_expression_1 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_132_p_unary_expression_2( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    static struct Nuitka_FrameObject *cache_frame_5cc8d94a5e1fe1d058d2dc0e268f0c82 = NULL;

    struct Nuitka_FrameObject *frame_5cc8d94a5e1fe1d058d2dc0e268f0c82;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5cc8d94a5e1fe1d058d2dc0e268f0c82, codeobj_5cc8d94a5e1fe1d058d2dc0e268f0c82, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_5cc8d94a5e1fe1d058d2dc0e268f0c82 = cache_frame_5cc8d94a5e1fe1d058d2dc0e268f0c82;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5cc8d94a5e1fe1d058d2dc0e268f0c82 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5cc8d94a5e1fe1d058d2dc0e268f0c82 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1576;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_UnaryOp );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1576;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1576;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1576;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1576;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_2;
    tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1576;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1576;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_2;
    tmp_source_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_source_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1576;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_coord );
    Py_DECREF( tmp_source_name_2 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1576;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_5cc8d94a5e1fe1d058d2dc0e268f0c82->m_frame.f_lineno = 1576;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1576;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1576;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1576;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5cc8d94a5e1fe1d058d2dc0e268f0c82 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5cc8d94a5e1fe1d058d2dc0e268f0c82 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5cc8d94a5e1fe1d058d2dc0e268f0c82, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5cc8d94a5e1fe1d058d2dc0e268f0c82->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5cc8d94a5e1fe1d058d2dc0e268f0c82, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_5cc8d94a5e1fe1d058d2dc0e268f0c82, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_5cc8d94a5e1fe1d058d2dc0e268f0c82 == cache_frame_5cc8d94a5e1fe1d058d2dc0e268f0c82 )
    {
        Py_DECREF( frame_5cc8d94a5e1fe1d058d2dc0e268f0c82 );
    }
    cache_frame_5cc8d94a5e1fe1d058d2dc0e268f0c82 = NULL;

    assertFrameObject( frame_5cc8d94a5e1fe1d058d2dc0e268f0c82 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_132_p_unary_expression_2 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_132_p_unary_expression_2 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_133_p_unary_expression_3( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    static struct Nuitka_FrameObject *cache_frame_8b7d7117faec7d0aef260da43d40c207 = NULL;

    struct Nuitka_FrameObject *frame_8b7d7117faec7d0aef260da43d40c207;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_8b7d7117faec7d0aef260da43d40c207, codeobj_8b7d7117faec7d0aef260da43d40c207, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_8b7d7117faec7d0aef260da43d40c207 = cache_frame_8b7d7117faec7d0aef260da43d40c207;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_8b7d7117faec7d0aef260da43d40c207 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_8b7d7117faec7d0aef260da43d40c207 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1582;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_UnaryOp );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1582;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1583;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1583;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_len_arg_1 = par_p;

    if ( tmp_len_arg_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1584;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1584;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_pos_3;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 1584;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto condexpr_true_1;
    }
    else
    {
        goto condexpr_false_1;
    }
    condexpr_true_1:;
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1584;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_2;
    tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1584;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto condexpr_end_1;
    condexpr_false_1:;
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1584;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_3;
    tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1584;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    condexpr_end_1:;
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1585;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1585;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = par_p;

    if ( tmp_args_element_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1585;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = const_int_pos_1;
    frame_8b7d7117faec7d0aef260da43d40c207->m_frame.f_lineno = 1585;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_args_element_name_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1585;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_8b7d7117faec7d0aef260da43d40c207->m_frame.f_lineno = 1582;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1582;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1582;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1582;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8b7d7117faec7d0aef260da43d40c207 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_8b7d7117faec7d0aef260da43d40c207 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_8b7d7117faec7d0aef260da43d40c207, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_8b7d7117faec7d0aef260da43d40c207->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_8b7d7117faec7d0aef260da43d40c207, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_8b7d7117faec7d0aef260da43d40c207, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_8b7d7117faec7d0aef260da43d40c207 == cache_frame_8b7d7117faec7d0aef260da43d40c207 )
    {
        Py_DECREF( frame_8b7d7117faec7d0aef260da43d40c207 );
    }
    cache_frame_8b7d7117faec7d0aef260da43d40c207 = NULL;

    assertFrameObject( frame_8b7d7117faec7d0aef260da43d40c207 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_133_p_unary_expression_3 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_133_p_unary_expression_3 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_134_p_unary_operator( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_return_value;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_b4c79c4a2dd3535b415a0995f8471cae = NULL;

    struct Nuitka_FrameObject *frame_b4c79c4a2dd3535b415a0995f8471cae;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b4c79c4a2dd3535b415a0995f8471cae, codeobj_b4c79c4a2dd3535b415a0995f8471cae, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_b4c79c4a2dd3535b415a0995f8471cae = cache_frame_b4c79c4a2dd3535b415a0995f8471cae;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b4c79c4a2dd3535b415a0995f8471cae );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b4c79c4a2dd3535b415a0995f8471cae ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1595;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1595;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1595;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b4c79c4a2dd3535b415a0995f8471cae );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b4c79c4a2dd3535b415a0995f8471cae );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b4c79c4a2dd3535b415a0995f8471cae, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b4c79c4a2dd3535b415a0995f8471cae->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b4c79c4a2dd3535b415a0995f8471cae, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_b4c79c4a2dd3535b415a0995f8471cae, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_b4c79c4a2dd3535b415a0995f8471cae == cache_frame_b4c79c4a2dd3535b415a0995f8471cae )
    {
        Py_DECREF( frame_b4c79c4a2dd3535b415a0995f8471cae );
    }
    cache_frame_b4c79c4a2dd3535b415a0995f8471cae = NULL;

    assertFrameObject( frame_b4c79c4a2dd3535b415a0995f8471cae );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_134_p_unary_operator );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_134_p_unary_operator );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_135_p_postfix_expression_1( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_return_value;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_1fb46e7eab0421a5014bc4bf4a5b4563 = NULL;

    struct Nuitka_FrameObject *frame_1fb46e7eab0421a5014bc4bf4a5b4563;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_1fb46e7eab0421a5014bc4bf4a5b4563, codeobj_1fb46e7eab0421a5014bc4bf4a5b4563, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_1fb46e7eab0421a5014bc4bf4a5b4563 = cache_frame_1fb46e7eab0421a5014bc4bf4a5b4563;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_1fb46e7eab0421a5014bc4bf4a5b4563 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_1fb46e7eab0421a5014bc4bf4a5b4563 ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1599;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1599;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1599;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1fb46e7eab0421a5014bc4bf4a5b4563 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_1fb46e7eab0421a5014bc4bf4a5b4563 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_1fb46e7eab0421a5014bc4bf4a5b4563, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_1fb46e7eab0421a5014bc4bf4a5b4563->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_1fb46e7eab0421a5014bc4bf4a5b4563, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_1fb46e7eab0421a5014bc4bf4a5b4563, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_1fb46e7eab0421a5014bc4bf4a5b4563 == cache_frame_1fb46e7eab0421a5014bc4bf4a5b4563 )
    {
        Py_DECREF( frame_1fb46e7eab0421a5014bc4bf4a5b4563 );
    }
    cache_frame_1fb46e7eab0421a5014bc4bf4a5b4563 = NULL;

    assertFrameObject( frame_1fb46e7eab0421a5014bc4bf4a5b4563 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_135_p_postfix_expression_1 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_135_p_postfix_expression_1 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_136_p_postfix_expression_2( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    static struct Nuitka_FrameObject *cache_frame_9d63efb08280aa9f3e1ade085e5671ce = NULL;

    struct Nuitka_FrameObject *frame_9d63efb08280aa9f3e1ade085e5671ce;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_9d63efb08280aa9f3e1ade085e5671ce, codeobj_9d63efb08280aa9f3e1ade085e5671ce, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_9d63efb08280aa9f3e1ade085e5671ce = cache_frame_9d63efb08280aa9f3e1ade085e5671ce;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_9d63efb08280aa9f3e1ade085e5671ce );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_9d63efb08280aa9f3e1ade085e5671ce ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1603;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_ArrayRef );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1603;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1603;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1603;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1603;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_3;
    tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1603;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1603;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_1;
    tmp_source_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_source_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1603;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_coord );
    Py_DECREF( tmp_source_name_2 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1603;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_9d63efb08280aa9f3e1ade085e5671ce->m_frame.f_lineno = 1603;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1603;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1603;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1603;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9d63efb08280aa9f3e1ade085e5671ce );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_9d63efb08280aa9f3e1ade085e5671ce );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_9d63efb08280aa9f3e1ade085e5671ce, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_9d63efb08280aa9f3e1ade085e5671ce->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_9d63efb08280aa9f3e1ade085e5671ce, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_9d63efb08280aa9f3e1ade085e5671ce, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_9d63efb08280aa9f3e1ade085e5671ce == cache_frame_9d63efb08280aa9f3e1ade085e5671ce )
    {
        Py_DECREF( frame_9d63efb08280aa9f3e1ade085e5671ce );
    }
    cache_frame_9d63efb08280aa9f3e1ade085e5671ce = NULL;

    assertFrameObject( frame_9d63efb08280aa9f3e1ade085e5671ce );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_136_p_postfix_expression_2 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_136_p_postfix_expression_2 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_137_p_postfix_expression_3( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    static struct Nuitka_FrameObject *cache_frame_12651dd7f01f4a368063187baf6a9878 = NULL;

    struct Nuitka_FrameObject *frame_12651dd7f01f4a368063187baf6a9878;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_12651dd7f01f4a368063187baf6a9878, codeobj_12651dd7f01f4a368063187baf6a9878, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_12651dd7f01f4a368063187baf6a9878 = cache_frame_12651dd7f01f4a368063187baf6a9878;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_12651dd7f01f4a368063187baf6a9878 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_12651dd7f01f4a368063187baf6a9878 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1609;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_FuncCall );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1609;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1609;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1609;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_len_arg_1 = par_p;

    if ( tmp_len_arg_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1609;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1609;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_pos_5;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 1609;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto condexpr_true_1;
    }
    else
    {
        goto condexpr_false_1;
    }
    condexpr_true_1:;
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1609;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_3;
    tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1609;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto condexpr_end_1;
    condexpr_false_1:;
    tmp_args_element_name_2 = Py_None;
    Py_INCREF( tmp_args_element_name_2 );
    condexpr_end_1:;
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1609;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_1;
    tmp_source_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_source_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1609;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_coord );
    Py_DECREF( tmp_source_name_2 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1609;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_12651dd7f01f4a368063187baf6a9878->m_frame.f_lineno = 1609;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1609;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1609;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1609;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_12651dd7f01f4a368063187baf6a9878 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_12651dd7f01f4a368063187baf6a9878 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_12651dd7f01f4a368063187baf6a9878, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_12651dd7f01f4a368063187baf6a9878->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_12651dd7f01f4a368063187baf6a9878, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_12651dd7f01f4a368063187baf6a9878, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_12651dd7f01f4a368063187baf6a9878 == cache_frame_12651dd7f01f4a368063187baf6a9878 )
    {
        Py_DECREF( frame_12651dd7f01f4a368063187baf6a9878 );
    }
    cache_frame_12651dd7f01f4a368063187baf6a9878 = NULL;

    assertFrameObject( frame_12651dd7f01f4a368063187baf6a9878 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_137_p_postfix_expression_3 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_137_p_postfix_expression_3 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_138_p_postfix_expression_4( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *var_field = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    static struct Nuitka_FrameObject *cache_frame_21b21c0e9aa6489741377e3025474a8d = NULL;

    struct Nuitka_FrameObject *frame_21b21c0e9aa6489741377e3025474a8d;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_21b21c0e9aa6489741377e3025474a8d, codeobj_21b21c0e9aa6489741377e3025474a8d, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_21b21c0e9aa6489741377e3025474a8d = cache_frame_21b21c0e9aa6489741377e3025474a8d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_21b21c0e9aa6489741377e3025474a8d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_21b21c0e9aa6489741377e3025474a8d ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1617;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_ID );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1617;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1617;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_3;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1617;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1617;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1617;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = par_p;

    if ( tmp_args_element_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1617;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = const_int_pos_3;
    frame_21b21c0e9aa6489741377e3025474a8d->m_frame.f_lineno = 1617;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_args_element_name_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1617;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    frame_21b21c0e9aa6489741377e3025474a8d->m_frame.f_lineno = 1617;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1617;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_field == NULL );
    var_field = tmp_assign_source_1;

    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1618;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_StructRef );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1618;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1618;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_1;
    tmp_args_element_name_5 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1618;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1618;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_2;
    tmp_args_element_name_6 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );

        exception_lineno = 1618;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_7 = var_field;

    if ( tmp_args_element_name_7 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );
        Py_DECREF( tmp_args_element_name_6 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "field" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1618;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscribed_name_4 = par_p;

    if ( tmp_subscribed_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );
        Py_DECREF( tmp_args_element_name_6 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1618;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_4 = const_int_pos_1;
    tmp_source_name_4 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_4 );
    if ( tmp_source_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );
        Py_DECREF( tmp_args_element_name_6 );

        exception_lineno = 1618;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_coord );
    Py_DECREF( tmp_source_name_4 );
    if ( tmp_args_element_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );
        Py_DECREF( tmp_args_element_name_6 );

        exception_lineno = 1618;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    frame_21b21c0e9aa6489741377e3025474a8d->m_frame.f_lineno = 1618;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_5 );
    Py_DECREF( tmp_args_element_name_6 );
    Py_DECREF( tmp_args_element_name_8 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1618;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1618;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1618;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_21b21c0e9aa6489741377e3025474a8d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_21b21c0e9aa6489741377e3025474a8d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_21b21c0e9aa6489741377e3025474a8d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_21b21c0e9aa6489741377e3025474a8d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_21b21c0e9aa6489741377e3025474a8d, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_21b21c0e9aa6489741377e3025474a8d, type_description ,par_self, par_p, var_field );

    // Release cached frame.
    if ( frame_21b21c0e9aa6489741377e3025474a8d == cache_frame_21b21c0e9aa6489741377e3025474a8d )
    {
        Py_DECREF( frame_21b21c0e9aa6489741377e3025474a8d );
    }
    cache_frame_21b21c0e9aa6489741377e3025474a8d = NULL;

    assertFrameObject( frame_21b21c0e9aa6489741377e3025474a8d );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_138_p_postfix_expression_4 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_field );
    var_field = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_field );
    var_field = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_138_p_postfix_expression_4 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_139_p_postfix_expression_5( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    static struct Nuitka_FrameObject *cache_frame_2f22fe77305a28e8416b02900417c1b5 = NULL;

    struct Nuitka_FrameObject *frame_2f22fe77305a28e8416b02900417c1b5;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2f22fe77305a28e8416b02900417c1b5, codeobj_2f22fe77305a28e8416b02900417c1b5, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_2f22fe77305a28e8416b02900417c1b5 = cache_frame_2f22fe77305a28e8416b02900417c1b5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2f22fe77305a28e8416b02900417c1b5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2f22fe77305a28e8416b02900417c1b5 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1624;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_UnaryOp );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1624;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_1 = const_str_plain_p;
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1624;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_2;
    tmp_right_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1624;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = BINARY_OPERATION_ADD( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1624;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1624;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_1;
    tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1624;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1624;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_1;
    tmp_source_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_source_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1624;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_coord );
    Py_DECREF( tmp_source_name_2 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1624;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_2f22fe77305a28e8416b02900417c1b5->m_frame.f_lineno = 1624;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1624;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1624;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1624;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2f22fe77305a28e8416b02900417c1b5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2f22fe77305a28e8416b02900417c1b5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2f22fe77305a28e8416b02900417c1b5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2f22fe77305a28e8416b02900417c1b5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2f22fe77305a28e8416b02900417c1b5, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_2f22fe77305a28e8416b02900417c1b5, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_2f22fe77305a28e8416b02900417c1b5 == cache_frame_2f22fe77305a28e8416b02900417c1b5 )
    {
        Py_DECREF( frame_2f22fe77305a28e8416b02900417c1b5 );
    }
    cache_frame_2f22fe77305a28e8416b02900417c1b5 = NULL;

    assertFrameObject( frame_2f22fe77305a28e8416b02900417c1b5 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_139_p_postfix_expression_5 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_139_p_postfix_expression_5 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_140_p_postfix_expression_6( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    static struct Nuitka_FrameObject *cache_frame_2ffe8752d69b5192793518d9b2bd5183 = NULL;

    struct Nuitka_FrameObject *frame_2ffe8752d69b5192793518d9b2bd5183;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_2ffe8752d69b5192793518d9b2bd5183, codeobj_2ffe8752d69b5192793518d9b2bd5183, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_2ffe8752d69b5192793518d9b2bd5183 = cache_frame_2ffe8752d69b5192793518d9b2bd5183;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_2ffe8752d69b5192793518d9b2bd5183 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_2ffe8752d69b5192793518d9b2bd5183 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1630;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_CompoundLiteral );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1630;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1630;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_2;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1630;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1630;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_5;
    tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1630;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_2ffe8752d69b5192793518d9b2bd5183->m_frame.f_lineno = 1630;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1630;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1630;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1630;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2ffe8752d69b5192793518d9b2bd5183 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_2ffe8752d69b5192793518d9b2bd5183 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_2ffe8752d69b5192793518d9b2bd5183, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_2ffe8752d69b5192793518d9b2bd5183->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_2ffe8752d69b5192793518d9b2bd5183, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_2ffe8752d69b5192793518d9b2bd5183, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_2ffe8752d69b5192793518d9b2bd5183 == cache_frame_2ffe8752d69b5192793518d9b2bd5183 )
    {
        Py_DECREF( frame_2ffe8752d69b5192793518d9b2bd5183 );
    }
    cache_frame_2ffe8752d69b5192793518d9b2bd5183 = NULL;

    assertFrameObject( frame_2ffe8752d69b5192793518d9b2bd5183 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_140_p_postfix_expression_6 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_140_p_postfix_expression_6 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_141_p_primary_expression_1( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_return_value;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_7aacc024cef287d47094c2e9272ac6a3 = NULL;

    struct Nuitka_FrameObject *frame_7aacc024cef287d47094c2e9272ac6a3;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_7aacc024cef287d47094c2e9272ac6a3, codeobj_7aacc024cef287d47094c2e9272ac6a3, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_7aacc024cef287d47094c2e9272ac6a3 = cache_frame_7aacc024cef287d47094c2e9272ac6a3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_7aacc024cef287d47094c2e9272ac6a3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_7aacc024cef287d47094c2e9272ac6a3 ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1634;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1634;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1634;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7aacc024cef287d47094c2e9272ac6a3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_7aacc024cef287d47094c2e9272ac6a3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_7aacc024cef287d47094c2e9272ac6a3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_7aacc024cef287d47094c2e9272ac6a3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_7aacc024cef287d47094c2e9272ac6a3, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_7aacc024cef287d47094c2e9272ac6a3, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_7aacc024cef287d47094c2e9272ac6a3 == cache_frame_7aacc024cef287d47094c2e9272ac6a3 )
    {
        Py_DECREF( frame_7aacc024cef287d47094c2e9272ac6a3 );
    }
    cache_frame_7aacc024cef287d47094c2e9272ac6a3 = NULL;

    assertFrameObject( frame_7aacc024cef287d47094c2e9272ac6a3 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_141_p_primary_expression_1 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_141_p_primary_expression_1 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_142_p_primary_expression_2( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_return_value;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_25ef2753338c990d7a75642de258fee4 = NULL;

    struct Nuitka_FrameObject *frame_25ef2753338c990d7a75642de258fee4;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_25ef2753338c990d7a75642de258fee4, codeobj_25ef2753338c990d7a75642de258fee4, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_25ef2753338c990d7a75642de258fee4 = cache_frame_25ef2753338c990d7a75642de258fee4;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_25ef2753338c990d7a75642de258fee4 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_25ef2753338c990d7a75642de258fee4 ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1638;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1638;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1638;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_25ef2753338c990d7a75642de258fee4 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_25ef2753338c990d7a75642de258fee4 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_25ef2753338c990d7a75642de258fee4, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_25ef2753338c990d7a75642de258fee4->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_25ef2753338c990d7a75642de258fee4, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_25ef2753338c990d7a75642de258fee4, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_25ef2753338c990d7a75642de258fee4 == cache_frame_25ef2753338c990d7a75642de258fee4 )
    {
        Py_DECREF( frame_25ef2753338c990d7a75642de258fee4 );
    }
    cache_frame_25ef2753338c990d7a75642de258fee4 = NULL;

    assertFrameObject( frame_25ef2753338c990d7a75642de258fee4 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_142_p_primary_expression_2 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_142_p_primary_expression_2 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_143_p_primary_expression_3( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_return_value;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_79eb7006626f9d871293d99e614159a9 = NULL;

    struct Nuitka_FrameObject *frame_79eb7006626f9d871293d99e614159a9;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_79eb7006626f9d871293d99e614159a9, codeobj_79eb7006626f9d871293d99e614159a9, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_79eb7006626f9d871293d99e614159a9 = cache_frame_79eb7006626f9d871293d99e614159a9;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_79eb7006626f9d871293d99e614159a9 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_79eb7006626f9d871293d99e614159a9 ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1644;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1644;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1644;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_79eb7006626f9d871293d99e614159a9 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_79eb7006626f9d871293d99e614159a9 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_79eb7006626f9d871293d99e614159a9, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_79eb7006626f9d871293d99e614159a9->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_79eb7006626f9d871293d99e614159a9, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_79eb7006626f9d871293d99e614159a9, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_79eb7006626f9d871293d99e614159a9 == cache_frame_79eb7006626f9d871293d99e614159a9 )
    {
        Py_DECREF( frame_79eb7006626f9d871293d99e614159a9 );
    }
    cache_frame_79eb7006626f9d871293d99e614159a9 = NULL;

    assertFrameObject( frame_79eb7006626f9d871293d99e614159a9 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_143_p_primary_expression_3 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_143_p_primary_expression_3 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_144_p_primary_expression_4( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_return_value;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_6fe279688e2cd7bc46d2d64929e946b5 = NULL;

    struct Nuitka_FrameObject *frame_6fe279688e2cd7bc46d2d64929e946b5;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_6fe279688e2cd7bc46d2d64929e946b5, codeobj_6fe279688e2cd7bc46d2d64929e946b5, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_6fe279688e2cd7bc46d2d64929e946b5 = cache_frame_6fe279688e2cd7bc46d2d64929e946b5;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_6fe279688e2cd7bc46d2d64929e946b5 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_6fe279688e2cd7bc46d2d64929e946b5 ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_2;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1648;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1648;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1648;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6fe279688e2cd7bc46d2d64929e946b5 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_6fe279688e2cd7bc46d2d64929e946b5 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_6fe279688e2cd7bc46d2d64929e946b5, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_6fe279688e2cd7bc46d2d64929e946b5->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_6fe279688e2cd7bc46d2d64929e946b5, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_6fe279688e2cd7bc46d2d64929e946b5, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_6fe279688e2cd7bc46d2d64929e946b5 == cache_frame_6fe279688e2cd7bc46d2d64929e946b5 )
    {
        Py_DECREF( frame_6fe279688e2cd7bc46d2d64929e946b5 );
    }
    cache_frame_6fe279688e2cd7bc46d2d64929e946b5 = NULL;

    assertFrameObject( frame_6fe279688e2cd7bc46d2d64929e946b5 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_144_p_primary_expression_4 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_144_p_primary_expression_4 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_145_p_primary_expression_5( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *var_coord = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_list_element_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    static struct Nuitka_FrameObject *cache_frame_3ebb659f536809e4475d45060ad98408 = NULL;

    struct Nuitka_FrameObject *frame_3ebb659f536809e4475d45060ad98408;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_3ebb659f536809e4475d45060ad98408, codeobj_3ebb659f536809e4475d45060ad98408, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_3ebb659f536809e4475d45060ad98408 = cache_frame_3ebb659f536809e4475d45060ad98408;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_3ebb659f536809e4475d45060ad98408 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_3ebb659f536809e4475d45060ad98408 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__token_coord );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1653;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_p;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1653;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = const_int_pos_1;
    frame_3ebb659f536809e4475d45060ad98408->m_frame.f_lineno = 1653;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1653;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_coord == NULL );
    var_coord = tmp_assign_source_1;

    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1654;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_FuncCall );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1654;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1654;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_ID );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1654;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1654;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_args_element_name_4 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1654;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_5 = var_coord;

    if ( tmp_args_element_name_5 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_4 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "coord" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1654;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    frame_3ebb659f536809e4475d45060ad98408->m_frame.f_lineno = 1654;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_args_element_name_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1654;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1655;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_ExprList );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );

        exception_lineno = 1655;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_7 = PyList_New( 2 );
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_7 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1655;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_3;
    tmp_list_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_list_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_7 );

        exception_lineno = 1655;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    PyList_SET_ITEM( tmp_args_element_name_7, 0, tmp_list_element_1 );
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_7 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1655;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_5;
    tmp_list_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_list_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_7 );

        exception_lineno = 1655;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    PyList_SET_ITEM( tmp_args_element_name_7, 1, tmp_list_element_1 );
    tmp_args_element_name_8 = var_coord;

    if ( tmp_args_element_name_8 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_7 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "coord" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1655;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    frame_3ebb659f536809e4475d45060ad98408->m_frame.f_lineno = 1655;
    {
        PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8 };
        tmp_args_element_name_6 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_7 );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );

        exception_lineno = 1655;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_9 = var_coord;

    if ( tmp_args_element_name_9 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_3 );
        Py_DECREF( tmp_args_element_name_6 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "coord" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1656;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    frame_3ebb659f536809e4475d45060ad98408->m_frame.f_lineno = 1654;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_6, tmp_args_element_name_9 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1654;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1654;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1654;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3ebb659f536809e4475d45060ad98408 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_3ebb659f536809e4475d45060ad98408 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_3ebb659f536809e4475d45060ad98408, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_3ebb659f536809e4475d45060ad98408->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_3ebb659f536809e4475d45060ad98408, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_3ebb659f536809e4475d45060ad98408, type_description ,par_self, par_p, var_coord );

    // Release cached frame.
    if ( frame_3ebb659f536809e4475d45060ad98408 == cache_frame_3ebb659f536809e4475d45060ad98408 )
    {
        Py_DECREF( frame_3ebb659f536809e4475d45060ad98408 );
    }
    cache_frame_3ebb659f536809e4475d45060ad98408 = NULL;

    assertFrameObject( frame_3ebb659f536809e4475d45060ad98408 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_145_p_primary_expression_5 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_coord );
    var_coord = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_coord );
    var_coord = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_145_p_primary_expression_5 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_146_p_offsetof_member_designator( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *var_field = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscribed_2;
    PyObject *tmp_ass_subscribed_3;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subscript_2;
    PyObject *tmp_ass_subscript_3;
    int tmp_ass_subscript_res_1;
    int tmp_ass_subscript_res_2;
    int tmp_ass_subscript_res_3;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_ass_subvalue_2;
    PyObject *tmp_ass_subvalue_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Eq_2;
    int tmp_cmp_Eq_3;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_left_name_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_len_arg_2;
    PyObject *tmp_len_arg_3;
    PyObject *tmp_len_arg_4;
    PyObject *tmp_make_exception_arg_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscribed_name_5;
    PyObject *tmp_subscribed_name_6;
    PyObject *tmp_subscribed_name_7;
    PyObject *tmp_subscribed_name_8;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    PyObject *tmp_subscript_name_5;
    PyObject *tmp_subscript_name_6;
    PyObject *tmp_subscript_name_7;
    PyObject *tmp_subscript_name_8;
    static struct Nuitka_FrameObject *cache_frame_16109f170a5b0bf37839ac5e2c0e961f = NULL;

    struct Nuitka_FrameObject *frame_16109f170a5b0bf37839ac5e2c0e961f;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_16109f170a5b0bf37839ac5e2c0e961f, codeobj_16109f170a5b0bf37839ac5e2c0e961f, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_16109f170a5b0bf37839ac5e2c0e961f = cache_frame_16109f170a5b0bf37839ac5e2c0e961f;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_16109f170a5b0bf37839ac5e2c0e961f );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_16109f170a5b0bf37839ac5e2c0e961f ) == 2 ); // Frame stack

    // Framed code:
    tmp_len_arg_1 = par_p;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1663;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_pos_2;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 1663;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1664;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1664;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1664;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1664;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    goto branch_end_1;
    branch_no_1:;
    tmp_len_arg_2 = par_p;

    if ( tmp_len_arg_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1665;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_left_2 = BUILTIN_LEN( tmp_len_arg_2 );
    if ( tmp_compare_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1665;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_2 = const_int_pos_4;
    tmp_cmp_Eq_2 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_2 );

        exception_lineno = 1665;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_2 );
    if ( tmp_cmp_Eq_2 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1666;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_ID );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1666;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1666;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_3;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1666;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1666;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1666;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = par_p;

    if ( tmp_args_element_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1666;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = const_int_pos_3;
    frame_16109f170a5b0bf37839ac5e2c0e961f->m_frame.f_lineno = 1666;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_args_element_name_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1666;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    frame_16109f170a5b0bf37839ac5e2c0e961f->m_frame.f_lineno = 1666;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1666;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_field == NULL );
    var_field = tmp_assign_source_1;

    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1667;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_StructRef );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1667;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1667;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_1;
    tmp_args_element_name_5 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1667;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_4 = par_p;

    if ( tmp_subscribed_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1667;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_4 = const_int_pos_2;
    tmp_args_element_name_6 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_4 );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );

        exception_lineno = 1667;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_7 = var_field;

    if ( tmp_args_element_name_7 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );
        Py_DECREF( tmp_args_element_name_6 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "field" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1667;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscribed_name_5 = par_p;

    if ( tmp_subscribed_name_5 == NULL )
    {
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );
        Py_DECREF( tmp_args_element_name_6 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1667;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_5 = const_int_pos_1;
    tmp_source_name_4 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_5, tmp_subscript_name_5 );
    if ( tmp_source_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );
        Py_DECREF( tmp_args_element_name_6 );

        exception_lineno = 1667;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_coord );
    Py_DECREF( tmp_source_name_4 );
    if ( tmp_args_element_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_5 );
        Py_DECREF( tmp_args_element_name_6 );

        exception_lineno = 1667;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    frame_16109f170a5b0bf37839ac5e2c0e961f->m_frame.f_lineno = 1667;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8 };
        tmp_ass_subvalue_2 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_5 );
    Py_DECREF( tmp_args_element_name_6 );
    Py_DECREF( tmp_args_element_name_8 );
    if ( tmp_ass_subvalue_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1667;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_2 = par_p;

    if ( tmp_ass_subscribed_2 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1667;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_2 = const_int_0;
    tmp_ass_subscript_res_2 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_2, tmp_ass_subscript_2, 0, tmp_ass_subvalue_2 );
    Py_DECREF( tmp_ass_subvalue_2 );
    if ( tmp_ass_subscript_res_2 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1667;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    goto branch_end_2;
    branch_no_2:;
    tmp_len_arg_3 = par_p;

    if ( tmp_len_arg_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1668;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_left_3 = BUILTIN_LEN( tmp_len_arg_3 );
    if ( tmp_compare_left_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1668;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_3 = const_int_pos_5;
    tmp_cmp_Eq_3 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_cmp_Eq_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_3 );

        exception_lineno = 1668;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_3 );
    if ( tmp_cmp_Eq_3 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1669;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_ArrayRef );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1669;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_6 = par_p;

    if ( tmp_subscribed_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1669;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_6 = const_int_pos_1;
    tmp_args_element_name_9 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_6, tmp_subscript_name_6 );
    if ( tmp_args_element_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 1669;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_7 = par_p;

    if ( tmp_subscribed_name_7 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_9 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1669;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_7 = const_int_pos_3;
    tmp_args_element_name_10 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_7, tmp_subscript_name_7 );
    if ( tmp_args_element_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_9 );

        exception_lineno = 1669;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_8 = par_p;

    if ( tmp_subscribed_name_8 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_9 );
        Py_DECREF( tmp_args_element_name_10 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1669;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_8 = const_int_pos_1;
    tmp_source_name_6 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_8, tmp_subscript_name_8 );
    if ( tmp_source_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_9 );
        Py_DECREF( tmp_args_element_name_10 );

        exception_lineno = 1669;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_coord );
    Py_DECREF( tmp_source_name_6 );
    if ( tmp_args_element_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );
        Py_DECREF( tmp_args_element_name_9 );
        Py_DECREF( tmp_args_element_name_10 );

        exception_lineno = 1669;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    frame_16109f170a5b0bf37839ac5e2c0e961f->m_frame.f_lineno = 1669;
    {
        PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10, tmp_args_element_name_11 };
        tmp_ass_subvalue_3 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_9 );
    Py_DECREF( tmp_args_element_name_10 );
    Py_DECREF( tmp_args_element_name_11 );
    if ( tmp_ass_subvalue_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1669;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_3 = par_p;

    if ( tmp_ass_subscribed_3 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1669;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_3 = const_int_0;
    tmp_ass_subscript_res_3 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_3, tmp_ass_subscript_3, 0, tmp_ass_subvalue_3 );
    Py_DECREF( tmp_ass_subvalue_3 );
    if ( tmp_ass_subscript_res_3 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1669;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    goto branch_end_3;
    branch_no_3:;
    tmp_left_name_1 = const_str_digest_6e6c77e24cfc9a052b7d222f6e6f60cf;
    tmp_len_arg_4 = par_p;

    if ( tmp_len_arg_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1671;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_right_name_1 = BUILTIN_LEN( tmp_len_arg_4 );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1671;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_make_exception_arg_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_make_exception_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1671;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    frame_16109f170a5b0bf37839ac5e2c0e961f->m_frame.f_lineno = 1671;
    {
        PyObject *call_args[] = { tmp_make_exception_arg_1 };
        tmp_raise_type_1 = CALL_FUNCTION_WITH_ARGS1( PyExc_NotImplementedError, call_args );
    }

    Py_DECREF( tmp_make_exception_arg_1 );
    assert( tmp_raise_type_1 != NULL );
    exception_type = tmp_raise_type_1;
    exception_lineno = 1671;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooo";
    goto frame_exception_exit_1;
    branch_end_3:;
    branch_end_2:;
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_16109f170a5b0bf37839ac5e2c0e961f );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_16109f170a5b0bf37839ac5e2c0e961f );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_16109f170a5b0bf37839ac5e2c0e961f, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_16109f170a5b0bf37839ac5e2c0e961f->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_16109f170a5b0bf37839ac5e2c0e961f, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_16109f170a5b0bf37839ac5e2c0e961f, type_description ,par_self, par_p, var_field );

    // Release cached frame.
    if ( frame_16109f170a5b0bf37839ac5e2c0e961f == cache_frame_16109f170a5b0bf37839ac5e2c0e961f )
    {
        Py_DECREF( frame_16109f170a5b0bf37839ac5e2c0e961f );
    }
    cache_frame_16109f170a5b0bf37839ac5e2c0e961f = NULL;

    assertFrameObject( frame_16109f170a5b0bf37839ac5e2c0e961f );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_146_p_offsetof_member_designator );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_field );
    var_field = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    Py_XDECREF( var_field );
    var_field = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_146_p_offsetof_member_designator );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_147_p_argument_expression_list( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscribed_2;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subscript_2;
    int tmp_ass_subscript_res_1;
    int tmp_ass_subscript_res_2;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_ass_subvalue_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_list_element_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscribed_name_5;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    PyObject *tmp_subscript_name_5;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_ed8adc41ee899609c66034535486075c = NULL;

    struct Nuitka_FrameObject *frame_ed8adc41ee899609c66034535486075c;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_ed8adc41ee899609c66034535486075c, codeobj_ed8adc41ee899609c66034535486075c, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_ed8adc41ee899609c66034535486075c = cache_frame_ed8adc41ee899609c66034535486075c;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_ed8adc41ee899609c66034535486075c );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_ed8adc41ee899609c66034535486075c ) == 2 ); // Frame stack

    // Framed code:
    tmp_len_arg_1 = par_p;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1677;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_pos_2;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 1677;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1678;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_ExprList );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1678;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = PyList_New( 1 );
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1678;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_list_element_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_list_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1678;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyList_SET_ITEM( tmp_args_element_name_1, 0, tmp_list_element_1 );
    tmp_subscribed_name_2 = par_p;

    if ( tmp_subscribed_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1678;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_1;
    tmp_source_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_source_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1678;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_coord );
    Py_DECREF( tmp_source_name_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1678;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_ed8adc41ee899609c66034535486075c->m_frame.f_lineno = 1678;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1678;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1678;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1678;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto branch_end_1;
    branch_no_1:;
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1680;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_3 = const_int_pos_1;
    tmp_source_name_4 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_source_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1680;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_exprs );
    Py_DECREF( tmp_source_name_4 );
    if ( tmp_source_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1680;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_append );
    Py_DECREF( tmp_source_name_3 );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1680;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_4 = par_p;

    if ( tmp_subscribed_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1680;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_4 = const_int_pos_3;
    tmp_args_element_name_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_4 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 1680;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_ed8adc41ee899609c66034535486075c->m_frame.f_lineno = 1680;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1680;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_subscribed_name_5 = par_p;

    if ( tmp_subscribed_name_5 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1681;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_5 = const_int_pos_1;
    tmp_ass_subvalue_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_5, tmp_subscript_name_5 );
    if ( tmp_ass_subvalue_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1681;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_2 = par_p;

    if ( tmp_ass_subscribed_2 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1681;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_2 = const_int_0;
    tmp_ass_subscript_res_2 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_2, tmp_ass_subscript_2, 0, tmp_ass_subvalue_2 );
    Py_DECREF( tmp_ass_subvalue_2 );
    if ( tmp_ass_subscript_res_2 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1681;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ed8adc41ee899609c66034535486075c );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_ed8adc41ee899609c66034535486075c );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_ed8adc41ee899609c66034535486075c, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_ed8adc41ee899609c66034535486075c->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_ed8adc41ee899609c66034535486075c, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_ed8adc41ee899609c66034535486075c, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_ed8adc41ee899609c66034535486075c == cache_frame_ed8adc41ee899609c66034535486075c )
    {
        Py_DECREF( frame_ed8adc41ee899609c66034535486075c );
    }
    cache_frame_ed8adc41ee899609c66034535486075c = NULL;

    assertFrameObject( frame_ed8adc41ee899609c66034535486075c );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_147_p_argument_expression_list );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_147_p_argument_expression_list );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_148_p_identifier( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_5ef1b3a186f7c83e4c84a68674855a62 = NULL;

    struct Nuitka_FrameObject *frame_5ef1b3a186f7c83e4c84a68674855a62;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_5ef1b3a186f7c83e4c84a68674855a62, codeobj_5ef1b3a186f7c83e4c84a68674855a62, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_5ef1b3a186f7c83e4c84a68674855a62 = cache_frame_5ef1b3a186f7c83e4c84a68674855a62;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_5ef1b3a186f7c83e4c84a68674855a62 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_5ef1b3a186f7c83e4c84a68674855a62 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1685;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_ID );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1685;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1685;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_args_element_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1685;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1685;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1685;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = par_p;

    if ( tmp_args_element_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1685;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = const_int_pos_1;
    frame_5ef1b3a186f7c83e4c84a68674855a62->m_frame.f_lineno = 1685;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_args_element_name_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1685;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_5ef1b3a186f7c83e4c84a68674855a62->m_frame.f_lineno = 1685;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1685;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1685;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1685;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5ef1b3a186f7c83e4c84a68674855a62 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_5ef1b3a186f7c83e4c84a68674855a62 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_5ef1b3a186f7c83e4c84a68674855a62, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_5ef1b3a186f7c83e4c84a68674855a62->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_5ef1b3a186f7c83e4c84a68674855a62, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_5ef1b3a186f7c83e4c84a68674855a62, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_5ef1b3a186f7c83e4c84a68674855a62 == cache_frame_5ef1b3a186f7c83e4c84a68674855a62 )
    {
        Py_DECREF( frame_5ef1b3a186f7c83e4c84a68674855a62 );
    }
    cache_frame_5ef1b3a186f7c83e4c84a68674855a62 = NULL;

    assertFrameObject( frame_5ef1b3a186f7c83e4c84a68674855a62 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_148_p_identifier );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_148_p_identifier );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_149_p_constant_1( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_dac04a09bf559be9390265aa086c5b1b = NULL;

    struct Nuitka_FrameObject *frame_dac04a09bf559be9390265aa086c5b1b;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_dac04a09bf559be9390265aa086c5b1b, codeobj_dac04a09bf559be9390265aa086c5b1b, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_dac04a09bf559be9390265aa086c5b1b = cache_frame_dac04a09bf559be9390265aa086c5b1b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_dac04a09bf559be9390265aa086c5b1b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_dac04a09bf559be9390265aa086c5b1b ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1693;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_Constant );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1693;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = const_str_plain_int;
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1694;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1694;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1694;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1694;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = par_p;

    if ( tmp_args_element_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1694;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = const_int_pos_1;
    frame_dac04a09bf559be9390265aa086c5b1b->m_frame.f_lineno = 1694;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_args_element_name_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1694;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_dac04a09bf559be9390265aa086c5b1b->m_frame.f_lineno = 1693;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1693;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1693;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1693;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dac04a09bf559be9390265aa086c5b1b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_dac04a09bf559be9390265aa086c5b1b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_dac04a09bf559be9390265aa086c5b1b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_dac04a09bf559be9390265aa086c5b1b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_dac04a09bf559be9390265aa086c5b1b, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_dac04a09bf559be9390265aa086c5b1b, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_dac04a09bf559be9390265aa086c5b1b == cache_frame_dac04a09bf559be9390265aa086c5b1b )
    {
        Py_DECREF( frame_dac04a09bf559be9390265aa086c5b1b );
    }
    cache_frame_dac04a09bf559be9390265aa086c5b1b = NULL;

    assertFrameObject( frame_dac04a09bf559be9390265aa086c5b1b );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_149_p_constant_1 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_149_p_constant_1 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_150_p_constant_2( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_4280c780fe5eca45d1548e381c321c2e = NULL;

    struct Nuitka_FrameObject *frame_4280c780fe5eca45d1548e381c321c2e;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_4280c780fe5eca45d1548e381c321c2e, codeobj_4280c780fe5eca45d1548e381c321c2e, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_4280c780fe5eca45d1548e381c321c2e = cache_frame_4280c780fe5eca45d1548e381c321c2e;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_4280c780fe5eca45d1548e381c321c2e );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_4280c780fe5eca45d1548e381c321c2e ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1700;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_Constant );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1700;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = const_str_plain_float;
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1701;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1701;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1701;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1701;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = par_p;

    if ( tmp_args_element_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1701;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = const_int_pos_1;
    frame_4280c780fe5eca45d1548e381c321c2e->m_frame.f_lineno = 1701;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_args_element_name_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1701;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_4280c780fe5eca45d1548e381c321c2e->m_frame.f_lineno = 1700;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1700;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1700;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1700;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4280c780fe5eca45d1548e381c321c2e );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_4280c780fe5eca45d1548e381c321c2e );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_4280c780fe5eca45d1548e381c321c2e, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_4280c780fe5eca45d1548e381c321c2e->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_4280c780fe5eca45d1548e381c321c2e, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_4280c780fe5eca45d1548e381c321c2e, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_4280c780fe5eca45d1548e381c321c2e == cache_frame_4280c780fe5eca45d1548e381c321c2e )
    {
        Py_DECREF( frame_4280c780fe5eca45d1548e381c321c2e );
    }
    cache_frame_4280c780fe5eca45d1548e381c321c2e = NULL;

    assertFrameObject( frame_4280c780fe5eca45d1548e381c321c2e );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_150_p_constant_2 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_150_p_constant_2 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_151_p_constant_3( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_22889f6f9c19d187b7c4c8d88b7e4fa6 = NULL;

    struct Nuitka_FrameObject *frame_22889f6f9c19d187b7c4c8d88b7e4fa6;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_22889f6f9c19d187b7c4c8d88b7e4fa6, codeobj_22889f6f9c19d187b7c4c8d88b7e4fa6, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_22889f6f9c19d187b7c4c8d88b7e4fa6 = cache_frame_22889f6f9c19d187b7c4c8d88b7e4fa6;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_22889f6f9c19d187b7c4c8d88b7e4fa6 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_22889f6f9c19d187b7c4c8d88b7e4fa6 ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1707;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_Constant );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1707;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = const_str_plain_char;
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1708;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1708;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1708;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1708;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = par_p;

    if ( tmp_args_element_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1708;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = const_int_pos_1;
    frame_22889f6f9c19d187b7c4c8d88b7e4fa6->m_frame.f_lineno = 1708;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_args_element_name_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1708;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_22889f6f9c19d187b7c4c8d88b7e4fa6->m_frame.f_lineno = 1707;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1707;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1707;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1707;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_22889f6f9c19d187b7c4c8d88b7e4fa6 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_22889f6f9c19d187b7c4c8d88b7e4fa6 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_22889f6f9c19d187b7c4c8d88b7e4fa6, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_22889f6f9c19d187b7c4c8d88b7e4fa6->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_22889f6f9c19d187b7c4c8d88b7e4fa6, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_22889f6f9c19d187b7c4c8d88b7e4fa6, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_22889f6f9c19d187b7c4c8d88b7e4fa6 == cache_frame_22889f6f9c19d187b7c4c8d88b7e4fa6 )
    {
        Py_DECREF( frame_22889f6f9c19d187b7c4c8d88b7e4fa6 );
    }
    cache_frame_22889f6f9c19d187b7c4c8d88b7e4fa6 = NULL;

    assertFrameObject( frame_22889f6f9c19d187b7c4c8d88b7e4fa6 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_151_p_constant_3 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_151_p_constant_3 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_152_p_unified_string_literal( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscribed_2;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subscript_2;
    int tmp_ass_subscript_res_1;
    int tmp_ass_subscript_res_2;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_ass_subvalue_2;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_len_arg_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscribed_name_5;
    PyObject *tmp_subscribed_name_6;
    PyObject *tmp_subscribed_name_7;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    PyObject *tmp_subscript_name_5;
    PyObject *tmp_subscript_name_6;
    PyObject *tmp_subscript_name_7;
    static struct Nuitka_FrameObject *cache_frame_58509cdc3d7993928017f618fed741c3 = NULL;

    struct Nuitka_FrameObject *frame_58509cdc3d7993928017f618fed741c3;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_58509cdc3d7993928017f618fed741c3, codeobj_58509cdc3d7993928017f618fed741c3, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_58509cdc3d7993928017f618fed741c3 = cache_frame_58509cdc3d7993928017f618fed741c3;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_58509cdc3d7993928017f618fed741c3 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_58509cdc3d7993928017f618fed741c3 ) == 2 ); // Frame stack

    // Framed code:
    tmp_len_arg_1 = par_p;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1719;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_pos_2;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 1719;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1720;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_Constant );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1720;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = const_str_plain_string;
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1721;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1721;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1721;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1721;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = par_p;

    if ( tmp_args_element_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1721;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = const_int_pos_1;
    frame_58509cdc3d7993928017f618fed741c3->m_frame.f_lineno = 1721;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_args_element_name_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1721;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_58509cdc3d7993928017f618fed741c3->m_frame.f_lineno = 1720;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1720;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1720;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1720;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto branch_end_1;
    branch_no_1:;
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1723;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_1;
    tmp_source_name_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_2 );
    if ( tmp_source_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1723;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_value );
    Py_DECREF( tmp_source_name_3 );
    if ( tmp_subscribed_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1723;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_3 = const_slice_none_int_neg_1_none;
    tmp_left_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_3 );
    Py_DECREF( tmp_subscribed_name_2 );
    if ( tmp_left_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1723;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_5 = par_p;

    if ( tmp_subscribed_name_5 == NULL )
    {
        Py_DECREF( tmp_left_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1723;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_4 = const_int_pos_2;
    tmp_subscribed_name_4 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_5, tmp_subscript_name_4 );
    if ( tmp_subscribed_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_1 );

        exception_lineno = 1723;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_5 = const_slice_int_pos_1_none_none;
    tmp_right_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_5 );
    Py_DECREF( tmp_subscribed_name_4 );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_1 );

        exception_lineno = 1723;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_1 = BINARY_OPERATION_ADD( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_left_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1723;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_6 = par_p;

    if ( tmp_subscribed_name_6 == NULL )
    {
        Py_DECREF( tmp_assattr_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1723;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_6 = const_int_pos_1;
    tmp_assattr_target_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_6, tmp_subscript_name_6 );
    if ( tmp_assattr_target_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 1723;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_value, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_target_1 );

        exception_lineno = 1723;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );
    Py_DECREF( tmp_assattr_target_1 );
    tmp_subscribed_name_7 = par_p;

    if ( tmp_subscribed_name_7 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1724;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_7 = const_int_pos_1;
    tmp_ass_subvalue_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_7, tmp_subscript_name_7 );
    if ( tmp_ass_subvalue_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1724;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_2 = par_p;

    if ( tmp_ass_subscribed_2 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1724;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_2 = const_int_0;
    tmp_ass_subscript_res_2 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_2, tmp_ass_subscript_2, 0, tmp_ass_subvalue_2 );
    Py_DECREF( tmp_ass_subvalue_2 );
    if ( tmp_ass_subscript_res_2 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1724;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_58509cdc3d7993928017f618fed741c3 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_58509cdc3d7993928017f618fed741c3 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_58509cdc3d7993928017f618fed741c3, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_58509cdc3d7993928017f618fed741c3->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_58509cdc3d7993928017f618fed741c3, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_58509cdc3d7993928017f618fed741c3, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_58509cdc3d7993928017f618fed741c3 == cache_frame_58509cdc3d7993928017f618fed741c3 )
    {
        Py_DECREF( frame_58509cdc3d7993928017f618fed741c3 );
    }
    cache_frame_58509cdc3d7993928017f618fed741c3 = NULL;

    assertFrameObject( frame_58509cdc3d7993928017f618fed741c3 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_152_p_unified_string_literal );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_152_p_unified_string_literal );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_153_p_unified_wstring_literal( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscribed_2;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subscript_2;
    int tmp_ass_subscript_res_1;
    int tmp_ass_subscript_res_2;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_ass_subvalue_2;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_len_arg_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscribed_name_5;
    PyObject *tmp_subscribed_name_6;
    PyObject *tmp_subscribed_name_7;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    PyObject *tmp_subscript_name_5;
    PyObject *tmp_subscript_name_6;
    PyObject *tmp_subscript_name_7;
    static struct Nuitka_FrameObject *cache_frame_a488ed12a4b6217597f4f94e372f960d = NULL;

    struct Nuitka_FrameObject *frame_a488ed12a4b6217597f4f94e372f960d;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a488ed12a4b6217597f4f94e372f960d, codeobj_a488ed12a4b6217597f4f94e372f960d, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_a488ed12a4b6217597f4f94e372f960d = cache_frame_a488ed12a4b6217597f4f94e372f960d;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a488ed12a4b6217597f4f94e372f960d );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a488ed12a4b6217597f4f94e372f960d ) == 2 ); // Frame stack

    // Framed code:
    tmp_len_arg_1 = par_p;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1730;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_pos_2;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 1730;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_c_ast );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "c_ast" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1731;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_Constant );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1731;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = const_str_plain_string;
    tmp_subscribed_name_1 = par_p;

    if ( tmp_subscribed_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1732;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_1 = const_int_pos_1;
    tmp_args_element_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1732;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1732;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__token_coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1732;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = par_p;

    if ( tmp_args_element_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1732;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = const_int_pos_1;
    frame_a488ed12a4b6217597f4f94e372f960d->m_frame.f_lineno = 1732;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_args_element_name_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 1732;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_a488ed12a4b6217597f4f94e372f960d->m_frame.f_lineno = 1731;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_ass_subvalue_1 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1731;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1731;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1731;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto branch_end_1;
    branch_no_1:;
    tmp_subscribed_name_3 = par_p;

    if ( tmp_subscribed_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1734;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_2 = const_int_pos_1;
    tmp_source_name_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_2 );
    if ( tmp_source_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1734;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_value );
    Py_DECREF( tmp_source_name_3 );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1734;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_a488ed12a4b6217597f4f94e372f960d->m_frame.f_lineno = 1734;
    tmp_subscribed_name_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_rstrip );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_subscribed_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1734;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_3 = const_slice_none_int_neg_1_none;
    tmp_left_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_3 );
    Py_DECREF( tmp_subscribed_name_2 );
    if ( tmp_left_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1734;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_5 = par_p;

    if ( tmp_subscribed_name_5 == NULL )
    {
        Py_DECREF( tmp_left_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1734;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_4 = const_int_pos_2;
    tmp_subscribed_name_4 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_5, tmp_subscript_name_4 );
    if ( tmp_subscribed_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_1 );

        exception_lineno = 1734;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_5 = const_slice_int_pos_2_none_none;
    tmp_right_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_5 );
    Py_DECREF( tmp_subscribed_name_4 );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_1 );

        exception_lineno = 1734;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_1 = BINARY_OPERATION_ADD( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_left_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1734;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_subscribed_name_6 = par_p;

    if ( tmp_subscribed_name_6 == NULL )
    {
        Py_DECREF( tmp_assattr_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1734;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_6 = const_int_pos_1;
    tmp_assattr_target_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_6, tmp_subscript_name_6 );
    if ( tmp_assattr_target_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 1734;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_value, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );
        Py_DECREF( tmp_assattr_target_1 );

        exception_lineno = 1734;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );
    Py_DECREF( tmp_assattr_target_1 );
    tmp_subscribed_name_7 = par_p;

    if ( tmp_subscribed_name_7 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1735;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_subscript_name_7 = const_int_pos_1;
    tmp_ass_subvalue_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_7, tmp_subscript_name_7 );
    if ( tmp_ass_subvalue_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1735;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_2 = par_p;

    if ( tmp_ass_subscribed_2 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1735;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_2 = const_int_0;
    tmp_ass_subscript_res_2 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_2, tmp_ass_subscript_2, 0, tmp_ass_subvalue_2 );
    Py_DECREF( tmp_ass_subvalue_2 );
    if ( tmp_ass_subscript_res_2 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1735;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a488ed12a4b6217597f4f94e372f960d );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a488ed12a4b6217597f4f94e372f960d );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a488ed12a4b6217597f4f94e372f960d, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a488ed12a4b6217597f4f94e372f960d->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a488ed12a4b6217597f4f94e372f960d, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_a488ed12a4b6217597f4f94e372f960d, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_a488ed12a4b6217597f4f94e372f960d == cache_frame_a488ed12a4b6217597f4f94e372f960d )
    {
        Py_DECREF( frame_a488ed12a4b6217597f4f94e372f960d );
    }
    cache_frame_a488ed12a4b6217597f4f94e372f960d = NULL;

    assertFrameObject( frame_a488ed12a4b6217597f4f94e372f960d );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_153_p_unified_wstring_literal );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_153_p_unified_wstring_literal );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_154_p_brace_open( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_a413dcd715e0f7313fbd11c8e102c39a = NULL;

    struct Nuitka_FrameObject *frame_a413dcd715e0f7313fbd11c8e102c39a;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_a413dcd715e0f7313fbd11c8e102c39a, codeobj_a413dcd715e0f7313fbd11c8e102c39a, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_a413dcd715e0f7313fbd11c8e102c39a = cache_frame_a413dcd715e0f7313fbd11c8e102c39a;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_a413dcd715e0f7313fbd11c8e102c39a );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_a413dcd715e0f7313fbd11c8e102c39a ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1740;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1740;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1740;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_1 = par_p;

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1741;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_set_lineno );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1741;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = const_int_0;
    tmp_called_instance_1 = par_p;

    if ( tmp_called_instance_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1741;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    frame_a413dcd715e0f7313fbd11c8e102c39a->m_frame.f_lineno = 1741;
    tmp_args_element_name_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_lineno, &PyTuple_GET_ITEM( const_tuple_int_pos_1_tuple, 0 ) );

    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1741;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_a413dcd715e0f7313fbd11c8e102c39a->m_frame.f_lineno = 1741;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1741;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a413dcd715e0f7313fbd11c8e102c39a );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_a413dcd715e0f7313fbd11c8e102c39a );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_a413dcd715e0f7313fbd11c8e102c39a, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_a413dcd715e0f7313fbd11c8e102c39a->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_a413dcd715e0f7313fbd11c8e102c39a, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_a413dcd715e0f7313fbd11c8e102c39a, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_a413dcd715e0f7313fbd11c8e102c39a == cache_frame_a413dcd715e0f7313fbd11c8e102c39a )
    {
        Py_DECREF( frame_a413dcd715e0f7313fbd11c8e102c39a );
    }
    cache_frame_a413dcd715e0f7313fbd11c8e102c39a = NULL;

    assertFrameObject( frame_a413dcd715e0f7313fbd11c8e102c39a );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_154_p_brace_open );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_154_p_brace_open );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_155_p_brace_close( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_26db2c85ab3d6d0266f0a822b40edf53 = NULL;

    struct Nuitka_FrameObject *frame_26db2c85ab3d6d0266f0a822b40edf53;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_26db2c85ab3d6d0266f0a822b40edf53, codeobj_26db2c85ab3d6d0266f0a822b40edf53, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_26db2c85ab3d6d0266f0a822b40edf53 = cache_frame_26db2c85ab3d6d0266f0a822b40edf53;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_26db2c85ab3d6d0266f0a822b40edf53 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_26db2c85ab3d6d0266f0a822b40edf53 ) == 2 ); // Frame stack

    // Framed code:
    tmp_subscribed_name_1 = par_p;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1746;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_ass_subscribed_1 = par_p;

    if ( tmp_ass_subscribed_1 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1746;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1746;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_1 = par_p;

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1747;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_set_lineno );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1747;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = const_int_0;
    tmp_called_instance_1 = par_p;

    if ( tmp_called_instance_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1747;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    frame_26db2c85ab3d6d0266f0a822b40edf53->m_frame.f_lineno = 1747;
    tmp_args_element_name_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_lineno, &PyTuple_GET_ITEM( const_tuple_int_pos_1_tuple, 0 ) );

    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1747;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_26db2c85ab3d6d0266f0a822b40edf53->m_frame.f_lineno = 1747;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1747;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_26db2c85ab3d6d0266f0a822b40edf53 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_26db2c85ab3d6d0266f0a822b40edf53 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_26db2c85ab3d6d0266f0a822b40edf53, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_26db2c85ab3d6d0266f0a822b40edf53->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_26db2c85ab3d6d0266f0a822b40edf53, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_26db2c85ab3d6d0266f0a822b40edf53, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_26db2c85ab3d6d0266f0a822b40edf53 == cache_frame_26db2c85ab3d6d0266f0a822b40edf53 )
    {
        Py_DECREF( frame_26db2c85ab3d6d0266f0a822b40edf53 );
    }
    cache_frame_26db2c85ab3d6d0266f0a822b40edf53 = NULL;

    assertFrameObject( frame_26db2c85ab3d6d0266f0a822b40edf53 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_155_p_brace_close );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_155_p_brace_close );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_156_p_empty( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_57177e1c43acfad59002f4c79c8dd68b = NULL;

    struct Nuitka_FrameObject *frame_57177e1c43acfad59002f4c79c8dd68b;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_57177e1c43acfad59002f4c79c8dd68b, codeobj_57177e1c43acfad59002f4c79c8dd68b, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_57177e1c43acfad59002f4c79c8dd68b = cache_frame_57177e1c43acfad59002f4c79c8dd68b;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_57177e1c43acfad59002f4c79c8dd68b );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_57177e1c43acfad59002f4c79c8dd68b ) == 2 ); // Frame stack

    // Framed code:
    tmp_ass_subvalue_1 = Py_None;
    tmp_ass_subscribed_1 = par_p;

    CHECK_OBJECT( tmp_ass_subscribed_1 );
    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1751;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_57177e1c43acfad59002f4c79c8dd68b );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_57177e1c43acfad59002f4c79c8dd68b );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_57177e1c43acfad59002f4c79c8dd68b, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_57177e1c43acfad59002f4c79c8dd68b->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_57177e1c43acfad59002f4c79c8dd68b, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_57177e1c43acfad59002f4c79c8dd68b, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_57177e1c43acfad59002f4c79c8dd68b == cache_frame_57177e1c43acfad59002f4c79c8dd68b )
    {
        Py_DECREF( frame_57177e1c43acfad59002f4c79c8dd68b );
    }
    cache_frame_57177e1c43acfad59002f4c79c8dd68b = NULL;

    assertFrameObject( frame_57177e1c43acfad59002f4c79c8dd68b );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_156_p_empty );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_156_p_empty );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_pycparser$c_parser$$$class_1_CParser$$$function_157_p_error( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_p = python_pars[ 1 ];
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_left_name_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_b7acc24f1086e7eb9e18ae8b458bb757 = NULL;

    struct Nuitka_FrameObject *frame_b7acc24f1086e7eb9e18ae8b458bb757;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_b7acc24f1086e7eb9e18ae8b458bb757, codeobj_b7acc24f1086e7eb9e18ae8b458bb757, module_pycparser$c_parser, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_b7acc24f1086e7eb9e18ae8b458bb757 = cache_frame_b7acc24f1086e7eb9e18ae8b458bb757;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_b7acc24f1086e7eb9e18ae8b458bb757 );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_b7acc24f1086e7eb9e18ae8b458bb757 ) == 2 ); // Frame stack

    // Framed code:
    tmp_cond_value_1 = par_p;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1757;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__parse_error );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1758;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_1 = const_str_digest_325218adecc4f0228a24278fb5234c18;
    tmp_source_name_2 = par_p;

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1759;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_right_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_value );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1759;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 1759;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_self;

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1760;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain__coord );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1760;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_1 = _PyDict_NewPresized( 2 );
    tmp_dict_key_1 = const_str_plain_lineno;
    tmp_source_name_4 = par_p;

    if ( tmp_source_name_4 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1760;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_dict_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_lineno );
    if ( tmp_dict_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1760;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    Py_DECREF( tmp_dict_value_1 );
    assert( !(tmp_res != 0) );
    tmp_dict_key_2 = const_str_plain_column;
    tmp_source_name_6 = par_self;

    if ( tmp_source_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1761;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_clex );
    if ( tmp_source_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1761;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_find_tok_column );
    Py_DECREF( tmp_source_name_5 );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1761;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = par_p;

    if ( tmp_args_element_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_1 );
        Py_DECREF( tmp_called_name_3 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "p" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1761;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    frame_b7acc24f1086e7eb9e18ae8b458bb757->m_frame.f_lineno = 1761;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_dict_value_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    if ( tmp_dict_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 1761;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_res = PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    Py_DECREF( tmp_dict_value_2 );
    assert( !(tmp_res != 0) );
    frame_b7acc24f1086e7eb9e18ae8b458bb757->m_frame.f_lineno = 1760;
    tmp_args_element_name_2 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_2, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 1760;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_b7acc24f1086e7eb9e18ae8b458bb757->m_frame.f_lineno = 1758;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1758;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_1;
    branch_no_1:;
    tmp_source_name_7 = par_self;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__parse_error );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1763;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = const_str_digest_e7a64a89e5927564e3642a46ab58f1c4;
    tmp_source_name_9 = par_self;

    if ( tmp_source_name_9 == NULL )
    {
        Py_DECREF( tmp_called_name_4 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 1763;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_source_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_clex );
    if ( tmp_source_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 1763;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_filename );
    Py_DECREF( tmp_source_name_8 );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 1763;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_b7acc24f1086e7eb9e18ae8b458bb757->m_frame.f_lineno = 1763;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1763;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b7acc24f1086e7eb9e18ae8b458bb757 );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_b7acc24f1086e7eb9e18ae8b458bb757 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_b7acc24f1086e7eb9e18ae8b458bb757, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_b7acc24f1086e7eb9e18ae8b458bb757->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_b7acc24f1086e7eb9e18ae8b458bb757, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_b7acc24f1086e7eb9e18ae8b458bb757, type_description ,par_self, par_p );

    // Release cached frame.
    if ( frame_b7acc24f1086e7eb9e18ae8b458bb757 == cache_frame_b7acc24f1086e7eb9e18ae8b458bb757 )
    {
        Py_DECREF( frame_b7acc24f1086e7eb9e18ae8b458bb757 );
    }
    cache_frame_b7acc24f1086e7eb9e18ae8b458bb757 = NULL;

    assertFrameObject( frame_b7acc24f1086e7eb9e18ae8b458bb757 );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_157_p_error );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( par_self );
    par_self = NULL;

    Py_XDECREF( par_p );
    par_p = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( pycparser$c_parser$$$class_1_CParser$$$function_157_p_error );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_100_p_direct_abstract_declarator_4(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_100_p_direct_abstract_declarator_4,
        const_str_plain_p_direct_abstract_declarator_4,
#if PYTHON_VERSION >= 330
        const_str_digest_6e95ffeb0e7816beaeca0e8f138f7c30,
#endif
        codeobj_1689f9118a658d2fccef32175084540f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_67ab4d59a0c077231f5627abe5a96096,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_101_p_direct_abstract_declarator_5(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_101_p_direct_abstract_declarator_5,
        const_str_plain_p_direct_abstract_declarator_5,
#if PYTHON_VERSION >= 330
        const_str_digest_edc88e6e620d04e505071707ba4525ca,
#endif
        codeobj_0ed528daae5194b75aa45f30a70a7d2a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_db4fbd32244e3e142dfff8ca5ad2d835,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_102_p_direct_abstract_declarator_6(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_102_p_direct_abstract_declarator_6,
        const_str_plain_p_direct_abstract_declarator_6,
#if PYTHON_VERSION >= 330
        const_str_digest_2cf67ea0a03b2cf611b58d5daaa1326b,
#endif
        codeobj_d0ddb5710ee04c11b9c8b5e7929925bb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_de90f98da1f88f6c37ec30f2101d5029,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_103_p_direct_abstract_declarator_7(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_103_p_direct_abstract_declarator_7,
        const_str_plain_p_direct_abstract_declarator_7,
#if PYTHON_VERSION >= 330
        const_str_digest_820fa7852213334e67e36dc54e523377,
#endif
        codeobj_40828e27474f8175923acb31cbff0852,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_e804d385509db9b1e7283e5542b56ffc,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_104_p_block_item(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_104_p_block_item,
        const_str_plain_p_block_item,
#if PYTHON_VERSION >= 330
        const_str_digest_abf6f1796659b1065c7123daae53e198,
#endif
        codeobj_d418cf27184b2bf16ca054052e01d977,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_e61ddf064a1db398749ac1d36281c3cb,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_105_p_block_item_list(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_105_p_block_item_list,
        const_str_plain_p_block_item_list,
#if PYTHON_VERSION >= 330
        const_str_digest_d5664c5531b4d8c20886d97ceb88d02f,
#endif
        codeobj_f876f59d4cd77fb6f7eab21d385ae078,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_6e4b44069d4b8ebacde4e38969a5851a,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_106_p_compound_statement_1(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_106_p_compound_statement_1,
        const_str_plain_p_compound_statement_1,
#if PYTHON_VERSION >= 330
        const_str_digest_d0dce591a53a04884750228ee0143163,
#endif
        codeobj_a80f7b2846d23973abaf0cf769aa2159,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_6ab508e6c2405e1a94cf3d2c7c0831cb,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_107_p_labeled_statement_1(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_107_p_labeled_statement_1,
        const_str_plain_p_labeled_statement_1,
#if PYTHON_VERSION >= 330
        const_str_digest_2b800f7f12830ca3c74b3d002525a8e9,
#endif
        codeobj_1310901836337014bc882ee72d64976b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_47d71f45ed595c6bc27351f58c7aaad0,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_108_p_labeled_statement_2(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_108_p_labeled_statement_2,
        const_str_plain_p_labeled_statement_2,
#if PYTHON_VERSION >= 330
        const_str_digest_124cdd6e5c1c3bca0c3f9db3c722414e,
#endif
        codeobj_848b6d36ac8046f93895c4f1c5e3f20a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_5a2740760b061d16507e2fe95c154990,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_109_p_labeled_statement_3(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_109_p_labeled_statement_3,
        const_str_plain_p_labeled_statement_3,
#if PYTHON_VERSION >= 330
        const_str_digest_33b3b26831c9fdeed6fb503fb3235253,
#endif
        codeobj_4b2ca4185e772da831d9fd26e5c441de,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_f67d5f062350872f4b7a3431eb8ff9ef,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_10__lex_on_rbrace_func(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_10__lex_on_rbrace_func,
        const_str_plain__lex_on_rbrace_func,
#if PYTHON_VERSION >= 330
        const_str_digest_1a34dbec4760d533fb71694a481d5e82,
#endif
        codeobj_f7642558c29696ca9e24e1bcaca82789,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_110_p_selection_statement_1(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_110_p_selection_statement_1,
        const_str_plain_p_selection_statement_1,
#if PYTHON_VERSION >= 330
        const_str_digest_e362d81bd9b3e85900445f8c349b8841,
#endif
        codeobj_3827ee0116b2c686ac4a629dc5c8d41b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_e664f998ac5740d2a3a6c87d0e4d9671,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_111_p_selection_statement_2(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_111_p_selection_statement_2,
        const_str_plain_p_selection_statement_2,
#if PYTHON_VERSION >= 330
        const_str_digest_c9f59b1fa5017cb9005bb768b7c0c697,
#endif
        codeobj_02c27f43617c9de50be853bd11a02557,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_d66e9c5c2bcd94289ac5f093c4055dbc,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_112_p_selection_statement_3(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_112_p_selection_statement_3,
        const_str_plain_p_selection_statement_3,
#if PYTHON_VERSION >= 330
        const_str_digest_125855f9025066f00bab7e56db3721bd,
#endif
        codeobj_df0dd4c7f3200da012ac0fd7c5300dee,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_d22a9d10bffbeaa38403c3c0bb0d1558,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_113_p_iteration_statement_1(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_113_p_iteration_statement_1,
        const_str_plain_p_iteration_statement_1,
#if PYTHON_VERSION >= 330
        const_str_digest_927a3c4fff6d9ce2ff3e8b0311b2a749,
#endif
        codeobj_802c5dcca4e0dc3da51d1647e1b1c44b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_821acde88c2af9a2f13af52e0c27fed6,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_114_p_iteration_statement_2(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_114_p_iteration_statement_2,
        const_str_plain_p_iteration_statement_2,
#if PYTHON_VERSION >= 330
        const_str_digest_e5e2ab4a197a763e089302e170784084,
#endif
        codeobj_af8b24a7fb187d46cbff465e53ea8988,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_aefe7a31071e8b90b70d14309835c4e8,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_115_p_iteration_statement_3(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_115_p_iteration_statement_3,
        const_str_plain_p_iteration_statement_3,
#if PYTHON_VERSION >= 330
        const_str_digest_67c7a592d5ccaa55aa64fc82209437a9,
#endif
        codeobj_08768331755421b59b3b286c6aa14448,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_f6874ff50ae284a33e88afa362ab3553,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_116_p_iteration_statement_4(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_116_p_iteration_statement_4,
        const_str_plain_p_iteration_statement_4,
#if PYTHON_VERSION >= 330
        const_str_digest_178c771a71db12f844d7380f17f7ef4e,
#endif
        codeobj_568ad40762c86bdbb2f4cf4156d8c64e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_3d708f088baf2d9fe04b4d4c3d1048e2,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_117_p_jump_statement_1(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_117_p_jump_statement_1,
        const_str_plain_p_jump_statement_1,
#if PYTHON_VERSION >= 330
        const_str_digest_7f1585ee0758766cedaf1624cb16edb0,
#endif
        codeobj_d4b13e566c43bcd4afcc2455b31001f3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_3bf5fc201f146f4078233e173b4cb76d,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_118_p_jump_statement_2(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_118_p_jump_statement_2,
        const_str_plain_p_jump_statement_2,
#if PYTHON_VERSION >= 330
        const_str_digest_80150a5bbe00013c9a11609bcac2921e,
#endif
        codeobj_aa10437b2c7b7415d366a3591971e55e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_cf56e81ade3b51653cf6277798267531,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_119_p_jump_statement_3(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_119_p_jump_statement_3,
        const_str_plain_p_jump_statement_3,
#if PYTHON_VERSION >= 330
        const_str_digest_63caba6a8655f13f8d6329090735eda2,
#endif
        codeobj_9a7884aa4204ef4dbd3aad792656ee71,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_5528a54872ed3f6e644fc93ddc6e4329,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_11__lex_type_lookup_func(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_11__lex_type_lookup_func,
        const_str_plain__lex_type_lookup_func,
#if PYTHON_VERSION >= 330
        const_str_digest_edd8de4708a55f1ec9dbcdda4529a4c2,
#endif
        codeobj_3c130929c04ff996d230a179e832aca1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_5818384d85f9531b5d1a4dc60515c5ef,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_120_p_jump_statement_4(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_120_p_jump_statement_4,
        const_str_plain_p_jump_statement_4,
#if PYTHON_VERSION >= 330
        const_str_digest_55a08934bb62f870d418c2065396356a,
#endif
        codeobj_42a6c9510c0bdcc207922abe14498274,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_5494df6239ebd6d1e5bb525f10a0f6cd,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_121_p_expression_statement(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_121_p_expression_statement,
        const_str_plain_p_expression_statement,
#if PYTHON_VERSION >= 330
        const_str_digest_f31c05fd6230f58c972a6b1f6469cc4a,
#endif
        codeobj_effdb1dfb0ba4b664777a5d6f9df0b8d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_b2165be07d44c0536d62b0ea0314fef6,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_122_p_expression(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_122_p_expression,
        const_str_plain_p_expression,
#if PYTHON_VERSION >= 330
        const_str_digest_e658ac8c4b7c2299a86f760a10b99615,
#endif
        codeobj_890693400d4202a153b8e1e690365ade,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_c88ddef41084d2b01880f788a8e1915e,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_123_p_typedef_name(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_123_p_typedef_name,
        const_str_plain_p_typedef_name,
#if PYTHON_VERSION >= 330
        const_str_digest_3502e26f1e7e9795bcde23e020a1c6c2,
#endif
        codeobj_1f4b7bc9508ec89587d97c1950610acf,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_d26c56e6f12d65901f9ea8a848bbf06f,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_124_p_assignment_expression(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_124_p_assignment_expression,
        const_str_plain_p_assignment_expression,
#if PYTHON_VERSION >= 330
        const_str_digest_8d8f57fbf9ace4a819eb9da34e88ef83,
#endif
        codeobj_19efd769ae32e39375b5f91ec8fbb547,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_b3256d0808a5cfa78a9b07f0014ae192,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_125_p_assignment_operator(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_125_p_assignment_operator,
        const_str_plain_p_assignment_operator,
#if PYTHON_VERSION >= 330
        const_str_digest_8a34c5f5b79e2060c67f54d2ea359c5c,
#endif
        codeobj_a7092856904714539f2d6ca7e3306ef6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_d3241665db4061517845a1ec21ea60f2,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_126_p_constant_expression(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_126_p_constant_expression,
        const_str_plain_p_constant_expression,
#if PYTHON_VERSION >= 330
        const_str_digest_dae376c9624166cef9d09e7b5e652d77,
#endif
        codeobj_d1032335e18e686c5a3e07c2a5efdd4f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_317c273604af4de5e262e646925688c4,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_127_p_conditional_expression(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_127_p_conditional_expression,
        const_str_plain_p_conditional_expression,
#if PYTHON_VERSION >= 330
        const_str_digest_52db91b7c1f71ae57834d48da56bbc3e,
#endif
        codeobj_db82277e54d8ea03459ccc4903704992,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_51cb11be562c4e62872e5a99fb92c982,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_128_p_binary_expression(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_128_p_binary_expression,
        const_str_plain_p_binary_expression,
#if PYTHON_VERSION >= 330
        const_str_digest_4f9513954810f933174045a85cc3a2ab,
#endif
        codeobj_3beaa24096ba678266b7ce5a127daf1e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_a5744676b3080c705bd7d08f2eeaded7,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_129_p_cast_expression_1(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_129_p_cast_expression_1,
        const_str_plain_p_cast_expression_1,
#if PYTHON_VERSION >= 330
        const_str_digest_7cdb66da260f8b202170173dc4a6470f,
#endif
        codeobj_6c76c6b906bebc731427f45496dd9bfe,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_84f8f95f98f69c9f598b1943ad4af5e9,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_12__get_yacc_lookahead_token(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_12__get_yacc_lookahead_token,
        const_str_plain__get_yacc_lookahead_token,
#if PYTHON_VERSION >= 330
        const_str_digest_4747c94525afd53dfec17ba56a3a01da,
#endif
        codeobj_b46c585229a82084cf4cd60f525bdce1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_abe9cf4d34820d00ecbbe01507e8a236,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_130_p_cast_expression_2(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_130_p_cast_expression_2,
        const_str_plain_p_cast_expression_2,
#if PYTHON_VERSION >= 330
        const_str_digest_04111da496bbf8fa420ef5af2e2ec8c2,
#endif
        codeobj_44fecbd2cd73bf009220006e0cf1357f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_6795256e62ee72e47844fa0e0f009b9a,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_131_p_unary_expression_1(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_131_p_unary_expression_1,
        const_str_plain_p_unary_expression_1,
#if PYTHON_VERSION >= 330
        const_str_digest_f25f218a0c1f5cad198347bc47b76ed9,
#endif
        codeobj_2805b5236c257d9892595ef331fe32b7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_05d595f63bad393233213e890f949113,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_132_p_unary_expression_2(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_132_p_unary_expression_2,
        const_str_plain_p_unary_expression_2,
#if PYTHON_VERSION >= 330
        const_str_digest_59cff374166603b529f71057ce36eaed,
#endif
        codeobj_5cc8d94a5e1fe1d058d2dc0e268f0c82,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_d629f9f772cbeff45a83968be4ddd03c,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_133_p_unary_expression_3(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_133_p_unary_expression_3,
        const_str_plain_p_unary_expression_3,
#if PYTHON_VERSION >= 330
        const_str_digest_550126ff38d208154c0902478dbba1ce,
#endif
        codeobj_8b7d7117faec7d0aef260da43d40c207,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_218c48307caf6bfda88fe53635606a43,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_134_p_unary_operator(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_134_p_unary_operator,
        const_str_plain_p_unary_operator,
#if PYTHON_VERSION >= 330
        const_str_digest_9ea1b38e0d2aa74c23f145dd3e278bab,
#endif
        codeobj_b4c79c4a2dd3535b415a0995f8471cae,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_926cbb8fdd1f46d7626b4cc0e214cfd0,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_135_p_postfix_expression_1(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_135_p_postfix_expression_1,
        const_str_plain_p_postfix_expression_1,
#if PYTHON_VERSION >= 330
        const_str_digest_4adaae36d1bcfc08aaddc6ab3ca280a1,
#endif
        codeobj_1fb46e7eab0421a5014bc4bf4a5b4563,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_e6054102b697f4379243ef2e481d9de1,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_136_p_postfix_expression_2(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_136_p_postfix_expression_2,
        const_str_plain_p_postfix_expression_2,
#if PYTHON_VERSION >= 330
        const_str_digest_05db319dd614b03c1a9c5cbdcfc77915,
#endif
        codeobj_9d63efb08280aa9f3e1ade085e5671ce,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_1af3c0955bc51582727db494d6e3b036,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_137_p_postfix_expression_3(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_137_p_postfix_expression_3,
        const_str_plain_p_postfix_expression_3,
#if PYTHON_VERSION >= 330
        const_str_digest_df4123329a07844b816ca766a10e3b4d,
#endif
        codeobj_12651dd7f01f4a368063187baf6a9878,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_641c74115009f84216dbefa5d7bd4004,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_138_p_postfix_expression_4(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_138_p_postfix_expression_4,
        const_str_plain_p_postfix_expression_4,
#if PYTHON_VERSION >= 330
        const_str_digest_49258e4a03bd2250dfb8cbfdcea029e5,
#endif
        codeobj_21b21c0e9aa6489741377e3025474a8d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_52b362b68c1a3994b3c354ae840e20f1,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_139_p_postfix_expression_5(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_139_p_postfix_expression_5,
        const_str_plain_p_postfix_expression_5,
#if PYTHON_VERSION >= 330
        const_str_digest_e60fde1ce3556920242aca8b3c191efe,
#endif
        codeobj_2f22fe77305a28e8416b02900417c1b5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_12f9e6fe12f7541fa2b46186a390fa7e,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_13__type_modify_decl(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_13__type_modify_decl,
        const_str_plain__type_modify_decl,
#if PYTHON_VERSION >= 330
        const_str_digest_8d22bfcb2b0b548ef9d27d2e0cd24f7d,
#endif
        codeobj_e70c38497d0ec9a52c2ff1f534573b49,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_673754ad82ad40b5e8cfbef5f26fa28b,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_140_p_postfix_expression_6(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_140_p_postfix_expression_6,
        const_str_plain_p_postfix_expression_6,
#if PYTHON_VERSION >= 330
        const_str_digest_5e2d8ee1259d7fabe59ee8fbc3b91004,
#endif
        codeobj_2ffe8752d69b5192793518d9b2bd5183,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_ea48cf7104d76d4530fca21257b2ac6b,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_141_p_primary_expression_1(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_141_p_primary_expression_1,
        const_str_plain_p_primary_expression_1,
#if PYTHON_VERSION >= 330
        const_str_digest_a8184ddf33f783ca2f5ff9b3b636381f,
#endif
        codeobj_7aacc024cef287d47094c2e9272ac6a3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_d642d0fe838aefefa0b9280cc6a39a38,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_142_p_primary_expression_2(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_142_p_primary_expression_2,
        const_str_plain_p_primary_expression_2,
#if PYTHON_VERSION >= 330
        const_str_digest_f7773303a76f0396c72f44ccc6cdac61,
#endif
        codeobj_25ef2753338c990d7a75642de258fee4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_df2387d02cc8652fc0588206818d2a5b,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_143_p_primary_expression_3(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_143_p_primary_expression_3,
        const_str_plain_p_primary_expression_3,
#if PYTHON_VERSION >= 330
        const_str_digest_c187e02bef7c074dcfaa98ea325683fc,
#endif
        codeobj_79eb7006626f9d871293d99e614159a9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_aeedbaa90a2ea63d79afdc2349fb7597,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_144_p_primary_expression_4(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_144_p_primary_expression_4,
        const_str_plain_p_primary_expression_4,
#if PYTHON_VERSION >= 330
        const_str_digest_51f8cd619ea97f30dc6589cdec4889ff,
#endif
        codeobj_6fe279688e2cd7bc46d2d64929e946b5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_8c97fa18e75807bc919d97720956d8b5,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_145_p_primary_expression_5(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_145_p_primary_expression_5,
        const_str_plain_p_primary_expression_5,
#if PYTHON_VERSION >= 330
        const_str_digest_10f37e3bff7e991e751e7269ffabadb0,
#endif
        codeobj_3ebb659f536809e4475d45060ad98408,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_73b402b81d578988831576aa55cece06,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_146_p_offsetof_member_designator(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_146_p_offsetof_member_designator,
        const_str_plain_p_offsetof_member_designator,
#if PYTHON_VERSION >= 330
        const_str_digest_2ee573711e350e5fa9f7994e07f7d359,
#endif
        codeobj_16109f170a5b0bf37839ac5e2c0e961f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_e1c12c8d1dab799b69e07b9066071ae2,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_147_p_argument_expression_list(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_147_p_argument_expression_list,
        const_str_plain_p_argument_expression_list,
#if PYTHON_VERSION >= 330
        const_str_digest_6bc7376195f70b4ee319b4b195df915c,
#endif
        codeobj_ed8adc41ee899609c66034535486075c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_f8f063e2d73853aff8adc792b438908e,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_148_p_identifier(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_148_p_identifier,
        const_str_plain_p_identifier,
#if PYTHON_VERSION >= 330
        const_str_digest_e13114f89598d7e65c91b632f0cadbb8,
#endif
        codeobj_5ef1b3a186f7c83e4c84a68674855a62,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_a095f2bdede86bb9b3571d87f15a4f3c,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_149_p_constant_1(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_149_p_constant_1,
        const_str_plain_p_constant_1,
#if PYTHON_VERSION >= 330
        const_str_digest_d64b22c7e8bcf5726624a0a905a39454,
#endif
        codeobj_dac04a09bf559be9390265aa086c5b1b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_57444e9b5b325fc1be7aff5d9f3b4c3e,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_14__fix_decl_name_type(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_14__fix_decl_name_type,
        const_str_plain__fix_decl_name_type,
#if PYTHON_VERSION >= 330
        const_str_digest_d16adbea55fe0967a56b6e6ba6b8aa8a,
#endif
        codeobj_7d6be3b889381e9206fe16ac40003ac8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_5ffee6bd7e73a82aa69f100a7aa6d022,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_150_p_constant_2(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_150_p_constant_2,
        const_str_plain_p_constant_2,
#if PYTHON_VERSION >= 330
        const_str_digest_436d5669d5bef2966850e86231313d36,
#endif
        codeobj_4280c780fe5eca45d1548e381c321c2e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_86e7bc379ddaa437cb4d0740b0f09628,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_151_p_constant_3(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_151_p_constant_3,
        const_str_plain_p_constant_3,
#if PYTHON_VERSION >= 330
        const_str_digest_d86600b943a4c7555073e3e4856d1089,
#endif
        codeobj_22889f6f9c19d187b7c4c8d88b7e4fa6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_9b2521a2a4f11b3568e8ad30e3a505ca,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_152_p_unified_string_literal(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_152_p_unified_string_literal,
        const_str_plain_p_unified_string_literal,
#if PYTHON_VERSION >= 330
        const_str_digest_79346a7e0deb4b73cbe7b4194fb4e2e9,
#endif
        codeobj_58509cdc3d7993928017f618fed741c3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_643d36ef80210022e8e8988135837871,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_153_p_unified_wstring_literal(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_153_p_unified_wstring_literal,
        const_str_plain_p_unified_wstring_literal,
#if PYTHON_VERSION >= 330
        const_str_digest_1e69359fa796c1d395f6ed6e958b1038,
#endif
        codeobj_a488ed12a4b6217597f4f94e372f960d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_8843e107d9ff99510b99f46b7f76e849,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_154_p_brace_open(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_154_p_brace_open,
        const_str_plain_p_brace_open,
#if PYTHON_VERSION >= 330
        const_str_digest_b42a0c796084440910713d8694dbdc5e,
#endif
        codeobj_a413dcd715e0f7313fbd11c8e102c39a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_4bd430b578c2bcc6d80843b185fb40e9,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_155_p_brace_close(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_155_p_brace_close,
        const_str_plain_p_brace_close,
#if PYTHON_VERSION >= 330
        const_str_digest_872052bc891e4d940163d196751ac419,
#endif
        codeobj_26db2c85ab3d6d0266f0a822b40edf53,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_c244982f392d01a9847bfb619bd7437c,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_156_p_empty(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_156_p_empty,
        const_str_plain_p_empty,
#if PYTHON_VERSION >= 330
        const_str_digest_68c0be9602cedbb187213fbf197fea5b,
#endif
        codeobj_57177e1c43acfad59002f4c79c8dd68b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_2f6102c4e0aa673d1243e931a1fc5195,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_157_p_error(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_157_p_error,
        const_str_plain_p_error,
#if PYTHON_VERSION >= 330
        const_str_digest_f6e25df3d800bc64ee76c249251a121b,
#endif
        codeobj_b7acc24f1086e7eb9e18ae8b458bb757,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_15__add_declaration_specifier( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_15__add_declaration_specifier,
        const_str_plain__add_declaration_specifier,
#if PYTHON_VERSION >= 330
        const_str_digest_6f2181aeaf73e778ef8fef0fecb260be,
#endif
        codeobj_fd2885a07b4bce7ac41dae2e3701ce8e,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_245e706123acd66a0d916383148f8b39,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_16__build_declarations( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_16__build_declarations,
        const_str_plain__build_declarations,
#if PYTHON_VERSION >= 330
        const_str_digest_55677b557b6476d90f099cb7f3f3bf9c,
#endif
        codeobj_bef5532727a45f5b235d041b44d2998c,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_32f37d7b1e094bf932b7a1d06bfa5763,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_17__build_function_definition(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_17__build_function_definition,
        const_str_plain__build_function_definition,
#if PYTHON_VERSION >= 330
        const_str_digest_ec3069c11ff9407ed42cf10e18b85079,
#endif
        codeobj_47d1681d5614a83e5df14808f4fa8d7b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_72424e08fc91bf13cdbee5746dacdd3f,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_18__select_struct_union_class(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_18__select_struct_union_class,
        const_str_plain__select_struct_union_class,
#if PYTHON_VERSION >= 330
        const_str_digest_67f6f0661dcf43443ba5aba2601841f6,
#endif
        codeobj_09001c135c5d1963f9dd6f01da960cd0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_d88c34830a8f899e0db8bc3194789629,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_19_p_translation_unit_or_empty(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_19_p_translation_unit_or_empty,
        const_str_plain_p_translation_unit_or_empty,
#if PYTHON_VERSION >= 330
        const_str_digest_1c433317a7150a35692bd30cb2425716,
#endif
        codeobj_25d6673a41ce2601022f3bec8cf9b9f2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_4b825c9f3babefb0715ce67102552636,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_1___init__( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_1___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        const_str_digest_d5fcd1840d9fbc06c9c5a3527fc1847d,
#endif
        codeobj_c59e20d15f8eac5266dae2329206bd8e,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_7fb11837565d2e38ffa2544b3c72440e,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_20_p_translation_unit_1(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_20_p_translation_unit_1,
        const_str_plain_p_translation_unit_1,
#if PYTHON_VERSION >= 330
        const_str_digest_01f6ae58b95068740a6086923c913284,
#endif
        codeobj_a186227811a44983d6a7e67189d06650,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_a20a4a402871289db2df557bee02c305,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_21_p_translation_unit_2(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_21_p_translation_unit_2,
        const_str_plain_p_translation_unit_2,
#if PYTHON_VERSION >= 330
        const_str_digest_1ba6cb72fde357e6df707af7c40bc09e,
#endif
        codeobj_aee718468f446ee6274702a5598cc964,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_1b8d0d478bf813fa092f6bca5ef1c206,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_22_p_external_declaration_1(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_22_p_external_declaration_1,
        const_str_plain_p_external_declaration_1,
#if PYTHON_VERSION >= 330
        const_str_digest_e83b94dd40a22f9b101921f16536afd9,
#endif
        codeobj_24adae7ae88f8e4355b4ba1428992bc6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_6f813f05266ed46ec5181eab859080ad,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_23_p_external_declaration_2(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_23_p_external_declaration_2,
        const_str_plain_p_external_declaration_2,
#if PYTHON_VERSION >= 330
        const_str_digest_c2c7438f6f3ab6e2ae34cf42aec88484,
#endif
        codeobj_6879c1e9865b0e5e45bb62efdd824393,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_17335b6423c53852abc4fa386f487ebf,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_24_p_external_declaration_3(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_24_p_external_declaration_3,
        const_str_plain_p_external_declaration_3,
#if PYTHON_VERSION >= 330
        const_str_digest_711802f92e6a2899ad0c3a102d2f0802,
#endif
        codeobj_208c1d0a5c48fb2f1b2e5a0a8e19fff7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_5f379363cdeef01b09cf7f64504042da,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_25_p_external_declaration_4(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_25_p_external_declaration_4,
        const_str_plain_p_external_declaration_4,
#if PYTHON_VERSION >= 330
        const_str_digest_ea1e7517ff14f16261f797c375173978,
#endif
        codeobj_229da5f0e9fa3c82a38b125a410979e1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_420d2d0b3c68fd79b820d0f6672b0a25,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_26_p_pp_directive(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_26_p_pp_directive,
        const_str_plain_p_pp_directive,
#if PYTHON_VERSION >= 330
        const_str_digest_eb511689ea0dfd7ea92bdc676c27cead,
#endif
        codeobj_e6bd3ffd6382f6051682737b197f564d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_04b031e3a95a05949b8673c1377c8678,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_27_p_pppragma_directive(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_27_p_pppragma_directive,
        const_str_plain_p_pppragma_directive,
#if PYTHON_VERSION >= 330
        const_str_digest_d981b77bcfe72f3dc742174b23807c08,
#endif
        codeobj_593cfeb60507e7593ca2134a702e323c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_dd3def542e52a4ea9e23e75851f4878e,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_28_p_function_definition_1(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_28_p_function_definition_1,
        const_str_plain_p_function_definition_1,
#if PYTHON_VERSION >= 330
        const_str_digest_9003243efa0c0ecc239aa9a62dcb65fd,
#endif
        codeobj_a679bfacf9dd7eea1a788fa45bb0ce95,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_d1cc4f42cc56377b00d07035e4578575,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_29_p_function_definition_2(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_29_p_function_definition_2,
        const_str_plain_p_function_definition_2,
#if PYTHON_VERSION >= 330
        const_str_digest_26372fde2775fe57a8247ee618f79642,
#endif
        codeobj_48b53f7793e20849ff5aff6a6726fe71,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_90baefe9843fd00d2fcc6c4fd66a583a,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_2_parse( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_2_parse,
        const_str_plain_parse,
#if PYTHON_VERSION >= 330
        const_str_digest_23aa0dacc3c1436a615874779d7ba221,
#endif
        codeobj_6a3ff42cc3d74ce0db1744142bbec85f,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_3cd56dd644178e94ac8c95975280e123,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_30_p_statement(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_30_p_statement,
        const_str_plain_p_statement,
#if PYTHON_VERSION >= 330
        const_str_digest_ee647972fdff9211886cabce258b38a4,
#endif
        codeobj_7eb54679c49b7375444fb88c8b84b1c2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_07bf1055960239c6afdf14732b3e2626,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_31_p_decl_body(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_31_p_decl_body,
        const_str_plain_p_decl_body,
#if PYTHON_VERSION >= 330
        const_str_digest_0ba0c181eb95710a8b10bf6f48d47eb7,
#endif
        codeobj_9ebb7e26c81a6e62f517f5a1634c7145,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_3aa1bda91d8a187cb1cfaa05f37e2a9a,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_32_p_declaration(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_32_p_declaration,
        const_str_plain_p_declaration,
#if PYTHON_VERSION >= 330
        const_str_digest_77451082531ef90d5a12539bac91b84d,
#endif
        codeobj_daf91fd058413412def7e9cba646ba87,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_98a5d60d6dc1672f0b5dd8b8c452133c,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_33_p_declaration_list(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_33_p_declaration_list,
        const_str_plain_p_declaration_list,
#if PYTHON_VERSION >= 330
        const_str_digest_307040cd1aee1d586a3e132983f8218a,
#endif
        codeobj_a550651500717a2145499cdc22099572,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_97d8cb402d283686d305a0534205cf16,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_34_p_declaration_specifiers_no_type_1(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_34_p_declaration_specifiers_no_type_1,
        const_str_plain_p_declaration_specifiers_no_type_1,
#if PYTHON_VERSION >= 330
        const_str_digest_034d2d261123545addc18f62de03953f,
#endif
        codeobj_36fc1a9c2412033462d3fd044b8c43d8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_67949f32b9c50c7570da61d6f3116a3c,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_35_p_declaration_specifiers_no_type_2(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_35_p_declaration_specifiers_no_type_2,
        const_str_plain_p_declaration_specifiers_no_type_2,
#if PYTHON_VERSION >= 330
        const_str_digest_0c8f1309a535f9f28741353a49e7264a,
#endif
        codeobj_a2b727d56381a053396d12a662497a0c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_e28583a0c8281162e1d6bb9bcf52a53f,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_36_p_declaration_specifiers_no_type_3(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_36_p_declaration_specifiers_no_type_3,
        const_str_plain_p_declaration_specifiers_no_type_3,
#if PYTHON_VERSION >= 330
        const_str_digest_030e172aedb3e27ebaa801170da02568,
#endif
        codeobj_3ec228d3af3ab7e0d8598e8ae146fa09,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_aee4be64fec3aac8f4cc13847cf5d34c,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_37_p_declaration_specifiers_1(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_37_p_declaration_specifiers_1,
        const_str_plain_p_declaration_specifiers_1,
#if PYTHON_VERSION >= 330
        const_str_digest_f5a05b9f3549c638d7908479c708f6c5,
#endif
        codeobj_dc55435f67e174458f33671217fef464,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_d6ee975e0df9eca8d5440193b813bd7d,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_38_p_declaration_specifiers_2(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_38_p_declaration_specifiers_2,
        const_str_plain_p_declaration_specifiers_2,
#if PYTHON_VERSION >= 330
        const_str_digest_0873233ec7645beb5174dc9e5b721ed2,
#endif
        codeobj_955db861391b760644188637061a0be7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_1d80facf566b625aa32b1f97e9f80fdc,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_39_p_declaration_specifiers_3(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_39_p_declaration_specifiers_3,
        const_str_plain_p_declaration_specifiers_3,
#if PYTHON_VERSION >= 330
        const_str_digest_d19791b80d76ff0c0c5ce1c5dc8220b7,
#endif
        codeobj_ba284b447b2324f31e4033bc80c04da8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_1beda91f8819e027ad8a23c29f618425,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_3__push_scope(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_3__push_scope,
        const_str_plain__push_scope,
#if PYTHON_VERSION >= 330
        const_str_digest_4283807529d6bc7d66fde2041c90b214,
#endif
        codeobj_9369739e178dac98413046a0f356581a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_40_p_declaration_specifiers_4(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_40_p_declaration_specifiers_4,
        const_str_plain_p_declaration_specifiers_4,
#if PYTHON_VERSION >= 330
        const_str_digest_f5534e5846f0091e2dec27d444fffb08,
#endif
        codeobj_1148723a196d3f7376492b433bec02f1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_3a2b2d446e67b8b60dcfe60187bbb94a,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_41_p_declaration_specifiers_5(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_41_p_declaration_specifiers_5,
        const_str_plain_p_declaration_specifiers_5,
#if PYTHON_VERSION >= 330
        const_str_digest_cef2fc285c8d4fd024540eafb50e5036,
#endif
        codeobj_ad0cabf99ebe872bef794caff00c20ff,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_df25ccf54e7b8d881231a8646232b4c5,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_42_p_declaration_specifiers_6(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_42_p_declaration_specifiers_6,
        const_str_plain_p_declaration_specifiers_6,
#if PYTHON_VERSION >= 330
        const_str_digest_9ca4962d95812b4146545cad53121567,
#endif
        codeobj_81f6b03a9095979e8e4c2741dd044885,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_eeeb606ddede2757ab34e6f6c30e8cfc,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_43_p_storage_class_specifier(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_43_p_storage_class_specifier,
        const_str_plain_p_storage_class_specifier,
#if PYTHON_VERSION >= 330
        const_str_digest_c42ba573360bdf98cc14a40131013fc8,
#endif
        codeobj_80b01d1e78e2951d30442bff34e5a4cb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_67292cb13e9197e2fb2c1781dd68cf71,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_44_p_function_specifier(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_44_p_function_specifier,
        const_str_plain_p_function_specifier,
#if PYTHON_VERSION >= 330
        const_str_digest_76ad672554caf5e4ae0ce3d708784295,
#endif
        codeobj_5cfdbbfac2e5693583b5c3bce0a5b55f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_6540d053a4745d3499d98b3c1b137fdc,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_45_p_type_specifier_no_typeid(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_45_p_type_specifier_no_typeid,
        const_str_plain_p_type_specifier_no_typeid,
#if PYTHON_VERSION >= 330
        const_str_digest_e01ad3fcfb8f2ceeb611d950f8bc575c,
#endif
        codeobj_463376239af8505f839bcaa0249bfc10,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_5ee1bd137846e03700116c37b66c1e9a,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_46_p_type_specifier(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_46_p_type_specifier,
        const_str_plain_p_type_specifier,
#if PYTHON_VERSION >= 330
        const_str_digest_388dfcadefec749acf799f03439e30db,
#endif
        codeobj_f569cd0da9b9127eb406763c7c607567,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_aa59018a8d0d3fcfa3ad474999db574d,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_47_p_type_qualifier(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_47_p_type_qualifier,
        const_str_plain_p_type_qualifier,
#if PYTHON_VERSION >= 330
        const_str_digest_a3ba25157bfdb97c14e3f422913e6e9a,
#endif
        codeobj_39de1eccef65c50e3c79de1d987275c6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_647a6e3276e06f7939544595fc801eba,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_48_p_init_declarator_list(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_48_p_init_declarator_list,
        const_str_plain_p_init_declarator_list,
#if PYTHON_VERSION >= 330
        const_str_digest_e8f9383a162dfbf1f03d39b53d3b5fc9,
#endif
        codeobj_c4664c50857c8a99411c8f15a81eca07,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_e50bcc58dedc95a40e88a177d13094dc,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_49_p_init_declarator(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_49_p_init_declarator,
        const_str_plain_p_init_declarator,
#if PYTHON_VERSION >= 330
        const_str_digest_ca8a32ff5c72a1ecfed53d1c8b17063d,
#endif
        codeobj_97a3152e541b6ec6c995297d53d9b782,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_c07bd5cfbc553d3631d0a1668f710914,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_4__pop_scope(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_4__pop_scope,
        const_str_plain__pop_scope,
#if PYTHON_VERSION >= 330
        const_str_digest_b4df5602eb44336fd139f1d9d4f707a8,
#endif
        codeobj_6e8be8813e958c494a98780a36bdc1e2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_50_p_id_init_declarator_list(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_50_p_id_init_declarator_list,
        const_str_plain_p_id_init_declarator_list,
#if PYTHON_VERSION >= 330
        const_str_digest_f652614c068fd18ab6b54821e3f5e567,
#endif
        codeobj_46874747c73603425f19b82b48f68a48,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_59e6ee836c87207f91389c76e8f37211,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_51_p_id_init_declarator(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_51_p_id_init_declarator,
        const_str_plain_p_id_init_declarator,
#if PYTHON_VERSION >= 330
        const_str_digest_1fca5d0e9bc76c0e07b262792fd8e99e,
#endif
        codeobj_aa0f5872a2f8e0828a2d10c20a4ef844,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_3d1c1b5a40bad5ea2b53479303af8ac3,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_52_p_specifier_qualifier_list_1(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_52_p_specifier_qualifier_list_1,
        const_str_plain_p_specifier_qualifier_list_1,
#if PYTHON_VERSION >= 330
        const_str_digest_9cdeb6682169eabb916c7a726bd5a898,
#endif
        codeobj_418db9cacfcd09e3118e18f6d0a2849f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_fdd5d372186562e91a02b35106e75db3,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_53_p_specifier_qualifier_list_2(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_53_p_specifier_qualifier_list_2,
        const_str_plain_p_specifier_qualifier_list_2,
#if PYTHON_VERSION >= 330
        const_str_digest_aa4b6ff9cb7b7e2de6145f81e4b024a4,
#endif
        codeobj_6ecdf682fba70e48f758afad9ba925c9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_8ad640be40d1e51038889c0ad468a995,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_54_p_specifier_qualifier_list_3(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_54_p_specifier_qualifier_list_3,
        const_str_plain_p_specifier_qualifier_list_3,
#if PYTHON_VERSION >= 330
        const_str_digest_41f6ebfa89aad8d3dfc1d7132e5ff63a,
#endif
        codeobj_1da590064ef77831c71eb320c8e29b4f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_e24f977f6803d5f0c297c89e5fb42201,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_55_p_specifier_qualifier_list_4(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_55_p_specifier_qualifier_list_4,
        const_str_plain_p_specifier_qualifier_list_4,
#if PYTHON_VERSION >= 330
        const_str_digest_74fea7cff33b7bf42ce4fcb20f366d7e,
#endif
        codeobj_3c330c3797f362655fc43b272c3eb042,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_5d8b7746d279b77778a2347a35fac441,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_56_p_struct_or_union_specifier_1(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_56_p_struct_or_union_specifier_1,
        const_str_plain_p_struct_or_union_specifier_1,
#if PYTHON_VERSION >= 330
        const_str_digest_47c288e3e3c1ec5382a287f33b329e55,
#endif
        codeobj_0ea1d0686563ee73ce9af74116275c5f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_680cc8fadbfc312c9e9abfca1ee7a562,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_57_p_struct_or_union_specifier_2(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_57_p_struct_or_union_specifier_2,
        const_str_plain_p_struct_or_union_specifier_2,
#if PYTHON_VERSION >= 330
        const_str_digest_568b35cedd50be265c02bbdb7a7eb88d,
#endif
        codeobj_129c1473716b75fca59a3bb1a8c29dc1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_8ecbd0539063d98b175e5d1b148373e4,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_58_p_struct_or_union_specifier_3(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_58_p_struct_or_union_specifier_3,
        const_str_plain_p_struct_or_union_specifier_3,
#if PYTHON_VERSION >= 330
        const_str_digest_6c52cb702432c3d80308420329a005f0,
#endif
        codeobj_0fd5d9823eacda464fa5a1ee5cd90b6e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_58be8217c52b2b0082fd54c328e34edd,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_59_p_struct_or_union(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_59_p_struct_or_union,
        const_str_plain_p_struct_or_union,
#if PYTHON_VERSION >= 330
        const_str_digest_467f5498c75043f32be58f16f19f8328,
#endif
        codeobj_eaf2fded8c31a9dea63e42cdeb65689e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_9bb26e7c3ad302320772fd07b96a4189,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_5__add_typedef_name(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_5__add_typedef_name,
        const_str_plain__add_typedef_name,
#if PYTHON_VERSION >= 330
        const_str_digest_2aaa91cf4331f7a6a55f392233d13676,
#endif
        codeobj_5d301616ab586222ed78633c90ffcd8d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_c921c8f322b3fd46a59553d2e5dfc401,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_60_p_struct_declaration_list(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_60_p_struct_declaration_list,
        const_str_plain_p_struct_declaration_list,
#if PYTHON_VERSION >= 330
        const_str_digest_df1d3e1503202a90612746b6071f8fc8,
#endif
        codeobj_d92a866aca5ee4bf46d4ac9e314cf35b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_0ebf677191c7d5c09c299499be874cec,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_61_p_struct_declaration_1(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_61_p_struct_declaration_1,
        const_str_plain_p_struct_declaration_1,
#if PYTHON_VERSION >= 330
        const_str_digest_2060f4e391866f3f24cf672a745dbddb,
#endif
        codeobj_7f70ce3e02d3f2f4e1e4321d7d064669,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_eb88e54a205432a72790f32cf3ad216c,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_62_p_struct_declaration_2(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_62_p_struct_declaration_2,
        const_str_plain_p_struct_declaration_2,
#if PYTHON_VERSION >= 330
        const_str_digest_f902c40d06583479323f2a0e09f149d0,
#endif
        codeobj_753414c1c431ae4c5db9c6601df038b5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_613ba6a44a1d56c696caece48ebdb21e,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_63_p_struct_declarator_list(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_63_p_struct_declarator_list,
        const_str_plain_p_struct_declarator_list,
#if PYTHON_VERSION >= 330
        const_str_digest_18559e92d38108a30eaa5a5cecac76ce,
#endif
        codeobj_b0f344fd6a0c4d2abd6db14c8fef82ab,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_a61395ec1f8cbf83baab4a2c6ec5e642,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_64_p_struct_declarator_1(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_64_p_struct_declarator_1,
        const_str_plain_p_struct_declarator_1,
#if PYTHON_VERSION >= 330
        const_str_digest_432c60fb536d6a5750f1ead762b4062e,
#endif
        codeobj_f6eb8c7ab6d5260fc9fa696b3c5597c9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_571f26da7d7ba7969e33ae47d529100a,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_65_p_struct_declarator_2(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_65_p_struct_declarator_2,
        const_str_plain_p_struct_declarator_2,
#if PYTHON_VERSION >= 330
        const_str_digest_229a95fb3332065f431f76ad875a569b,
#endif
        codeobj_3ce513362ae9f8a7a7ed0c2ec7b2acad,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_547b0820a3a668896a8f847d79c3b158,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_66_p_enum_specifier_1(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_66_p_enum_specifier_1,
        const_str_plain_p_enum_specifier_1,
#if PYTHON_VERSION >= 330
        const_str_digest_b754de9b97f0b72d6dd37dec82ba5746,
#endif
        codeobj_56043ddf00ef986baf64b5ab4532f55e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_483f66f5df35d692c60dbf8d94b9ce53,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_67_p_enum_specifier_2(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_67_p_enum_specifier_2,
        const_str_plain_p_enum_specifier_2,
#if PYTHON_VERSION >= 330
        const_str_digest_891e4ef06043254cd6f550a053fcf199,
#endif
        codeobj_795eb7c6f2350e65bc50540431566e11,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_7ba0fc454e8e35159e5df23ec4292d59,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_68_p_enum_specifier_3(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_68_p_enum_specifier_3,
        const_str_plain_p_enum_specifier_3,
#if PYTHON_VERSION >= 330
        const_str_digest_ef5470f8407896db734faec9dc576857,
#endif
        codeobj_bdb3c9c7f520adbb0bb977e5f55bd902,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_c7350461c8319ccb9b869ca9d757d071,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_69_p_enumerator_list(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_69_p_enumerator_list,
        const_str_plain_p_enumerator_list,
#if PYTHON_VERSION >= 330
        const_str_digest_b8f2e1eb7155c9c1f218f399b31285ac,
#endif
        codeobj_f82d0149f91c7c324123f2efb235c3aa,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_b662c5a69a6a4f6634e2c2fb3d230a44,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_6__add_identifier(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_6__add_identifier,
        const_str_plain__add_identifier,
#if PYTHON_VERSION >= 330
        const_str_digest_91fe4d48c7f332f506ad592767e0b1fa,
#endif
        codeobj_288dc4e82434f2e66f5d247261ad8ef7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_4d2282977f5acc83443a234c654eb96e,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_70_p_enumerator(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_70_p_enumerator,
        const_str_plain_p_enumerator,
#if PYTHON_VERSION >= 330
        const_str_digest_c7dec89123121915f4b9612d61ec875a,
#endif
        codeobj_fc36fad08403ba995c218b757a509878,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_4d5064fee01745e0edfcfd695c906323,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_71_p_declarator(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_71_p_declarator,
        const_str_plain_p_declarator,
#if PYTHON_VERSION >= 330
        const_str_digest_eae5a57ac505c9fd51dcee063c70c12f,
#endif
        codeobj_337331efd9e8b98ec904248b5729d4b7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_0e25af74743e7bbe803c3850cf908d5e,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_72_p_xxx_declarator_1(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_72_p_xxx_declarator_1,
        const_str_plain_p_xxx_declarator_1,
#if PYTHON_VERSION >= 330
        const_str_digest_99ef339a31ce34c0e20749e73057955b,
#endif
        codeobj_8b41c2cd19aa34d145a09e06a36a06d1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_791b8912d692e91ab59be831ef8bc1a7,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_73_p_xxx_declarator_2(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_73_p_xxx_declarator_2,
        const_str_plain_p_xxx_declarator_2,
#if PYTHON_VERSION >= 330
        const_str_digest_0469223446185989541f16e54e881c26,
#endif
        codeobj_98e40246e2cc3f8becdbf3e10cd918f2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_7aa878e9a432a70b1be9c111bdefc021,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_74_p_direct_xxx_declarator_1(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_74_p_direct_xxx_declarator_1,
        const_str_plain_p_direct_xxx_declarator_1,
#if PYTHON_VERSION >= 330
        const_str_digest_90a2bfabec7dd4c758b77580ec12f8b8,
#endif
        codeobj_10aeb59019f195c42eae9c75e055c5a0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_30531a534a7c297aabfd46265292dec4,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_75_p_direct_xxx_declarator_2(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_75_p_direct_xxx_declarator_2,
        const_str_plain_p_direct_xxx_declarator_2,
#if PYTHON_VERSION >= 330
        const_str_digest_fb1821a12d9337038c5f0ba339bff7bc,
#endif
        codeobj_b6926e29a605bdf62681337c32c04bf6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_b69fc3ce48390b0e9cfa18d81a30a6e0,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_76_p_direct_xxx_declarator_3(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_76_p_direct_xxx_declarator_3,
        const_str_plain_p_direct_xxx_declarator_3,
#if PYTHON_VERSION >= 330
        const_str_digest_25da212803d8c0d225df3dfd19d548d9,
#endif
        codeobj_27d82a838ba49194322163c62da6de8b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_3f66b33dcd02380a3b34f7c175ab47ca,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_77_p_direct_xxx_declarator_4(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_77_p_direct_xxx_declarator_4,
        const_str_plain_p_direct_xxx_declarator_4,
#if PYTHON_VERSION >= 330
        const_str_digest_59d40c66bd1068fb9a5fac1ba3853f9d,
#endif
        codeobj_b329363a2e1d615669c61b6bf24bd116,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_2e1cbe41f85e408c79a828dbf5edff43,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_78_p_direct_xxx_declarator_5(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_78_p_direct_xxx_declarator_5,
        const_str_plain_p_direct_xxx_declarator_5,
#if PYTHON_VERSION >= 330
        const_str_digest_3e10b62863993a2cc69fa833b1c10828,
#endif
        codeobj_ed4050f5ceb4859fce3f8015827a9ddd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_4d9f5a102c6e338e4518642310a06235,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_79_p_direct_xxx_declarator_6(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_79_p_direct_xxx_declarator_6,
        const_str_plain_p_direct_xxx_declarator_6,
#if PYTHON_VERSION >= 330
        const_str_digest_bf7acc4751dc5b6ecae6da620bd3895d,
#endif
        codeobj_e4b4c3a4569c493600c917b20c1f31dd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_c5fd27a7e790f10912398117eb633879,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_7__is_type_in_scope(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_7__is_type_in_scope,
        const_str_plain__is_type_in_scope,
#if PYTHON_VERSION >= 330
        const_str_digest_4c53af9b18e731d13a6eaff3cd61c1bd,
#endif
        codeobj_f288e41b499202bc1365c10c60a14f5b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_192b105d8a394fb0ecdd5413c89d71d5,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_80_p_pointer(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_80_p_pointer,
        const_str_plain_p_pointer,
#if PYTHON_VERSION >= 330
        const_str_digest_d73a0191fa324324a6b46a5358fae01c,
#endif
        codeobj_878a1c18fbce981d7e9ea80408cd4b98,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_5dd9b87f6fa196442177a7da624a6140,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_81_p_type_qualifier_list(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_81_p_type_qualifier_list,
        const_str_plain_p_type_qualifier_list,
#if PYTHON_VERSION >= 330
        const_str_digest_e86f7034b1998ca0fd1f83fbc241f439,
#endif
        codeobj_5d32d7d5b0f216e650e8a6ecb453fe6c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_6a4952e047321440db18a38bf73040e5,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_82_p_parameter_type_list(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_82_p_parameter_type_list,
        const_str_plain_p_parameter_type_list,
#if PYTHON_VERSION >= 330
        const_str_digest_61cb30757fb84ded43723d45db63c47d,
#endif
        codeobj_11b37f28b0696e358af2a7dcdff91c68,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_17cc52e14b6c1f7ad77cb5c85591f124,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_83_p_parameter_list(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_83_p_parameter_list,
        const_str_plain_p_parameter_list,
#if PYTHON_VERSION >= 330
        const_str_digest_8e675f7522c50836436091bad083eade,
#endif
        codeobj_33c782c9369ccb6646fd10ca5266b9cf,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_94f4c600d0330853c740c988770a5205,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_84_p_parameter_declaration_1(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_84_p_parameter_declaration_1,
        const_str_plain_p_parameter_declaration_1,
#if PYTHON_VERSION >= 330
        const_str_digest_98df06d490521f0a00d6ac5b08c499e6,
#endif
        codeobj_1802192b2a03b205fa58a441ed52b1bb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_85edeba66ecd8010a3ffbe3e744f2716,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_85_p_parameter_declaration_2(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_85_p_parameter_declaration_2,
        const_str_plain_p_parameter_declaration_2,
#if PYTHON_VERSION >= 330
        const_str_digest_c0efe027b7adc1ecc803adc6bf777f4f,
#endif
        codeobj_ec7e7fa34698fe0d0aeabdfc87e00cd0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_534b5bcecbd2c4f39a6a03b6e5d0a4d9,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_86_p_identifier_list(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_86_p_identifier_list,
        const_str_plain_p_identifier_list,
#if PYTHON_VERSION >= 330
        const_str_digest_be14d60093071f59d0507692040d9a94,
#endif
        codeobj_867142bdf96c9102a846ef71dc64dcbc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_e01c24288bb4a048bc585c985f9198c6,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_87_p_initializer_1(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_87_p_initializer_1,
        const_str_plain_p_initializer_1,
#if PYTHON_VERSION >= 330
        const_str_digest_1f8992215f1ce67405c35060612647fa,
#endif
        codeobj_3286b72abfbf9883a8da41cbb843f21f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_6fd75982f2b711afbab1aec5063c9027,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_88_p_initializer_2(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_88_p_initializer_2,
        const_str_plain_p_initializer_2,
#if PYTHON_VERSION >= 330
        const_str_digest_294b43969495463422d51c2e0af683fa,
#endif
        codeobj_2981cd55a1d00047fb71fd4a3e5caa1e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_03c3aa4a35ee337fabd3abd65350cf72,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_89_p_initializer_list(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_89_p_initializer_list,
        const_str_plain_p_initializer_list,
#if PYTHON_VERSION >= 330
        const_str_digest_9d630abb686b7666019838011d097aa8,
#endif
        codeobj_7bdedbef7a00776795107daa1bc963d5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_df007a6e044b925abf12d22b7ef3ea75,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_8__lex_error_func(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_8__lex_error_func,
        const_str_plain__lex_error_func,
#if PYTHON_VERSION >= 330
        const_str_digest_2dcd182a11e70168432f85bd4916de3f,
#endif
        codeobj_f1cc1ced8689c1a73b6a22276b413658,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_90_p_designation(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_90_p_designation,
        const_str_plain_p_designation,
#if PYTHON_VERSION >= 330
        const_str_digest_ad6ead784d30f848fe6914fe2453eb23,
#endif
        codeobj_85094ef0f04670a999427ff66a78ee6f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_1a96c17db4422135332fc034b84b4f5e,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_91_p_designator_list(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_91_p_designator_list,
        const_str_plain_p_designator_list,
#if PYTHON_VERSION >= 330
        const_str_digest_3f8b6aa31a0455c8989a7d5ca708b30b,
#endif
        codeobj_52eb0d57f6175eba75633633bbe54ef2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_246f58de0d8282544b0f16b8e9adffe7,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_92_p_designator(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_92_p_designator,
        const_str_plain_p_designator,
#if PYTHON_VERSION >= 330
        const_str_digest_3527e2c43140c9c3fd5fb7fcbbe9a457,
#endif
        codeobj_c0feafe8bd77b3b88cd6575e93ee8a8a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_fb8cb72a47e4e6a97db78d6f2a14c1a9,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_93_p_type_name(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_93_p_type_name,
        const_str_plain_p_type_name,
#if PYTHON_VERSION >= 330
        const_str_digest_16dd3aa8de123b64723e9d3f1db8a05b,
#endif
        codeobj_febe702af8a1cd2b2bf16ba9e9fd3f58,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_d3b46ce600868fd3d7716c8dd7a08173,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_94_p_abstract_declarator_1(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_94_p_abstract_declarator_1,
        const_str_plain_p_abstract_declarator_1,
#if PYTHON_VERSION >= 330
        const_str_digest_6dbcd0ad6d3e522de8841a8354327179,
#endif
        codeobj_ac70248d42fae48a157ba1db8b5e4a7b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_f4c586e057933351dce958e95b28310c,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_95_p_abstract_declarator_2(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_95_p_abstract_declarator_2,
        const_str_plain_p_abstract_declarator_2,
#if PYTHON_VERSION >= 330
        const_str_digest_7c7abce5be464c1a2373a819305d6607,
#endif
        codeobj_51b554cea9d0e7f1e3adf8f99cc405e4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_732bc606378f1eac79e58256e6deeaca,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_96_p_abstract_declarator_3(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_96_p_abstract_declarator_3,
        const_str_plain_p_abstract_declarator_3,
#if PYTHON_VERSION >= 330
        const_str_digest_0cf7bbaa709fa7445d261c18853462db,
#endif
        codeobj_dbbbd791f6d9a09e74dbfc14504f2e29,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_d13b4c87d8a8852eb743b212f8d676d6,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_97_p_direct_abstract_declarator_1(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_97_p_direct_abstract_declarator_1,
        const_str_plain_p_direct_abstract_declarator_1,
#if PYTHON_VERSION >= 330
        const_str_digest_7d9088072ecc638c9f57de60088a1028,
#endif
        codeobj_5257b1cf3d2353a8c350ec764d19c8d2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_0594790bab68d7c87f42d25d5c5e4a6b,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_98_p_direct_abstract_declarator_2(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_98_p_direct_abstract_declarator_2,
        const_str_plain_p_direct_abstract_declarator_2,
#if PYTHON_VERSION >= 330
        const_str_digest_12b5d80dbab35a1fee3c7294bdecc060,
#endif
        codeobj_f10314a14c8ac1925cc08a640435747f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_5ce94e49f4392eb90c8c6d62708b5382,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_99_p_direct_abstract_declarator_3(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_99_p_direct_abstract_declarator_3,
        const_str_plain_p_direct_abstract_declarator_3,
#if PYTHON_VERSION >= 330
        const_str_digest_54641dd2781e3ae796914e2648dd7e3c,
#endif
        codeobj_5290c3915469426265e7f52d66a998a4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        const_str_digest_7525f41ae25b32b5ae040b76992d907b,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_pycparser$c_parser$$$class_1_CParser$$$function_9__lex_on_lbrace_func(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_pycparser$c_parser$$$class_1_CParser$$$function_9__lex_on_lbrace_func,
        const_str_plain__lex_on_lbrace_func,
#if PYTHON_VERSION >= 330
        const_str_digest_ed337dbead15c0fdcf05f046938efb38,
#endif
        codeobj_a0f37948e5f35b331da261a1dc94d087,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_pycparser$c_parser,
        Py_None,
        0
    );


    return (PyObject *)result;
}



#if PYTHON_VERSION >= 300
static struct PyModuleDef mdef_pycparser$c_parser =
{
    PyModuleDef_HEAD_INIT,
    "pycparser.c_parser",   /* m_name */
    NULL,                /* m_doc */
    -1,                  /* m_size */
    NULL,                /* m_methods */
    NULL,                /* m_reload */
    NULL,                /* m_traverse */
    NULL,                /* m_clear */
    NULL,                /* m_free */
  };
#endif

#if PYTHON_VERSION >= 300
extern PyObject *metapath_based_loader;
#endif
#if PYTHON_VERSION >= 330
extern PyObject *const_str_plain___loader__;
#endif

extern void _initCompiledCellType();
extern void _initCompiledGeneratorType();
extern void _initCompiledFunctionType();
extern void _initCompiledMethodType();
extern void _initCompiledFrameType();
#if PYTHON_VERSION >= 350
extern void _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
extern void _initCompiledAsyncgenTypes();
#endif

// The exported interface to CPython. On import of the module, this function
// gets called. It has to have an exact function name, in cases it's a shared
// library export. This is hidden behind the MOD_INIT_DECL.

MOD_INIT_DECL( pycparser$c_parser )
{
#if defined(_NUITKA_EXE) || PYTHON_VERSION >= 300
    static bool _init_done = false;

    // Modules might be imported repeatedly, which is to be ignored.
    if ( _init_done )
    {
        return MOD_RETURN_VALUE( module_pycparser$c_parser );
    }
    else
    {
        _init_done = true;
    }
#endif

#ifdef _NUITKA_MODULE
    // In case of a stand alone extension module, need to call initialization
    // the init here because that's the first and only time we are going to get
    // called here.

    // Initialize the constant values used.
    _initBuiltinModule();
    createGlobalConstants();

    /* Initialize the compiled types of Nuitka. */
    _initCompiledCellType();
    _initCompiledGeneratorType();
    _initCompiledFunctionType();
    _initCompiledMethodType();
    _initCompiledFrameType();
#if PYTHON_VERSION >= 350
    _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
    _initCompiledAsyncgenTypes();
#endif

#if PYTHON_VERSION < 300
    _initSlotCompare();
#endif
#if PYTHON_VERSION >= 270
    _initSlotIternext();
#endif

    patchBuiltinModule();
    patchTypeComparison();

    // Enable meta path based loader if not already done.
    setupMetaPathBasedLoader();

#if PYTHON_VERSION >= 300
    patchInspectModule();
#endif

#endif

    /* The constants only used by this module are created now. */
#ifdef _NUITKA_TRACE
    puts("pycparser.c_parser: Calling createModuleConstants().");
#endif
    createModuleConstants();

    /* The code objects used by this module are created now. */
#ifdef _NUITKA_TRACE
    puts("pycparser.c_parser: Calling createModuleCodeObjects().");
#endif
    createModuleCodeObjects();

    // puts( "in initpycparser$c_parser" );

    // Create the module object first. There are no methods initially, all are
    // added dynamically in actual code only.  Also no "__doc__" is initially
    // set at this time, as it could not contain NUL characters this way, they
    // are instead set in early module code.  No "self" for modules, we have no
    // use for it.
#if PYTHON_VERSION < 300
    module_pycparser$c_parser = Py_InitModule4(
        "pycparser.c_parser",       // Module Name
        NULL,                    // No methods initially, all are added
                                 // dynamically in actual module code only.
        NULL,                    // No __doc__ is initially set, as it could
                                 // not contain NUL this way, added early in
                                 // actual code.
        NULL,                    // No self for modules, we don't use it.
        PYTHON_API_VERSION
    );
#else
    module_pycparser$c_parser = PyModule_Create( &mdef_pycparser$c_parser );
#endif

    moduledict_pycparser$c_parser = (PyDictObject *)((PyModuleObject *)module_pycparser$c_parser)->md_dict;

    CHECK_OBJECT( module_pycparser$c_parser );

// Seems to work for Python2.7 out of the box, but for Python3, the module
// doesn't automatically enter "sys.modules", so do it manually.
#if PYTHON_VERSION >= 300
    {
        int r = PyObject_SetItem( PySys_GetObject( (char *)"modules" ), const_str_digest_738bb76ee3cb1d75ac2eedcc90bfedb8, module_pycparser$c_parser );

        assert( r != -1 );
    }
#endif

    // For deep importing of a module we need to have "__builtins__", so we set
    // it ourselves in the same way than CPython does. Note: This must be done
    // before the frame object is allocated, or else it may fail.

    PyObject *module_dict = PyModule_GetDict( module_pycparser$c_parser );

    if ( PyDict_GetItem( module_dict, const_str_plain___builtins__ ) == NULL )
    {
        PyObject *value = (PyObject *)builtin_module;

        // Check if main module, not a dict then.
#if !defined(_NUITKA_EXE) || !0
        value = PyModule_GetDict( value );
#endif

#ifndef __NUITKA_NO_ASSERT__
        int res =
#endif
            PyDict_SetItem( module_dict, const_str_plain___builtins__, value );

        assert( res == 0 );
    }

#if PYTHON_VERSION >= 330
    PyDict_SetItem( module_dict, const_str_plain___loader__, metapath_based_loader );
#endif

    // Temp variables if any
    PyObject *tmp_import_from_1__module = NULL;
    PyObject *tmp_pycparser$c_parser_class_creation_1__bases = NULL;
    PyObject *tmp_pycparser$c_parser_class_creation_1__class_decl_dict = NULL;
    PyObject *tmp_pycparser$c_parser_class_creation_1__metaclass = NULL;
    PyObject *tmp_pycparser$c_parser_class_creation_1__prepared = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_assign_source_12;
    PyObject *tmp_assign_source_13;
    PyObject *tmp_assign_source_14;
    PyObject *tmp_assign_source_15;
    PyObject *tmp_assign_source_16;
    PyObject *tmp_assign_source_17;
    PyObject *tmp_assign_source_18;
    PyObject *tmp_assign_source_19;
    PyObject *tmp_assign_source_20;
    PyObject *tmp_bases_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cmp_In_1;
    int tmp_cmp_In_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_dict_name_1;
    PyObject *tmp_dictdel_dict;
    PyObject *tmp_dictdel_key;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_fromlist_name_2;
    PyObject *tmp_fromlist_name_3;
    PyObject *tmp_fromlist_name_4;
    PyObject *tmp_fromlist_name_5;
    PyObject *tmp_fromlist_name_6;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_globals_name_2;
    PyObject *tmp_globals_name_3;
    PyObject *tmp_globals_name_4;
    PyObject *tmp_globals_name_5;
    PyObject *tmp_globals_name_6;
    PyObject *tmp_hasattr_attr_1;
    PyObject *tmp_hasattr_source_1;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_import_name_from_2;
    PyObject *tmp_import_name_from_3;
    PyObject *tmp_import_name_from_4;
    PyObject *tmp_import_name_from_5;
    PyObject *tmp_import_name_from_6;
    PyObject *tmp_import_name_from_7;
    PyObject *tmp_import_name_from_8;
    PyObject *tmp_import_name_from_9;
    PyObject *tmp_key_name_1;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_level_name_1;
    PyObject *tmp_level_name_2;
    PyObject *tmp_level_name_3;
    PyObject *tmp_level_name_4;
    PyObject *tmp_level_name_5;
    PyObject *tmp_level_name_6;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_locals_name_2;
    PyObject *tmp_locals_name_3;
    PyObject *tmp_locals_name_4;
    PyObject *tmp_locals_name_5;
    PyObject *tmp_locals_name_6;
    PyObject *tmp_metaclass_name_1;
    PyObject *tmp_name_name_1;
    PyObject *tmp_name_name_2;
    PyObject *tmp_name_name_3;
    PyObject *tmp_name_name_4;
    PyObject *tmp_name_name_5;
    PyObject *tmp_name_name_6;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_source_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_tuple_element_2;
    PyObject *tmp_type_arg_1;
    struct Nuitka_FrameObject *frame_09fa059b553ec32ab362c24c2ae782a0;


    // Module code.
    tmp_assign_source_1 = Py_None;
    UPDATE_STRING_DICT0( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain___doc__, tmp_assign_source_1 );
    tmp_assign_source_2 = module_filename_obj;
    UPDATE_STRING_DICT0( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain___file__, tmp_assign_source_2 );
    tmp_assign_source_3 = Py_None;
    UPDATE_STRING_DICT0( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain___cached__, tmp_assign_source_3 );
    tmp_assign_source_4 = const_str_plain_pycparser;
    UPDATE_STRING_DICT0( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain___package__, tmp_assign_source_4 );
    // Frame without reuse.
    frame_09fa059b553ec32ab362c24c2ae782a0 = MAKE_MODULE_FRAME( codeobj_09fa059b553ec32ab362c24c2ae782a0, module_pycparser$c_parser );

    // Push the new frame as the currently active one, and we should be exclusively
    // owning it.
    pushFrameStack( frame_09fa059b553ec32ab362c24c2ae782a0 );
    assert( Py_REFCNT( frame_09fa059b553ec32ab362c24c2ae782a0 ) == 2 );

    // Framed code:
    tmp_name_name_1 = const_str_plain_re;
    tmp_globals_name_1 = ((PyModuleObject *)module_pycparser$c_parser)->md_dict;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = Py_None;
    tmp_level_name_1 = const_int_0;
    frame_09fa059b553ec32ab362c24c2ae782a0->m_frame.f_lineno = 9;
    tmp_assign_source_5 = IMPORT_MODULE5( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1, tmp_level_name_1 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 9;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_re, tmp_assign_source_5 );
    tmp_name_name_2 = const_str_plain_ply;
    tmp_globals_name_2 = ((PyModuleObject *)module_pycparser$c_parser)->md_dict;
    tmp_locals_name_2 = Py_None;
    tmp_fromlist_name_2 = const_tuple_str_plain_yacc_tuple;
    tmp_level_name_2 = const_int_pos_1;
    frame_09fa059b553ec32ab362c24c2ae782a0->m_frame.f_lineno = 11;
    tmp_import_name_from_1 = IMPORT_MODULE5( tmp_name_name_2, tmp_globals_name_2, tmp_locals_name_2, tmp_fromlist_name_2, tmp_level_name_2 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 11;

        goto frame_exception_exit_1;
    }
    tmp_assign_source_6 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_yacc );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 11;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_yacc, tmp_assign_source_6 );
    tmp_name_name_3 = const_str_empty;
    tmp_globals_name_3 = ((PyModuleObject *)module_pycparser$c_parser)->md_dict;
    tmp_locals_name_3 = Py_None;
    tmp_fromlist_name_3 = const_tuple_str_plain_c_ast_tuple;
    tmp_level_name_3 = const_int_pos_1;
    frame_09fa059b553ec32ab362c24c2ae782a0->m_frame.f_lineno = 13;
    tmp_import_name_from_2 = IMPORT_MODULE5( tmp_name_name_3, tmp_globals_name_3, tmp_locals_name_3, tmp_fromlist_name_3, tmp_level_name_3 );
    if ( tmp_import_name_from_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 13;

        goto frame_exception_exit_1;
    }
    tmp_assign_source_7 = IMPORT_NAME( tmp_import_name_from_2, const_str_plain_c_ast );
    Py_DECREF( tmp_import_name_from_2 );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 13;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_c_ast, tmp_assign_source_7 );
    tmp_name_name_4 = const_str_plain_c_lexer;
    tmp_globals_name_4 = ((PyModuleObject *)module_pycparser$c_parser)->md_dict;
    tmp_locals_name_4 = Py_None;
    tmp_fromlist_name_4 = const_tuple_str_plain_CLexer_tuple;
    tmp_level_name_4 = const_int_pos_1;
    frame_09fa059b553ec32ab362c24c2ae782a0->m_frame.f_lineno = 14;
    tmp_import_name_from_3 = IMPORT_MODULE5( tmp_name_name_4, tmp_globals_name_4, tmp_locals_name_4, tmp_fromlist_name_4, tmp_level_name_4 );
    if ( tmp_import_name_from_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 14;

        goto frame_exception_exit_1;
    }
    tmp_assign_source_8 = IMPORT_NAME( tmp_import_name_from_3, const_str_plain_CLexer );
    Py_DECREF( tmp_import_name_from_3 );
    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 14;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_CLexer, tmp_assign_source_8 );
    tmp_name_name_5 = const_str_plain_plyparser;
    tmp_globals_name_5 = ((PyModuleObject *)module_pycparser$c_parser)->md_dict;
    tmp_locals_name_5 = Py_None;
    tmp_fromlist_name_5 = const_tuple_0ea225ba60de122d0cbb5d84b83eeb1c_tuple;
    tmp_level_name_5 = const_int_pos_1;
    frame_09fa059b553ec32ab362c24c2ae782a0->m_frame.f_lineno = 15;
    tmp_assign_source_9 = IMPORT_MODULE5( tmp_name_name_5, tmp_globals_name_5, tmp_locals_name_5, tmp_fromlist_name_5, tmp_level_name_5 );
    if ( tmp_assign_source_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 15;

        goto frame_exception_exit_1;
    }
    assert( tmp_import_from_1__module == NULL );
    tmp_import_from_1__module = tmp_assign_source_9;

    // Tried code:
    tmp_import_name_from_4 = tmp_import_from_1__module;

    CHECK_OBJECT( tmp_import_name_from_4 );
    tmp_assign_source_10 = IMPORT_NAME( tmp_import_name_from_4, const_str_plain_PLYParser );
    if ( tmp_assign_source_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 15;

        goto try_except_handler_1;
    }
    UPDATE_STRING_DICT1( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_PLYParser, tmp_assign_source_10 );
    tmp_import_name_from_5 = tmp_import_from_1__module;

    CHECK_OBJECT( tmp_import_name_from_5 );
    tmp_assign_source_11 = IMPORT_NAME( tmp_import_name_from_5, const_str_plain_Coord );
    if ( tmp_assign_source_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 15;

        goto try_except_handler_1;
    }
    UPDATE_STRING_DICT1( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_Coord, tmp_assign_source_11 );
    tmp_import_name_from_6 = tmp_import_from_1__module;

    CHECK_OBJECT( tmp_import_name_from_6 );
    tmp_assign_source_12 = IMPORT_NAME( tmp_import_name_from_6, const_str_plain_ParseError );
    if ( tmp_assign_source_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 15;

        goto try_except_handler_1;
    }
    UPDATE_STRING_DICT1( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_ParseError, tmp_assign_source_12 );
    tmp_import_name_from_7 = tmp_import_from_1__module;

    CHECK_OBJECT( tmp_import_name_from_7 );
    tmp_assign_source_13 = IMPORT_NAME( tmp_import_name_from_7, const_str_plain_parameterized );
    if ( tmp_assign_source_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 15;

        goto try_except_handler_1;
    }
    UPDATE_STRING_DICT1( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_parameterized, tmp_assign_source_13 );
    tmp_import_name_from_8 = tmp_import_from_1__module;

    CHECK_OBJECT( tmp_import_name_from_8 );
    tmp_assign_source_14 = IMPORT_NAME( tmp_import_name_from_8, const_str_plain_template );
    if ( tmp_assign_source_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 15;

        goto try_except_handler_1;
    }
    UPDATE_STRING_DICT1( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_template, tmp_assign_source_14 );
    goto try_end_1;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_import_from_1__module );
    tmp_import_from_1__module = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    Py_XDECREF( tmp_import_from_1__module );
    tmp_import_from_1__module = NULL;

    tmp_name_name_6 = const_str_plain_ast_transforms;
    tmp_globals_name_6 = ((PyModuleObject *)module_pycparser$c_parser)->md_dict;
    tmp_locals_name_6 = Py_None;
    tmp_fromlist_name_6 = const_tuple_str_plain_fix_switch_cases_tuple;
    tmp_level_name_6 = const_int_pos_1;
    frame_09fa059b553ec32ab362c24c2ae782a0->m_frame.f_lineno = 16;
    tmp_import_name_from_9 = IMPORT_MODULE5( tmp_name_name_6, tmp_globals_name_6, tmp_locals_name_6, tmp_fromlist_name_6, tmp_level_name_6 );
    if ( tmp_import_name_from_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 16;

        goto frame_exception_exit_1;
    }
    tmp_assign_source_15 = IMPORT_NAME( tmp_import_name_from_9, const_str_plain_fix_switch_cases );
    Py_DECREF( tmp_import_name_from_9 );
    if ( tmp_assign_source_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 16;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_fix_switch_cases, tmp_assign_source_15 );
    // Tried code:
    tmp_assign_source_16 = PyTuple_New( 1 );
    tmp_tuple_element_1 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_PLYParser );

    if (unlikely( tmp_tuple_element_1 == NULL ))
    {
        tmp_tuple_element_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PLYParser );
    }

    if ( tmp_tuple_element_1 == NULL )
    {
        Py_DECREF( tmp_assign_source_16 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "PLYParser" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 20;

        goto try_except_handler_2;
    }

    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_assign_source_16, 0, tmp_tuple_element_1 );
    assert( tmp_pycparser$c_parser_class_creation_1__bases == NULL );
    tmp_pycparser$c_parser_class_creation_1__bases = tmp_assign_source_16;

    tmp_assign_source_17 = PyDict_New();
    assert( tmp_pycparser$c_parser_class_creation_1__class_decl_dict == NULL );
    tmp_pycparser$c_parser_class_creation_1__class_decl_dict = tmp_assign_source_17;

    tmp_compare_left_1 = const_str_plain_metaclass;
    tmp_compare_right_1 = tmp_pycparser$c_parser_class_creation_1__class_decl_dict;

    CHECK_OBJECT( tmp_compare_right_1 );
    tmp_cmp_In_1 = PySequence_Contains( tmp_compare_right_1, tmp_compare_left_1 );
    assert( !(tmp_cmp_In_1 == -1) );
    if ( tmp_cmp_In_1 == 1 )
    {
        goto condexpr_true_1;
    }
    else
    {
        goto condexpr_false_1;
    }
    condexpr_true_1:;
    tmp_dict_name_1 = tmp_pycparser$c_parser_class_creation_1__class_decl_dict;

    CHECK_OBJECT( tmp_dict_name_1 );
    tmp_key_name_1 = const_str_plain_metaclass;
    tmp_metaclass_name_1 = DICT_GET_ITEM( tmp_dict_name_1, tmp_key_name_1 );
    if ( tmp_metaclass_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 20;

        goto try_except_handler_2;
    }
    goto condexpr_end_1;
    condexpr_false_1:;
    tmp_cond_value_1 = tmp_pycparser$c_parser_class_creation_1__bases;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 20;

        goto try_except_handler_2;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto condexpr_true_2;
    }
    else
    {
        goto condexpr_false_2;
    }
    condexpr_true_2:;
    tmp_subscribed_name_1 = tmp_pycparser$c_parser_class_creation_1__bases;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_0;
    tmp_type_arg_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_type_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 20;

        goto try_except_handler_2;
    }
    tmp_metaclass_name_1 = BUILTIN_TYPE1( tmp_type_arg_1 );
    Py_DECREF( tmp_type_arg_1 );
    if ( tmp_metaclass_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 20;

        goto try_except_handler_2;
    }
    goto condexpr_end_2;
    condexpr_false_2:;
    tmp_metaclass_name_1 = (PyObject *)&PyType_Type;
    Py_INCREF( tmp_metaclass_name_1 );
    condexpr_end_2:;
    condexpr_end_1:;
    tmp_bases_name_1 = tmp_pycparser$c_parser_class_creation_1__bases;

    CHECK_OBJECT( tmp_bases_name_1 );
    tmp_assign_source_18 = SELECT_METACLASS( tmp_metaclass_name_1, tmp_bases_name_1 );
    if ( tmp_assign_source_18 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_metaclass_name_1 );

        exception_lineno = 20;

        goto try_except_handler_2;
    }
    Py_DECREF( tmp_metaclass_name_1 );
    assert( tmp_pycparser$c_parser_class_creation_1__metaclass == NULL );
    tmp_pycparser$c_parser_class_creation_1__metaclass = tmp_assign_source_18;

    tmp_compare_left_2 = const_str_plain_metaclass;
    tmp_compare_right_2 = tmp_pycparser$c_parser_class_creation_1__class_decl_dict;

    CHECK_OBJECT( tmp_compare_right_2 );
    tmp_cmp_In_2 = PySequence_Contains( tmp_compare_right_2, tmp_compare_left_2 );
    assert( !(tmp_cmp_In_2 == -1) );
    if ( tmp_cmp_In_2 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_dictdel_dict = tmp_pycparser$c_parser_class_creation_1__class_decl_dict;

    CHECK_OBJECT( tmp_dictdel_dict );
    tmp_dictdel_key = const_str_plain_metaclass;
    tmp_result = DICT_REMOVE_ITEM( tmp_dictdel_dict, tmp_dictdel_key );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 20;

        goto try_except_handler_2;
    }
    branch_no_1:;
    tmp_hasattr_source_1 = tmp_pycparser$c_parser_class_creation_1__metaclass;

    CHECK_OBJECT( tmp_hasattr_source_1 );
    tmp_hasattr_attr_1 = const_str_plain___prepare__;
    tmp_res = PyObject_HasAttr( tmp_hasattr_source_1, tmp_hasattr_attr_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 20;

        goto try_except_handler_2;
    }
    if ( tmp_res == 1 )
    {
        goto condexpr_true_3;
    }
    else
    {
        goto condexpr_false_3;
    }
    condexpr_true_3:;
    tmp_source_name_1 = tmp_pycparser$c_parser_class_creation_1__metaclass;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain___prepare__ );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 20;

        goto try_except_handler_2;
    }
    tmp_args_name_1 = PyTuple_New( 2 );
    tmp_tuple_element_2 = const_str_plain_CParser;
    Py_INCREF( tmp_tuple_element_2 );
    PyTuple_SET_ITEM( tmp_args_name_1, 0, tmp_tuple_element_2 );
    tmp_tuple_element_2 = tmp_pycparser$c_parser_class_creation_1__bases;

    CHECK_OBJECT( tmp_tuple_element_2 );
    Py_INCREF( tmp_tuple_element_2 );
    PyTuple_SET_ITEM( tmp_args_name_1, 1, tmp_tuple_element_2 );
    tmp_kw_name_1 = tmp_pycparser$c_parser_class_creation_1__class_decl_dict;

    CHECK_OBJECT( tmp_kw_name_1 );
    frame_09fa059b553ec32ab362c24c2ae782a0->m_frame.f_lineno = 20;
    tmp_assign_source_19 = CALL_FUNCTION( tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_name_1 );
    if ( tmp_assign_source_19 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 20;

        goto try_except_handler_2;
    }
    goto condexpr_end_3;
    condexpr_false_3:;
    tmp_assign_source_19 = PyDict_New();
    condexpr_end_3:;
    assert( tmp_pycparser$c_parser_class_creation_1__prepared == NULL );
    tmp_pycparser$c_parser_class_creation_1__prepared = tmp_assign_source_19;

    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_template );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_template );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyUnicode_FromFormat( "name '%s' is not defined", "template" );
        exception_tb = NULL;
        NORMALIZE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
        CHAIN_EXCEPTION( exception_value );

        exception_lineno = 19;

        goto try_except_handler_2;
    }

    tmp_args_element_name_1 = impl_pycparser$c_parser$$$class_1_CParser( NULL, &tmp_pycparser$c_parser_class_creation_1__bases, &tmp_pycparser$c_parser_class_creation_1__class_decl_dict, &tmp_pycparser$c_parser_class_creation_1__metaclass, &tmp_pycparser$c_parser_class_creation_1__prepared );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 20;

        goto try_except_handler_2;
    }
    frame_09fa059b553ec32ab362c24c2ae782a0->m_frame.f_lineno = 19;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_20 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_20 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 19;

        goto try_except_handler_2;
    }
    UPDATE_STRING_DICT1( moduledict_pycparser$c_parser, (Nuitka_StringObject *)const_str_plain_CParser, tmp_assign_source_20 );
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF( tmp_pycparser$c_parser_class_creation_1__bases );
    tmp_pycparser$c_parser_class_creation_1__bases = NULL;

    Py_XDECREF( tmp_pycparser$c_parser_class_creation_1__class_decl_dict );
    tmp_pycparser$c_parser_class_creation_1__class_decl_dict = NULL;

    Py_XDECREF( tmp_pycparser$c_parser_class_creation_1__metaclass );
    tmp_pycparser$c_parser_class_creation_1__metaclass = NULL;

    Py_XDECREF( tmp_pycparser$c_parser_class_creation_1__prepared );
    tmp_pycparser$c_parser_class_creation_1__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

    // Restore frame exception if necessary.
#if 0
    RESTORE_FRAME_EXCEPTION( frame_09fa059b553ec32ab362c24c2ae782a0 );
#endif
    popFrameStack();

    assertFrameObject( frame_09fa059b553ec32ab362c24c2ae782a0 );

    goto frame_no_exception_1;
    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_09fa059b553ec32ab362c24c2ae782a0 );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_09fa059b553ec32ab362c24c2ae782a0, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_09fa059b553ec32ab362c24c2ae782a0->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_09fa059b553ec32ab362c24c2ae782a0, exception_lineno );
    }

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto module_exception_exit;
    frame_no_exception_1:;
    Py_XDECREF( tmp_pycparser$c_parser_class_creation_1__bases );
    tmp_pycparser$c_parser_class_creation_1__bases = NULL;

    Py_XDECREF( tmp_pycparser$c_parser_class_creation_1__class_decl_dict );
    tmp_pycparser$c_parser_class_creation_1__class_decl_dict = NULL;

    Py_XDECREF( tmp_pycparser$c_parser_class_creation_1__metaclass );
    tmp_pycparser$c_parser_class_creation_1__metaclass = NULL;

    Py_XDECREF( tmp_pycparser$c_parser_class_creation_1__prepared );
    tmp_pycparser$c_parser_class_creation_1__prepared = NULL;


    return MOD_RETURN_VALUE( module_pycparser$c_parser );
    module_exception_exit:
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );
    return MOD_RETURN_VALUE( NULL );
}
