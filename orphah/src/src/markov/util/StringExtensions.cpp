// Generated by Haxe 3.4.3
#include <hxcpp.h>

#ifndef INCLUDED_haxe_Utf8
#include <haxe/Utf8.h>
#endif
#ifndef INCLUDED_markov_util_StringExtensions
#include <markov/util/StringExtensions.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_a6cdc598bb5a3a15_16_reverse,"markov.util.StringExtensions","reverse",0xd9f1928b,"markov.util.StringExtensions.reverse","markov/util/StringExtensions.hx",16,0x506759e7)
HX_LOCAL_STACK_FRAME(_hx_pos_a6cdc598bb5a3a15_29_repeat,"markov.util.StringExtensions","repeat",0x97fd1e12,"markov.util.StringExtensions.repeat","markov/util/StringExtensions.hx",29,0x506759e7)
HX_LOCAL_STACK_FRAME(_hx_pos_a6cdc598bb5a3a15_45_contains,"markov.util.StringExtensions","contains",0x84343c96,"markov.util.StringExtensions.contains","markov/util/StringExtensions.hx",45,0x506759e7)
HX_LOCAL_STACK_FRAME(_hx_pos_a6cdc598bb5a3a15_61_capitalize,"markov.util.StringExtensions","capitalize",0x432bb7e3,"markov.util.StringExtensions.capitalize","markov/util/StringExtensions.hx",61,0x506759e7)
namespace markov{
namespace util{

void StringExtensions_obj::__construct() { }

Dynamic StringExtensions_obj::__CreateEmpty() { return new StringExtensions_obj; }

void *StringExtensions_obj::_hx_vtable = 0;

Dynamic StringExtensions_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< StringExtensions_obj > _hx_result = new StringExtensions_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool StringExtensions_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x16d8343f;
}

::String StringExtensions_obj::reverse(::String str){
            	HX_STACKFRAME(&_hx_pos_a6cdc598bb5a3a15_16_reverse)
HXLINE(  17)		if (!(hx::IsNotNull( str ))) {
HXLINE(  17)			HX_STACK_DO_THROW(HX_("FAIL: str != null",38,54,07,40));
            		}
HXLINE(  18)		::Array< ::String > arr = str.split(HX_("",00,00,00,00));
HXLINE(  19)		arr->reverse();
HXLINE(  20)		return arr->join(HX_("",00,00,00,00));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(StringExtensions_obj,reverse,return )

::String StringExtensions_obj::repeat(::String str,int times){
            	HX_STACKFRAME(&_hx_pos_a6cdc598bb5a3a15_29_repeat)
HXLINE(  30)		if (!(hx::IsNotNull( str ))) {
HXLINE(  30)			HX_STACK_DO_THROW(HX_("FAIL: str != null",38,54,07,40));
            		}
HXLINE(  31)		if (!((times >= (int)1))) {
HXLINE(  31)			HX_STACK_DO_THROW(HX_("FAIL: times >= 1",ae,97,08,7f));
            		}
HXLINE(  32)		::String output = HX_("",00,00,00,00);
HXLINE(  33)		{
HXLINE(  33)			int _g1 = (int)0;
HXDLIN(  33)			int _g = times;
HXDLIN(  33)			while((_g1 < _g)){
HXLINE(  33)				_g1 = (_g1 + (int)1);
HXDLIN(  33)				int i = (_g1 - (int)1);
HXLINE(  34)				output = (output + str);
            			}
            		}
HXLINE(  36)		return output;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(StringExtensions_obj,repeat,return )

bool StringExtensions_obj::contains(::String str,::String substr){
            	HX_STACKFRAME(&_hx_pos_a6cdc598bb5a3a15_45_contains)
HXLINE(  46)		if (!(hx::IsNotNull( str ))) {
HXLINE(  46)			HX_STACK_DO_THROW(HX_("FAIL: str != null",38,54,07,40));
            		}
HXLINE(  47)		if (!(hx::IsNotNull( substr ))) {
HXLINE(  47)			HX_STACK_DO_THROW(HX_("FAIL: substr != null",40,b3,95,38));
            		}
HXLINE(  52)		return (str.indexOf(substr,null()) >= (int)0);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(StringExtensions_obj,contains,return )

::String StringExtensions_obj::capitalize(::String str){
            	HX_STACKFRAME(&_hx_pos_a6cdc598bb5a3a15_61_capitalize)
HXLINE(  62)		if (!(hx::IsNotNull( str ))) {
HXLINE(  62)			HX_STACK_DO_THROW(HX_("FAIL: str != null",38,54,07,40));
            		}
HXLINE(  63)		::String _hx_tmp = ::haxe::Utf8_obj::sub(str,(int)0,(int)1).toUpperCase();
HXDLIN(  63)		return (_hx_tmp + ::haxe::Utf8_obj::sub(str,(int)1,(::haxe::Utf8_obj::length(str) - (int)1)));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(StringExtensions_obj,capitalize,return )


StringExtensions_obj::StringExtensions_obj()
{
}

bool StringExtensions_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"repeat") ) { outValue = repeat_dyn(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"reverse") ) { outValue = reverse_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"contains") ) { outValue = contains_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"capitalize") ) { outValue = capitalize_dyn(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *StringExtensions_obj_sMemberStorageInfo = 0;
static hx::StaticInfo *StringExtensions_obj_sStaticStorageInfo = 0;
#endif

static void StringExtensions_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(StringExtensions_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void StringExtensions_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(StringExtensions_obj::__mClass,"__mClass");
};

#endif

hx::Class StringExtensions_obj::__mClass;

static ::String StringExtensions_obj_sStaticFields[] = {
	HX_HCSTRING("reverse","\x22","\x39","\xfc","\x1a"),
	HX_HCSTRING("repeat","\x5b","\x97","\x7c","\x06"),
	HX_HCSTRING("contains","\x1f","\x5a","\x7b","\x2c"),
	HX_HCSTRING("capitalize","\xac","\x09","\x9c","\xe1"),
	::String(null())
};

void StringExtensions_obj::__register()
{
	hx::Object *dummy = new StringExtensions_obj;
	StringExtensions_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("markov.util.StringExtensions","\xd7","\xa8","\x3d","\xdd");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &StringExtensions_obj::__GetStatic;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = StringExtensions_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(StringExtensions_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< StringExtensions_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = StringExtensions_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = StringExtensions_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = StringExtensions_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace markov
} // end namespace util
